\chapter{Describing inductive definitions}

\section{Algebraic semantics}

\section{$\Set$-sorted inductive-inductive definitions}

We have mentioned that one of the defining features of the inductive
definitions we want to be able to handle, is any constructor may refer
to any of its previous constructors. Some examples we have seen of
this phenomenon are:
%
\begin{itemize}
\item the constructor $\intseg : \intzero = \intone$ of the interval
  type, $\intty$, which refers to both its previous constructor,
\item the constructor
  $\ttpi : (\Gamma : \ttconty) (A : \tttyty\ \Gamma) \to \tttyty\
  (\ttcons{\Gamma}{A}) \to \tttyty\ \Gamma$,
  which refers to the previous constructor
  $\ttcons{\_}{\_} : \Gamma : \ttconty) \to \tttyty\ \Gamma \to
  \ttconty$.
\end{itemize}

Describing inductive definitions with such constructors is not
something we can do with a single endofunctor on an appropriately
chosen category. Instead of having one functor, we need a functor for
every constructor. The domain of the $n$-th functor will then be the
``category of algebras of all previous constructors''. 

\begin{example}
  \label{silly-type}
  To illustrate this idea, we consider the following example (which we
  can easily show to be equivalent to the booleans):
  % 
  \begin{datatype}{\Tty}{\Type}
    \constr{\Ta}{\unitty \to \Tty} \\
    \constr{\Tb}{(t : \Tty) \times \Ta\ \unitval = t \to \Tty}
  \end{datatype}
  % 
\end{example}

The first constructor $\Ta$ can be described as being an $F_0$-algebra
structure on $\Tty$, with $F_0 : \Type \to \Type$ being defined as
$F_0 X \ddefeq \unitty$. The arguments of $\Tb$ are described by the
functor $F_1 : \algcat{F_0} \to \Type$ with:
$$
F_1 (X,a) \ddefeq (x : X) \times a\ \unitval = x
$$
Since $F_1$ is not an endofunctor, $\Tb$ cannot be described as an
$F_1$-algebra structure. However, $\algcat{F_0}$ comes with a
forgetful functor $U_0 : \algcat{U_0} \to \Type$ which gives us the
carrier of the algebra. We therefore have that
$\Tb : F_1(\Tty,\Ta) \to U_0(\Tty,\Ta)$, \ie $\Tb$ is an
$(F_1,U_0)$-\emph{dialgebra}~\cite{Hagino1987} structure on
$(\Tty,\Ta) : \algcat{F_0}$.
%
\begin{definition}
  \label{dialg}
  Let $F, G : \Cc \to \Dd$ be functors. The category $\dialgcat{F}{G}$ has
  as objects pairs $(X, \theta)$ where $X : |\Cc|$ and $\theta : F X \to
  G X$. A morphism from $(X, \theta)$ to $(Y, \rho)$ is a morphism $f : X
  \to Y$ in $\Cc$ such that the following commutes:
  $$
  \xymatrix{
  F X \ar[r]^{\theta} \ar[d]_{F f} &G X \ar[d]^{G f} \\
  G X \ar[r]^{\rho}  &G Y
  }
  $$
\end{definition}
%

As $\specty$ is essentially a list type, we will use list notation for
its values, \eg we denote $\specsnoc\ (\specsnoc\ F_0\ \specnil)\ F_1$
as $[F_0,F_1]$.

Any dialgebra category $\dialgcat{F}{G}$ comes with a forgetful
functor $U : \dialgcat{F}{G} \to \Cc$ which projects out the carrier
of the algebra. This means in particular that we have a forgetful
functor $U_1 : \dialgcat{F_1}{U_0} \to \algcat{F_0}$. If we were to
add a third and a fourth constructor, we would have to define a
functors $F_2 : \dialgcat{F_1}{U_0} \to \Type$ and
$F_3 : \dialgcat{F_2}{U_0 \circ U_1} \to \Type$ to describe
their arguments. The objects we are interested in are \emph{iterated}
dialgebras. For the situation described above we have:
$$
\xymatrix{
\Type 
\ar[d]_{F_0}
&\algcat{F_0} 
\ar[d]_{F_1}
\ar[l]_{U_0}
&\dialgcat{F_1}{U_0}
\ar[d]_{F_2}
\ar[l]_{U_1}
&\dialgcat{F_2}{U_0 \circ U_1}
\ar[d]_{F_3}
\ar[l]_{U_2}
&\dialgcat{F_3}{U_0 \circ U_1 \circ U_2}
\ar[l]_{U_3}
\\
\Type
&\Type
&\Type
&\Type
&
}
$$

Note that we build the category of dialgebras over another category of
dialgebras, \ie we are working with \emph{iterated} dialgebras. All of
the categories of dialgebras have a forgetful functor into $\Type$. We
can formalise the concept $\Type$-sorted inductive-inductive
definitions as a inductive-recursive type:
%
\begin{definition}
  \label{type-sorted-spec}
  The specification of a $\Type$-sorted inductive-inductive definition
  and its category of algebras and underlying carrier functor is given
  by the following inductive-recursive
  definition of
  %
  \begin{sorts}
    \sortnamety{\specty}{\Type} \\
    \functy{\Alg}{\specty \to \Cat} \\
    \functy{\Und}{(s : \specty) \to \Func{\Alg_s}{\Type}}
  \end{sorts}
  %
  where $\specty$ is inductively generated by
  %
  \begin{datatype}{\specty}{}
    \constr{\specnil}{\specty} \\
    \constr{\specsnoc}{(s : \specty) \to \Func{\Alg_s}{\Type} \to \specty}
  \end{datatype}
  %
  and $\Alg$ and $\Und$ are defined by
  %
  \begin{align*}
    \Alg\ \specnil &\ddefeq \Type \\
    \Alg\ (\specsnoc\ s\ F) &\ddefeq \dialgcat{F}{U_s} \\
    \\
    \Und\ \specnil &\ddefeq\ \id \\
    \Und\ (\specsnoc\ s\ F) &\ddefeq U_s \circ V
  \end{align*}
  %
  where $V$ is the forgetful functor that gives the underlying object of
  a dialgebra.
\end{definition}

\begin{example}
  The example in \cref{silly-type} can be represented by the
  specification $[F_0, F_1]$ where $F_0$ and $F_1$ are the same
  functors as before, as we have that $\Type \defeq \Alg_{[]}$,
  $\algcat{F_0} \defeq \Alg_{[F_0]}$ and
  $\dialgcat{F_1}{U_0} \defeq \Alg_{[F_0,F_1]}$.
\end{example}

\subsection{Avoiding induction-recursion}

The type of specifications in \cref{type-sorted-spec} is given
inductive-recursively. Intuitively the type is just a snoc-list of
functors. The induction-recursion allows us to succinctly make sure
that the domain of the functors is always a category of algebras. We
can avoid induction-recursion by separately defining the snoc-list of
functors and a predicate on that list that ensures the domain of the
functors is correct:

\begin{definition}
  % 
  \begin{datatype}{\specaltty}{\Type}
    \constr{\specaltnil}{\specaltty} \\
    \constr{\specaltsnoc}{\specaltty \to (\Cc : \Cat)\ (\Func{\Cc}{\Type}) \to \specaltty}
  \end{datatype}
  % 
  On this type, we define a predicate mutually with its interpretation
  function $\Algalt$ with forgetful functor $\Undalt$:
  %
  \begin{sorts}
    \functy{\specaltiscorrect}{\specaltty \to \Type} \\
    \functy{\Algalt}{(s : \specaltty) \times (\specaltiscorrect\ s) \to \Cat} \\
    \functy{\Undalt}{(s : \specaltty) \times (p : \specaltiscorrect\ s) \to \Func{\Algalt_{(s,p)}}{\Type}}
  \end{sorts}
  %
  where
  %
  \begin{align*}
    \specaltiscorrect\ \specaltnil &\ddefeq \unitty \\
    \specaltiscorrect\ (\specaltsnoc\ s\ \Cc\ F) &\ddefeq (p : \specaltiscorrect) \times (\Cc = \Algalt_{(s,p)})
  \end{align*}
  %
  The definitions of $\Alg'$ and $\Und'$ are similar to the previous
  definitions: we can pattern match on the equality proofs we get from
  $\specaltiscorrect$ and then use the previous definitions.
\end{definition}

\begin{remark}
  The mutual definition of $\specaltiscorrect$, $\Alg'$ and $\Und'$
  can be avoided by combining all three definitions into one function
  with all its arguments and result types combined in a big
  $\Sigma$-type.
\end{remark}

\begin{proposition}
  The types $\specty$ and $(s : \specaltty) \times \specaltiscorrect\ s$ are equivalent.
\end{proposition}

\begin{proof}
  This is a straightforward proof by induction on the types involved.
\end{proof}

\subsection{Coherence issues}

So far we have not given a precise definition of $\dialgcat{F}{G}$ for
some functors $F, G : \Cc \to \Dd$. In \cref{dialg}, we have defined
the category its objects and morphisms. The objects are defined in
terms of objects from $\Cc$ and morphisms from $\Dd$. Morphisms are
defined in terms of morphisms in $\Cc$ and $\Dd$ along with equalities
between them. If we are only interested in objects and morphisms of
$\dialgcat{F}{G}$, we need to know what the objects and morphisms of
$\Cc$ and $\Dd$ are and the actions of $F$ and $G$ on those. Once we
go beyond morphisms, we run into trouble.



\section{Dependent sorts}

Describing how a sort depends the previous sorts can be done by
providing a functor of the previous category of sorts into $\Type$. A
complete description is then a snoc-list of functors, which can be
formalised inductive-recursively together with the function that
interprets the list as a category.
% 
\begin{definition}
  The specification of sorts and their interpretation as a
  categories is given by the following inductive-recursive
  definition
  % 
  \begin{sorts}
    \sortname{\sortsty}{\Type} \\
    \functy{\SortCat{\_}}{\sortsty \to \Cat}
  \end{sorts}
  where $\sortsty$ is inductively generated by
  %
  \begin{datatype}{\sortsty}{}
    \constr{\sortsnil}{\sortsty} \\
    \constr{\sortssnoc}{(\Ss : \sortsty) \to (\Func{\SortCat{\Ss}}{\Type}) \to \sortsty}
  \end{datatype}
  % 
  with $\SortCat{\sortsnil}$ defined as the terminal category $\termcat$, and given
  $\Ss : \sortsty$ and $R : \Func{\SortCat{\Ss}}{\Type}$,
  the category $\SortCat{\sortssnoc\ \Ss\ R}$ has:
  % 
  \begin{itemize}
  \item objects: $(X : | \SortCat{\Ss} |) \times (R X \to \Type))$,
  \item morphisms $(X,Z) \to (Y,W)$: a morphism $f : \SortCat{\Ss}(X,Y)$
    together with a dependent function $g : (x : R X) \to Y\ x \to W\ (R(f)\ x)$.
  \end{itemize}
\end{definition}

% \begin{example}
%   The sort of an ordinary inductive definition can be represented by
%   the list $[R_0]$ (\ie $\sortssnoc\ \sortsnil\ R_0$) where $R_0 : 1 \to \Type$
%   is defined by $R_0\ x \ddefeq 1$. The resulting category
%   $\SortCat{R_0}$ has objects $(\ast : 1) \times (A : 1 \to \Type)$ and
%   a morphism $(x, A) \to (y, B)$ is given by, since trivially
%   $x = y = \ast$, a trivial morphism $\ast \to \ast$ together with a
%   function $f x : A\ x \to B\ x$ for every $x : 1$. In other words,
%   this category is equivalent to the category $\Type$.
% \end{example}

% \begin{example}
%   The sort of the context and types example $(\Con, \Ty)$ can be
%   represented by the list $[R_0, R_1]$ with
% \begin{itemize}
% \item $R_0 : 1 \to \Type$, $R_0\ x \ddefeq 1$
% \item $R_1 : \SortCat{R_0} \to \Type$, $R_0 (x, A) \ddefeq A\ x$
% \end{itemize}
% The category $\SortCat{R_0,R_1}$ has objects
% $(x : 1) \times (A : 1 \to \Type) \times (B : A\ x \to \Type)$. We see
% that this category is equivalent to the category $\Fam$ of families of
% sets.
% \end{example}

% \begin{example}
%   \label{ex:rel}
%   Similarly, the category $\Rel$ can be represented by the list
%   $[R_0, R_1]$ with
% \begin{itemize}
% \item $R_0 : 1 \to \Type$, $R_0\ x \ddefeq 1$
% \item $R_1 : \SortCat{R_0} \to \Type$, $R_0 (x, A) \ddefeq A\ x \times A\ x$
% \end{itemize}
% We see that $\SortCat{R_0,R_1}$ is equivalent to the category with
% objects $(X : \Type, R : X \to X \to \Type)$ and morphisms
% $(X,R) \to (Y,S)$ given by $f : X \to Y$ together with
% $g : (x\ y: X) \to R\ x\ y \to S\ (f\ x)\ (f\ y)$.
  
% \end{example}

% % In the $\Fam$ example it may seem superfluous to have the empty list
% % interpreted as the terminal category and not as $\Type$. However, this
% % choice allows us to have the first sort be indexed by some other type,
% % \eg $\Nat$. Hence a definition of the vectors would have as sort
% % specification the list $[R_0]$ with $R_0\ x \ddefeq \Nat$.

% A specification $\Ss = [R_0, \ldots, R_n] : \sortsty$ defines a chain of categories
% \[
% \xymatrix{
% 1 &S_0 \ar[l]_{t_0} &S_1 \ar[l]_{t_1} &\hdots \ar[l]_{t_2} &S_n \ar[l]_{t_i}
% }
% \]
% where $n$ is the number of functors in the list and
% $S_i = \SortCat{R_0, \ldots, R_i}$ is the category of sorts truncated
% to the first $i$ elements. Every $t_i$ is the forgetful functor that
% maps $(X,Y)$ to $X$.

% \begin{example}
% In the case of $\Rel$, we get the sequence
% \[
% \xymatrix{
% 1 &\Type \ar[l]_{t_0} &\Rel \ar[l]_{t_1}
% }
% \]
% \end{example}

\subsection{Coherence issues}

\subsection{Sort membership}

% When giving a \qiid, we start out by defining its sorts. When
% specifying a constructor, we need to say what sort we want to
% construct points or paths in. To this end, we can define a membership
% relation
% \[
%   \_ \in \_ : \Cat \to \sortsty \to \Type
% \]
% where $\C \in \Ss$ means that $\C$ appears in the chain
% ${1 \leftarrow S_0 \leftarrow \ldots \leftarrow S_n}$ corresponding to
% $\Ss$, \i.e $\C$ is either $1$, or $S_i$ for some $0 \leq i \leq
% n$. For a \qiid with sorts $\Ss : \sortsty$, specifying the sort for a
% constructor is done by giving a category $\A : \Cat$ along with a
% proof of $\A \in \Ss$.

\subsection{Makkai's dependent sorts}

\section{Categories of algebras}

\subsection{0-constructors}

\subsection{1-constructors}


\section{From syntax to functors}

