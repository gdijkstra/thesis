\chapter{Describing inductive definitions}
\label{describing}

When we give an inductive definition, we have to give four sets of
rules:
\begin{itemize}
\item \emph{type formation rules}: we have to specify the \emph{sorts}
  of the definition. For example, for the contexts and types
  definition we have a rule stating that $\ttconty$ is a type and that
  for every $\Gamma : \ttconty$, $\tttyty\ \Gamma$ is a type.
\item \emph{introduction rules}: we have to have means of creating
  instances of the data: we need \emph{constructors}
\item \emph{elimination rules}: we also need means to manipulate the
  data: we need an induction principle
\item \emph{computation rules}: the induction principle needs to ``compute''
\end{itemize}

In practice one gives the type formation and introduction rules, which
are used to derive the elimination and computation rules from.

In this chapter we will not work directly on the level of syntax, but
will work on a categorical level.

We have seen in the examples in \cref{qits} that quotient
inductive-inductive definitions differ from ordinary inductive
definitions in three ways:
%
\begin{itemize}
\item constructors may refer to any previous constructor
\item we are not defining one type, but a collection of types and type
  families
\item apart from point constructors we also have path constructors
\end{itemize}

\section{Algebraic semantics}

Let us look at a list of constructors of an ordinary data type, \eg:
\begin{datatype}{\Aty}{\Type}
  \constr{\Aco}{F_0\ \Aty \to \Aty} \\
  \constr{\Aci}{F_1\ \Aty \to \Aty} \\
  \constrdots \\
  \constr{\Ack}{F_k\ \Aty \to \Aty}
\end{datatype}
with every $F_i : \Type \to \Type$ being a function that gives us the
arguments of the constructors. One observation is that if we have
coproducts, we can rewrite the definition into one having a single
constructor:
\begin{datatype}{\Aty}{\Type}
  \constr{\Ac}{F_0\ \Aty + F_1\ \Aty + \hdots + F_k\ \Aty \to \Aty}
\end{datatype}
Hence for ordinary inductive types, it is enough to just consider
definitions with a single constructor. The type formation rule for
such a definition is always the same: $\Aty$ is a type. The
introduction rule is given by supplying a function
$F : \Type \to \Type$, yielding the constructor
$\Ac : F\ \Aty \to \Aty$.

Moving on the recursion principle, we notice that we need more
structure on the function $F$. The recursion principle gives us a way
to define a function $\Aty \to X$ for some type $X$, given some
additional structure on $X$. Intuitively we need to specify for every
constructor what the corresponding ``constructor'' in the target type
is. For example, for the natural numbers we have:
$$
\natrec : (A : \Type)\ (\theta_0 : A)\ (\theta_1 : A \to A) \to \natty \to A
$$
with computation rules giving us equalities
$\natrec\ A\ \theta_0\ \theta_1\ \natzero = \theta_0$ and
$\natrec\ A\ \theta_0\ \theta_1\ (\natsucc\ n) = \theta_1\ (\natrec\
A\ \theta_0\ \theta_1\ n)$.
These rules tell us that applying $\natrec$ to constructors of
$\natty$ is the same as first applying $\natrec$ to the recursive
arguments and then applying the ``constructors'' of the target of the
recursion.

In order to generalise the recursion principle and its computation
rules to any inductive type $\Aty$ with constructor
$\Ac : F\ \Aty \to \Aty$, we need $F$ to be \emph{functorial}. We can
then state the recursion principle for $\Aty$ as:
$$
\Arec : (X : \Type)\ (\theta : F\ X \to X) \to \Aty \to X
$$
with as its computation rule:
$$
\Arec\ X\ \theta\ (\Ac\ x) = \theta\ (F\ f\ x)
$$


\begin{definition}
  Given an endofunctor $F$ on $\Cc$, an \emph{$F$-algebra} is an
  object $X : | \Cc |$ along with an \emph{$F$-algebra structure}
  $\theta : \Cc(F X, X)$. The object $X$ is also referred to as the
  \emph{carrier} or \emph{underlying object} of the algebra.
\end{definition}

\begin{definition}
  Given $F$-algebras $(X,\theta)$ and $(Y,\rho)$ an \emph{$F$-algebra
    morphism} consists of a morphism $f : \Cc(X,Y)$ such that the
  following commutes:
  $$
  \xymatrix{
    FX \ar[r]^{\theta} \ar[d]_{Ff} &X \ar[d]^{f} \\
    FY \ar[r]^{\rho} &Y
  }
  $$
\end{definition}

\begin{proposition}
  Given an endofunctor $F$, $F$-algebras and $F$-algebra morphisms
  form a category, denoted as $\algcat{F}$.
\end{proposition}

\subsection{Monad algebras}

Given an endofunctor $F$ on $\Type$, we can consider its \emph{free
  monad} $F^*$, which is defined pointwise as the inductive type:

\begin{datatype}{F^* X}{\Type}
  \constr{\Fstareta}{X \to F^* X} \\
  \constr{\Fstarc}{F (F^* X) \to F^* X}
\end{datatype}

It is straightforward to show that $F^*$ forms a monad.

\begin{proposition}
  $F^*$ forms a monad with unit $\eta$ and multiplication defined by
  recursion.
\end{proposition}

$F^*$ is called the \emph{free} monad as it is a free object with
regards to the forgetful functor of the category of monads on $\Type$
to endofunctors on $\Type$.

Note that $F^* \emptyty$ gives us the inductive type defined by $F$.

\begin{definition}
  Given a monad $M : \Func{\Cc}{\Cc}$ with $\eta : \Nat{1_{\Cc},M}$
  its unit and $\mu : \Nat{M^2,M}$ is multiplication, a monad algebra
  on $M$ is an object $X : | \Cc |$ and a morphism
  $\theta : \Cc(MX,X)$ such that it respects the monad operations, \ie
  the following commutes:
  $$
  \xymatrix{
    X \ar[r]^{\eta_X} \ar[dr]_{\id_X} &MX \ar[d]^{\theta} \\
    &X
  }
  $$
  and
  $$
  \xymatrix{
    &M^2 X \ar[r]^{M \theta} \ar[d]_{\mu_X} &MX \ar[d]^{\theta} \\
    &MX \ar[r]_{\theta} &X
  }
  $$

  Monad algebra morphisms are defined in the same way as morphisms of
  algebras of an endofunctor.
\end{definition}

\begin{proposition}
  Monad algebras and monad algebra morphisms form a category, denoted
  $\monalgcat{M}$, also called the \emph{Eilenberg-Moore category} of
  $M$.
\end{proposition}

\begin{theorem}
  Let $F : \Func{\Cc}{\Cc}$ be an endofunctor on $\Cc$ with
  $F^* : \Func{\Cc}{\Cc}$ its free monad, then $\monalgcat{F^*}$ is
  equivalent to $\algcat{F}$.
\end{theorem}

If we associate ordinary inductive types with free monads, then a
generalisation of this would be to consider not just free monads, but
any \emph{presented monad}, \ie a monad that is defined in terms of
generators and relations. 

\section{$\Set$-sorted inductive-inductive definitions}

We have mentioned that one of the defining features of the inductive
definitions we want to be able to handle, is any constructor may refer
to any of its previous constructors. Some examples we have seen of
this phenomenon are:
%
\begin{itemize}
\item the constructor $\intseg : \intzero = \intone$ of the interval
  type, $\intty$, which refers to both its previous constructor,
\item the constructor
  $\ttpi : (\Gamma : \ttconty) (A : \tttyty\ \Gamma) \to \tttyty\
  (\ttcons{\Gamma}{A}) \to \tttyty\ \Gamma$,
  which refers to the previous constructor
  $\ttcons{\_}{\_} : \Gamma : \ttconty) \to \tttyty\ \Gamma \to
  \ttconty$.
\end{itemize}

Describing inductive definitions with such constructors is not
something we can do with a single endofunctor on an appropriately
chosen category. Instead of having one functor, we need a functor for
every constructor. The domain of the $n$-th functor will then be the
``category of algebras of all previous constructors''. 

\begin{example}
  \label{silly-type}
  To illustrate this idea, we consider the following example (which we
  can easily show to be equivalent to the booleans):
  % 
  \begin{datatype}{\Tty}{\Type}
    \constr{\Ta}{\unitty \to \Tty} \\
    \constr{\Tb}{(t : \Tty) \times \Ta\ \unitval = t \to \Tty}
  \end{datatype}
  % 
\end{example}

The first constructor $\Ta$ can be described as being an $F_0$-algebra
structure on $\Tty$, with $F_0 : \Type \to \Type$ being defined as
$F_0 X \ddefeq \unitty$. The arguments of $\Tb$ are described by the
functor $F_1 : \algcat{F_0} \to \Type$ with:
$$
F_1 (X,a) \ddefeq (x : X) \times a\ \unitval = x
$$
Since $F_1$ is not an endofunctor, $\Tb$ cannot be described as an
$F_1$-algebra structure. However, $\algcat{F_0}$ comes with a
forgetful functor $U_0 : \algcat{U_0} \to \Type$ which gives us the
carrier of the algebra. We therefore have that
$\Tb : F_1(\Tty,\Ta) \to U_0(\Tty,\Ta)$, \ie $\Tb$ is an
$(F_1,U_0)$-\emph{dialgebra}~\cite{Hagino1987} structure on
$(\Tty,\Ta) : \algcat{F_0}$.
%
\begin{definition}
  \label{dialg}
  Let $F, G : \Cc \to \Dd$ be functors. The category $\dialgcat{F}{G}$ has
  as objects pairs $(X, \theta)$ where $X : |\Cc|$ and $\theta : F X \to
  G X$. A morphism from $(X, \theta)$ to $(Y, \rho)$ is a morphism $f : X
  \to Y$ in $\Cc$ such that the following commutes:
  $$
  \xymatrix{
  F X \ar[r]^{\theta} \ar[d]_{F f} &G X \ar[d]^{G f} \\
  G X \ar[r]^{\rho}  &G Y
  }
  $$
\end{definition}
%

As $\specty$ is essentially a list type, we will use list notation for
its values, \eg we denote $\specsnoc\ (\specsnoc\ F_0\ \specnil)\ F_1$
as $[F_0,F_1]$.

Any dialgebra category $\dialgcat{F}{G}$ comes with a forgetful
functor $U : \dialgcat{F}{G} \to \Cc$ which projects out the carrier
of the algebra. This means in particular that we have a forgetful
functor $U_1 : \dialgcat{F_1}{U_0} \to \algcat{F_0}$. If we were to
add a third and a fourth constructor, we would have to define a
functors $F_2 : \dialgcat{F_1}{U_0} \to \Type$ and
$F_3 : \dialgcat{F_2}{U_0 \circ U_1} \to \Type$ to describe
their arguments. The objects we are interested in are \emph{iterated}
dialgebras. For the situation described above we have:
$$
\xymatrix{
\Type 
\ar[d]_{F_0}
&\algcat{F_0} 
\ar[d]_{F_1}
\ar[l]_{U_0}
&\dialgcat{F_1}{U_0}
\ar[d]_{F_2}
\ar[l]_{U_1}
&\dialgcat{F_2}{U_0 \circ U_1}
\ar[d]_{F_3}
\ar[l]_{U_2}
&\dialgcat{F_3}{U_0 \circ U_1 \circ U_2}
\ar[l]_{U_3}
\\
\Type
&\Type
&\Type
&\Type
&
}
$$

Note that we build the category of dialgebras over another category of
dialgebras, \ie we are working with \emph{iterated} dialgebras. All of
the categories of dialgebras have a forgetful functor into $\Type$. We
can formalise the concept $\Type$-sorted inductive-inductive
definitions as a inductive-recursive type:
%
\begin{definition}
  \label{type-sorted-spec}
  The specification of a $\Type$-sorted inductive-inductive definition
  and its category of algebras and underlying carrier functor is given
  by the following inductive-recursive
  definition of
  %
  \begin{sorts}
    \sortnamety{\specty}{\Type} \\
    \functy{\Alg}{\specty \to \Cat} \\
    \functy{\Und}{(s : \specty) \to \Func{\Alg_s}{\Type}}
  \end{sorts}
  %
  where $\specty$ is inductively generated by
  %
  \begin{datatype}{\specty}{}
    \constr{\specnil}{\specty} \\
    \constr{\specsnoc}{(s : \specty) \to \Func{\Alg_s}{\Type} \to \specty}
  \end{datatype}
  %
  and $\Alg$ and $\Und$ are defined by
  %
  \begin{align*}
    \Alg\ \specnil &\ddefeq \Type \\
    \Alg\ (\specsnoc\ s\ F) &\ddefeq \dialgcat{F}{U_s} \\
    \\
    \Und\ \specnil &\ddefeq\ \id \\
    \Und\ (\specsnoc\ s\ F) &\ddefeq U_s \circ V
  \end{align*}
  %
  where $V$ is the forgetful functor that gives the underlying object of
  a dialgebra.
\end{definition}

\begin{example}
  The example in \cref{silly-type} can be represented by the
  specification $[F_0, F_1]$ where $F_0$ and $F_1$ are the same
  functors as before, as we have that $\Type \defeq \Alg_{[]}$,
  $\algcat{F_0} \defeq \Alg_{[F_0]}$ and
  $\dialgcat{F_1}{U_0} \defeq \Alg_{[F_0,F_1]}$.
\end{example}

\subsection{Avoiding induction-recursion}
\label{avoiding-induction-recursion}

The type of specifications in \cref{type-sorted-spec} is given
inductive-recursively. Intuitively the type is just a snoc-list of
functors. The induction-recursion allows us to succinctly make sure
that the domain of the functors is always a category of algebras. We
can avoid induction-recursion by separately defining the snoc-list of
functors and a predicate on that list that ensures the domain of the
functors is correct:

\begin{definition}
  % 
  \begin{datatype}{\specaltty}{\Type}
    \constr{\specaltnil}{\specaltty} \\
    \constr{\specaltsnoc}{\specaltty \to (\Cc : \Cat)\ (\Func{\Cc}{\Type}) \to \specaltty}
  \end{datatype}
  % 
  On this type, we define a predicate mutually with its interpretation
  function $\Algalt$ with forgetful functor $\Undalt$:
  %
  \begin{sorts}
    \functy{\specaltiscorrect}{\specaltty \to \Type} \\
    \functy{\Algalt}{(s : \specaltty) \times (\specaltiscorrect\ s) \to \Cat} \\
    \functy{\Undalt}{(s : \specaltty) \times (p : \specaltiscorrect\ s) \to \Func{\Algalt_{(s,p)}}{\Type}}
  \end{sorts}
  %
  where
  %
  \begin{align*}
    \specaltiscorrect\ \specaltnil &\ddefeq \unitty \\
    \specaltiscorrect\ (\specaltsnoc\ s\ \Cc\ F) &\ddefeq (p : \specaltiscorrect) \times (\Cc = \Algalt_{(s,p)})
  \end{align*}
  %
  The definitions of $\Alg'$ and $\Und'$ are similar to the previous
  definitions: we can pattern match on the equality proofs we get from
  $\specaltiscorrect$ and then use the previous definitions.
\end{definition}

\begin{remark}
  The mutual definition of $\specaltiscorrect$, $\Alg'$ and $\Und'$
  can be avoided by combining all three definitions into one function
  with all its arguments and result types combined in a big
  $\Sigma$-type.
\end{remark}

\begin{proposition}
  The types $\specty$ and $(s : \specaltty) \times \specaltiscorrect\ s$ are equivalent.
\end{proposition}

\begin{proof}
  This is a straightforward proof by induction on the types involved.
\end{proof}

\section{Dependent sorts}

Describing how a sort depends the previous sorts can be done by
providing a functor of the previous category of sorts into $\Type$. A
complete description is then a snoc-list of functors, which can be
formalised inductive-recursively together with the function that
interprets the list as a category.
% 
\begin{definition}
  The specification of sorts and their interpretation as a
  categories is given by the following inductive-recursive
  definition
  % 
  \begin{sorts}
    \sortnamety{\sortsty}{\Type} \\
    \functy{\SortCat{\_}}{\sortsty \to \Cat}
  \end{sorts}
  where $\sortsty$ is inductively generated by
  %
  \begin{datatype}{\sortsty}{}
    \constr{\sortsnil}{\sortsty} \\
    \constr{\sortssnoc}{(\Ss : \sortsty) \to (\Func{\SortCat{\Ss}}{\Type}) \to \sortsty}
  \end{datatype}
  % 
  with $\SortCat{\sortsnil}$ defined as the terminal category $\termcat$, and given
  $\Ss : \sortsty$ and $R : \Func{\SortCat{\Ss}}{\Type}$,
  the category $\SortCat{\sortssnoc\ \Ss\ R}$ has:
  % 
  \begin{itemize}
  \item objects: $(X : | \SortCat{\Ss} |) \times (R X \to \Type))$,
  \item morphisms $(X,Z) \to (Y,W)$ consists of
    \begin{itemize}
    \item a morphism $f : \SortCat{\Ss}(X,Y)$
    \item a dependent function
      $g : (x : R X) \to Y\ x \to W\ (R\ f\ x)$.
    \end{itemize}
  \end{itemize}
\end{definition}

\begin{remark}
  The use of induction-recursion can be avoided here as well, using
  the same techniques as in \cref{avoiding-induction-recursion}
\end{remark}

\begin{example}
  The sort of an ordinary inductive definition can be represented by
  the list $[R_0]$ (\ie $\sortssnoc\ \sortsnil\ R_0$) where
  $R_0 : \Func{\termcat}{\Type}$ is defined as the constant functor
  $R_0\ x \ddefeq \unitty$. The resulting category $\SortCat{R_0}$ has
  objects $(\unitval : \unitty) \times (A : \unitty \to \Type)$ and a
  morphism $(x, A) \to (y, B)$ is given by, since trivially
  $x = y = \unitval$, a trivial morphism $\unitty \to \unitty$
  together with a function $f\ x : A\ x \to B\ x$ for every $x : 1$. In
  other words, this category is equivalent to the category $\Type$.
\end{example}

In the above example it may seem superfluous to have the empty list
interpreted as the terminal category and not as $\Type$. However, this
choice allows us to have the first sort be indexed by some other type,
\eg $\natty$. Hence a definition of the vectors would have as sort
specification the list $[R_0]$ with $R_0\ x \ddefeq \natty$.

\begin{example}
  The sort of the context and types example $(\ttconty, \tttyty)$ can be
  represented by the list $[R_0, R_1]$ with
  \begin{itemize}
  \item $R_0 : \Func{\termcat}{\Type}$, $R_0\ x \ddefeq \unitty$
  \item $R_1 : \Func{\SortCat{R_0}}{\Type}$, $R_0 (x, A) \ddefeq A\ x$
  \end{itemize}
  The category $\SortCat{R_0,R_1}$ has objects
  $(x : \unitty) \times (A : \unitty \to \Type) \times (B : A\ x \to
  \Type)$.
  We see that this category is equivalent to the category $\Fam$ of
  families of sets.
\end{example}

\begin{example}
  \label{rel-sorts}
  Similarly, the category $\Rel$ can be represented by the list
  $[R_0, R_1]$ with
  \begin{itemize}
  \item $R_0 : \Func{\termcat}{\Type}$, $R_0\ x \ddefeq 1$
  \item $R_1 : \Func{\SortCat{R_0}}{\Type}$, $R_0 (x, A) \ddefeq A\ x \times A\ x$
  \end{itemize}
  We see that $\SortCat{R_0,R_1}$ is equivalent to the category with
  objects $(X : \Type, R : X \to X \to \Type)$ and morphisms
  $(X,R) \to (Y,S)$ given by $f : X \to Y$ together with
  $g : (x\ y: X) \to R\ x\ y \to S\ (f\ x)\ (f\ y)$.
\end{example}

\subsection{Sort membership}

Given a specification $s : \sortsty$ and a functor
$R : \Func{\SortCat{s}}{\Type}$, we can define a forgetful functor
$t : \Func{\SortCat{\sortssnoc\ s\ R}}{\SortCat{s}}$ which maps an object
$(X , P) : \SortCat{\sortssnoc\ s\ R}$ to $X$. A specification
$\Ss = [R_0, \ldots, R_n] : \sortsty$ therefore defines a chain of
categories:
$$
\xymatrix{
1 &S_0 \ar[l]_{t_0} &S_1 \ar[l]_{t_1} &\hdots \ar[l]_{t_2} &S_n \ar[l]_{t_i}
}
$$
where $n$ is the number of functors in the list and
$S_i = \SortCat{R_0, \ldots, R_i}$ is the category of sorts truncated
to the first $i$ elements. Every $t_i$ is the forgetful functor into
the previous category.

\begin{example}
In the case of $\Rel$, we get the sequence
\[
\xymatrix{
1 &\Type \ar[l]_{t_0} &\Rel \ar[l]_{t_1}
}
\]
\end{example}

When giving a quotient inductive-inductive definition, we start out by
defining its sorts. When specifying a constructor, we need to say what
sort we want to construct points or paths in. To this end, we can
define a membership relation
$$
  \sortsin{\_}{\_} : \Cat \to \sortsty \to \Type
$$
where $\sortsin{\Cc}{\Ss}$ means that $\Cc$ is one of the $S_i$ in the chain
${S_0 \leftarrow \ldots \leftarrow S_n}$. We can formalise this with
the following inductive type:
%
\begin{datatype}{\sortsin{\_}{\_}}{\Cat \to \sortsty \to \Type}
  \constr{\sortsinhere}{(s : \sortsty)\ (R : \Func{\SortCat{s}}{\Type}) \to \sortsin{\SortCat{\sortssnoc\ s\ R}}{\sortssnoc\ s\ R}} \\
  \constr{\sortsinthere}{(s : \sortsty)\ (R : \Func{\SortCat{s}}{\Type})\ (\Cc : \Cat) \to \sortsin{\Cc}{s} \to \sortsin{\Cc}{\sortssnoc\ s\ R}}
\end{datatype}
%
\begin{example}
  Consider the specification of $\Rel$ (\cref{rel-sorts}). If we want
  to say that $\sortsin{\SortCat{[R_0]}}{[R_0,R_1]}$ (recall that
  $\SortCat{[R_0]}$ is equivalent to $\Type$), then we can do so by
  giving the following term:
  $$
  \sortsinthere\ [R_0]\ R_1\ \SortCat{R_0}\ (\sortsinhere\ \sortsnil\ R_0)
  $$
\end{example}
%
For a quotient inductive-inductive definition with sorts
$\Ss : \sortsty$, specifying the sort for a constructor is done by
giving a category $\Aa : \Cat$ along with a proof of
$\sortsin{\Aa}{\Ss}$. Note that with this definition,
$\sortsin{\termcat}{s}$ is uninhabited for any $s : \sortsty$. This is
useful as adding constructors of sort $\termcat$ does not do anything,
so we need not consider this case.

Suppose we have a chain of sorts
$S_1 \from S_2 \from \hdots \from S_n$ and a functor
$U : \Func{\Cc}{S_n}$, then naturally we can extend this functor to
$\hat{U_i} : \Func{\Cc}{S_i}$ for any $S_i$ in the chain by composing
with the forgetful functors. We can formalise this operation with sort
membership, \ie for every specification $s : \sortsty$ with a functor
$U : \Func{\Cc}{\SortCat{s}}$, we can define the function:
$$
\hat{U} : (S_i : \Cat) \to \sortsin{S_i}{\SortCat{s}} \to \Func{\Cc}{S_i}
$$
This function is defined by induction over the proof of
$\sortsin{S_i}{\SortCat{s}}$.


\subsection{Makkai's dependent sorts}

As mentioned before, giving an inductive definition is similar to
defining a theory: we specify the type formation rules, or the sorts,
we specify the point constructors, or the function symbols and we
specify the path constructors, or the equations. One important aspect
of our inductive definitions is that our type formation rules do not
just give us a collection of types, but also type \emph{families}: we
do have \emph{dependent sorts}.

In Makkai's FOLDS (first-order logic with dependent sorts), these
dependent sorts are represented as presheaves over certain
categories. Observe that the category of families $\Fam$ can either be
defined as having objects $(X : \Set) \times (P : X \to \Set)$ or as
having as objects $(X Y : \Set) \times (p : Y \to X)$. The latter
category can be explained as the presheaf category $\Set^I$, where $I$
is the arrow category $\cdot \to \cdot$.

Suppose we have an inductive definition with sorts
%
\begin{itemize}
\item $O : \Type$
\item $A : O \to O \to \Type$ (a family of arrows)
\item $T : (x y z : O) \to A\ x\ y \to A\ y\ z \to A\ x\ z \to \Type$ (a family of triangles)
\end{itemize}
%
The corresponding category of sorts can be represented as presheaves over the category:
$$
\xymatrix{
\cdot     
\ar@<-.5ex>[r]
\ar@<.5ex>[r]
&\cdot
\ar@<-.75ex>[r]
\ar@<.0ex>[r]
\ar@<.75ex>[r]
&\cdot
}
$$
In Makkai, they consider dependent sorts to be specified by presheaves
on a \emph{direct category}.
\begin{definition}[Direct category]
  A category $\Cc$ is \emph{direct} if $\Cc$ contains no infinite
  descending chain of non-identity morphisms.
\end{definition}
Intuitively this means that all the arrows go in the ``same
direction'' and that there are no non-trivial automorphisms.

There is also no finiteness restriction on this, so one could also
talk about presheaves from the simplex category (without the
degeneracies) $\Delta^+$.
$$
\xymatrix{
\cdot     
\ar@<-.5ex>[r]
\ar@<.5ex>[r]
&\cdot
\ar@<-1ex>[r]
\ar@<0ex>[r]
\ar@<1ex>[r]
&\cdot
\ar@<-1.5ex>[r]
\ar@<-.5ex>[r]
\ar@<.5ex>[r]
\ar@<1.5ex>[r]
&\hdots
}
$$
Our definition of sorts does not support infinitely many sorts,
however one could take a coinductive interpretation of the $\sortsty$
type.

Some sorts do not translate easily to the presheaf approach. Take for
example the sorts:
\begin{itemize}
\item $A : \Type$
\item $B : \List\ A \to \Type$
\end{itemize}
With the $\sortsty$ datatype, we are allowed to use arbitrary
functors, so this readily translates to that setting. In the presheaf
setting, there is not such a straightforward translation possible.

We have chosen our specific definition of sorts in this way as it
follows our syntax closely. Most importantly, the sort membership
relation can be defined in a straightforward manner and used in a
similarly straightforward manner.


\section{Categories of algebras}

\subsection{A $\Rel$-sorted quotient inductive-inductive type}

As a warm-up, in this section we will give an example of how the
specification and the categories of algebras look like for the
following quotient inductive-inductive definition:
%
\begin{sorts}
  \sortnamety{\Aty}{\Set} \\
  \sortnamety{\Bty}{\Aty \to \Aty \to \Set}
\end{sorts}
%
\begin{datatype}{\Aty}{}
  \constr{\Aco}{\Aty} \\
  \constr{\Aci}{\Aty}
\end{datatype}
%
\begin{datatype}{\Bty}{}
  \constr{\Bcii}{\natty \to \Bty\ \Aco\ \Aci} \\
  \constr{\Bciii}{(n : \natty) \to \Bcii\ n = \Bcii\ (n+1)}
\end{datatype}

In this section we will show what all the categories of algebras are
and how they can be characterised. We will get a chain of categories:
$$
\xymatrix{
\Alg_0
&\Alg_1
\ar[l]
&\Alg_2
\ar[l]
&\Alg_3
\ar[l]
&\Alg_4
\ar[l]
}
$$
where $\Alg_i$ is the category that ``contains'' the first $i$
constructors. The functors are the forgetful functors. $\Alg_4$ is the
category we are ultimately interested in: this is the category of
algebras that is associated with the full inductive definition.

{\bf Sorts} The sorts of the definition are
$(A : \Set) \times (B : A \to A \to \Set)$: the category of sorts is
the category $\Rel$. In \cref{rel-sorts} we saw how this can be
represented as a list of functors. This category is also the first
category of algebras, \ie algebras with no constructors, and will as
such also be referred to as $\Alg_0$.

{\bf First constructor} ($\Aco : \Aty$) The first constructor $\Aco$
has no arguments and is of sort $\Aty : \Set$. Its arguments can be
described by the functor $F_0 : \Func{\Rel}{\Set}$ with
$F_0\ (X,R) \ddefeq \unitty$. The category of algebras for the first
constructor is then $\dialgcat{F_0}{t_1}$, where
$t_1 : \Func{\Rel}{\Set}$ is the forgetful functor. Strictly speaking,
an $(F_0,t_1)$-dialgebra structure on a relation $(X,R)$ is a function
$1 \to X$, but for this example we will work with the equivalent
definition
$| \Alg_1 | \equiv (X : \Set) \times (R : X \to X \to \Set) \times
(\theta_0 : X)$.
Morphisms $(X,R,\theta_0) \to (Y,S,\rho_0)$ consist of:
%
\begin{itemize}
\item $f : X \to Y$
\item $g : (x\ y : X) \to R\ x\ y \to S\ (f\ x)\ (f\ y)$
\item $f_0 : f\ \theta_0 = \rho_0$
\end{itemize}
%
We see that we get a morphism in $\Rel$ along with a computation rule
that tells us that the morphism in $\Rel$ preserves the
$(F_0,t_1)$-dialgebra structure.
%
Note that $F_0$ is a functor from $\Rel$ to $\Set$ and is not an
endofunctor on $\Set$: the constructor may refer to elements of fibres
of the relation $X \to X \to \Set$ being defined. The category
$\Alg_1$ also comes with a forgetful functor $U_1 : \Func{\Alg_1}{\Alg_0}$
defined by $U_1 ((X,R),\theta_0) \ddefeq (X,R)$ --- in fact, every
category of algebras $\Alg_{i+1}$ has a similarly defined forgetful
functor $U_{i+1} : \Func{\Alg_{i+1}}{\Alg_0$}.

{\bf Second constructor} ($\Aci : \Aty$) For the second constructor
$\Aci$, the specification is largely similar: it is given by the
functor $F_1 : \Func{\Alg_1}{\Set}$ defined by
$F_1\ (X, R, \theta_0) \ddefeq \unitty$. $\Alg_2$ has objects
$(X : \Set) \times (\theta_0 : X) \times (\theta_1 : X)$, or
equivalently: $\Alg_2$ can be thought of as being the dialgebra
category $\dialgcat{F_1}{t_1 \circ U_1}$.

{\bf Third constructor} ($\Bcii : \natty \to \Bty\ \Aco\ \Aci$) The
third constructor $\Bcii$ maps into a different sort, hence its
definition will be slightly different. We want the resulting category
$\Alg_3$ of algebras for constructors $\Aco, \Aci, \Bcii$ to have
objects
$((X,R) : \Rel) \times (\theta_0 : X) \times (\theta_1 : X) \times
(\theta_2 : \natty \to R\ \theta_0\ \theta_1)$,
and we want morphisms
$((X,R),\theta_0,\theta_1,\theta_2) \to ((Y,S),\rho_0,\rho_1,\rho_2)$
to consist of
$(f,g,f_0,f_1) :
\Alg_2(((X,R),\theta_0,\theta_1),((Y,S),\rho_0,\rho_1))$
together with an equality
$$
g_2 : (n : \natty)  \to \pathover{S}{(f_0,f_1)}{g\ \theta_0\ \theta_1\ (\theta_2\ n)}{\rho_2\ n}
$$
%WAS: g_2 : (x\ y: X) (n : \natty)  \to g\ x\ y\ (\theta_2\ n) = \rho_2\ n
% -- CHECK new version is correct!
Note how we have to use the equalities $f_0 : f\ \theta_0 = \rho_0$ and
$f_1 : f\ \theta_1 = \rho_1$ to reconcile the types of
$$
g\ \theta_1\ \theta_2\ (\theta_2\ n) : S\ (f\ \theta_0)\ (f\ \theta_1)
$$
and 
$$
\rho_2 : S\ \rho_0\ \rho_1 .
$$
Realising the above directly as a dialgebra category is a bit
tricky. Observe however that if we have the following type
$$
(x : A) \to P\ (e\ x)
$$
for some $P : B \to \Set$ and $e : A \to B$, we can rewrite it to the
equivalent type:
$$
(x : A) (b : B) \to b = e\ x \to P\ b
$$
By singleton contraction, we see that the two types are indeed
equivalent. The latter version is sometimes referred to as the ``Henry
Ford''-style type (you can have any $b : B$ you want, as long as it is
$e\ x$). Along these lines, we can rewrite the type of $\theta_2$ to:
$$
\theta_2' : (x\ y : X) \to \big((x = \theta_0) \times (y = \theta_1) \times \natty\big) \to R\ x\ y 
$$
and define the functor $F_2 : Alg_2 \to \Rel$ by
$F_2 ((X,Y),\theta_0,\theta_1) \ddefeq (X , \lambda x\ y . (x =
\theta_0) \times (y = \theta_1) \times \natty)$
in order to see that $\theta_2'$ is a $(F_2,U_2)$-dialgebra. The
objects in this category give us ``too much'': such a dialgebra gives
us a morphism $F_2((X,Y),\theta_0,\theta_1) \to (X,Y)$ in $\Rel$, so
we also get a function $X \to X$. We can solve this problem by adding
an equation that the function $X \to X$ need be the identity. $\Alg_3$
is therefore not a category of dialgebras directly, but an equaliser
of one, as we will elucidate later on in some section.

{\bf Fourth constructor}
($\Bciii : (n : \natty) \to \Bcii\ n = \Bcii\ (n+1)$) The fourth
constructor $\Bciii$ is a path constructor. Hence, not only do we need
to supply a functor $F_3 : \Func{\Alg_3}{\Alg_0}$ to specify the
arguments, but we also need to specify the endpoints of the path. Just
as for $\Bcii$, we will first need to rewrite the type of the
constructor. We denote again by $\theta_2'$ the Henry Ford-version of
$\theta_2$.  We then have that the type
$(n : \natty) \to \theta_2\ n = \theta_2\ (n+ 1)$ is equivalent to the
type
%
\begin{multline*}
(x\ y : X) \to \big((p : x =  \theta_0) \times (q : y = \theta_1) \times (n : \natty)\big) \\
\ \ \ \ \to \theta_2'\ x\ y\ p\ q\ n = \theta_2'\ x\ y\ p\ q\ (n+1)
\end{multline*}
%
The endpoints can then be specified as natural transformations
$l, r : \Nat{F_3}{U_3}$, where $F_3 : \Func{\Alg_3}{\Rel}$ is defined in a
way similar to $F_2$. Given an algebra $A : \Alg_3$, $l_A$ and $r_A$
both define a morphism in
$\Rel$. $l_{((X,Y),\theta_0,\theta_1,\theta_2)}$ and
$r_{((X,Y),\theta_0,\theta_1,\theta_2)}$ are defined as
$(\id_X, l^1_{((X,Y),\theta_0,\theta_1,\theta_2)})$ and
$(\id_X,r^1_{((X,Y),\theta_0,\theta_1,\theta_2)})$ respectively, with
%
\begin{align*}
&l^1_{((X,Y),\theta_0,\theta_1,\theta_2)}\ a\ b\ (p, q, n) \ddefeq \theta_2'\ a\ b\ p\ q\ n \\
&r^1_{((X,Y),\theta_0,\theta_1,\theta_2)}\ a\ b\ (p, q, n) \ddefeq \theta_2'\ a\ b\ p\ q\ (n+1)
\end{align*}
%
By function extensionality, we can then say the category of algebras
$\Alg_3$ has objects $(X : | \Alg_2 |) \times (\theta_3 : l_X = r_X)$,
\ie it is an equaliser category. The morphisms are just morphisms in
$\Alg_2$ with no extra structure. For higher inductive types, one
usually expects a path computation rule for any path constructor, but
as we are working with sets, equalities between paths are trivial.

\subsection{Inductive-recursive definition of specifications}

We have already seen how $\Set$-sorted inductive-inductive definitions
can be formalised. Generalising this to arbitrary quotient
inductive-inductive definitions means that we have to generalise in
two aspects: we have to be able to deal arbitrary sorts, as well as
with path constructors.

Let $\Ss : \sortsty$ be a specification of sorts. Recall that we have a
predicate $\sortsin{\Aa}{\Ss}$ that tells us that $\Aa : \Cat$ is one of the
sort categories in $\Ss$. Specifying a constructor now requires us to
specify a sort, which is done by using the predicate. The type of
quotient inductive-inductive specifications is then refined to the
following definition:

\begin{definition}[Specification of quotient
inductive-inductive types]
The specification of a quotient inductive-inductive type and its
category of algebras and underlying carrier functor is given by the
following inductive-recursive definition of
\begin{sorts}
  \sortnamety{\specty}{\Set} \\
  \functy{\Constr}{(s : \specty)\ (\Aa: \Cat) \to \sortsin{\Aa}{\Ss} \to \Set} \\
  \functy{\Alg}{\specty \to \Cat} \\
  \functy{\Und}{(s : \specty) \to \Func{\Alg_s}{\SortCat{\Ss}}} \\
\end{sorts}
% 
with
%
\begin{datatype}{\specty}{}
  \constr{\specnil}{\specty} \\
  \constr{\specsnoc}{(s : \specty) (\Aa: \Cat) (p : \sortsin{\Aa}{\Ss}) \to \Constr\ s\ \Aa\ p \to \specty}
\end{datatype}
%
where $\Constr\ s\ \Aa\ p$ is defined by recursion on $p : \sortsin{\Aa}{\Ss}$ such that
\begin{align*}
&\Constr\ s\ 1\ p \ddefeq 0 \\
&\Constr\ s\ \Aa\ p \ddefeq \Constr_0\ s\ \Aa\ p + \Constr_1\ s\ \Aa\ p
\end{align*}
%
The functions $\Constr_0$, $\Constr_1$, $\Alg$ and $\Und$ will be
defined in the remainder of this section.
\end{definition}

Let us briefly discuss the defining clauses for $\Constr\ s\ \Aa\ p$,
which is meant to describe the data needed to specify a constructor of
sort $\Aa$. There should not be any constructors of the trivial sort
$\Aa = \termcat$, and if $\Aa$ is a non-trivial sort, then a
constructor can either be a point constructor specified by
$\Constr_0\ s\ \Aa\ p$, or a path constructor specified by
$\Constr_1\ s\ \Aa\ p$. The next two subsections will describe the
data needed for point and path constructors respectively.

\subsection{0-constructors}

Suppose we have $\sortsin{S_i}{\Ss}$ and $s : \specty$, and we have already
constructed
%
\begin{itemize}
\item $\Alg_s : \Cat$,
\item $U_s : \Alg_s \to \SortCat{\Ss}$ its forgetful functor, and
\item the extension $\bar{U}_s : \Alg_s \to S_i$ of $U_s$, which we
  get from $\sortsin{S_i}{\Ss}$.
\end{itemize}
%
To make more concrete: suppose $\Ss$ contains $n$ sorts and $s$
describes $m$ constructors, then an object in $X : \Alg_s$ is a tuple
$(X_0, \hdots, X_n, \theta_0, \hdots, \theta_m)$. The functor $U_s$
gives us back all underlying carriers, \ie
$U_s(X_0, \hdots, X_n, \theta_0, \hdots, \theta_m) = (X_0, \hdots,
X_n)$
and the functor $\bar{U}_s$ further projects down to the $i$ first
carriers $X_0, \hdots, X_i$, with
$(X_0, \hdots, X_{i-1}) : | S_{i-1} |$ and
\[
X_i : R_i (X_0, \hdots, X_{i-1}) \to \Set \enspace .
\]
Recall that $R_i : \Func{S_{i-1}}{\Set}$ is the functor that describes how
the family $X_i$ depends on the previous sorts $X_0, \hdots,
X_{i-1}$. A point constructor structure on $X$ is of the form
$$
\theta : (x : R_i (X_0, \hdots, X_{i-1})) \to F_1\ (X_0, \hdots, X_n, \theta_0, \hdots, \theta_m)\ x \to X_i\ x
$$
where
$$
F_1 : ((X_0,\hdots,X_n,\theta_0,\hdots,\theta_m) : | \Alg_s |) \to R_i (X_0, \hdots, X_{i-1}) \to \Set
$$
Note that the functor $\bar{U}_s$ can be decomposed into two parts: we
have $\bar{U}_0 : \Alg_s \to S_{i-1}$ and
$\bar{U}_1 : (X : \Alg_s) \to R_i\ (\bar{U}_0\ X) \to \Set$.
$\bar{U}_0$ can also be written as $t_i \circ \bar{U}_s$, where
$t_i : S_i \to S_{i-1}$ is the forgetful functor of $S_i$. In order
for the point constructor specified by $F_1$ to be well-defined, \ie
to make sense of its computation rule, we need
$F X \ddefeq (\bar{U}_0\ X, F_1\ X)$ to be a functor
$\Func{\Alg_s}{S_i}$.  This leads us to the definition of a point
constructor specification:

\begin{definition}
  Given a specification $s : \specty$, a point constructor of sort
  $\sortsin{S_i}{\Ss}$ is specified by giving a functor
  $F : \Func{\Alg_s}{S_i}$ such that the following commutes:
  $$
  \xymatrix{
    \Alg_s \ar[r]^{F} \ar[d]_{\bar{U}_s} &S_i \ar[d]^{t_i} \\
    S_i \ar[r]^{t_i} &S_{i-1}
  }
  $$
  In other words, we have
  $$
  \Constr_0\ s\ S_i\ p \ddefeq (F : \Func{\Alg_s}{S_i}) \times (p : t_i \circ F = t_i \circ \bar{U}_s) \enspace .
  $$
\end{definition} 

The fact that $F$ must satisfy the commutativity condition intuitively
means that $F$ leaves the sorts $(X_0, \hdots, X_{i-1})$ ``untouched''.

We now explain how to construct the category $\Alg_{s'}$ of algebras
for a an specification with an additional point constructor. Suppose
the specification $s'$ has been obtained as the extension of a
specification $s$ by a point constructor given by a functor
$F : \Alg_s \to S_i$, which decomposes as $F = (\bar{U}_0, F_1)$. The
previous characterisation of a point constructor algebra structure on
an object $X : | \Alg_s |$ can be summarised as having a dependent
function of morphisms
\[
\theta : (x : R_i (\bar{U}_0\ X)) \to F_1\ X\ x \to \bar{U}_1\ X\ x
\]
A morphism $(X,\theta) \to (Y,\rho)$ consists of a morphism
$f : \Alg_s(X,Y)$ along with a ``computation rule'':
\begin{multline*}
f_0 : (x : R_i \ (\bar{U}_0\ X))\ (y : F_1\ X\ x) \to \\ \bar{U}_1(f)\ x\ (\theta\ x\ y) = \rho\ (R_i(\bar{U}_0(f))\ x)\ (F_1(f)\ x\ y)
\end{multline*}
This category of algebras look similar to
$\dialgcat{F}{\bar{U}_s}$. However, as we have seen previously, the
category of dialgebras contains too much: morphisms there also come
with a superfluous endomorphism in $S_{i-1}$. We want this morphism to
be an identity morphism, which we can achieve by taking an
equaliser. The category $\dialgcat{F}{\bar{U}_s}$ comes with two
forgetful functors: $V$ that gives us the carrier of the algebra and
$V^I$ that gives us algebra structure on the carrier, which is a
morphism in $S_i$ or equivalently, an object in the arrow category
$S_i^I$. The definition of the new category of algebras is as follows:

\begin{definition}
  Let $s' : \specty$ be the specification $s$ extended with a
  0-constructor of sort $S_i$ given by a functor $F : \Alg_s \to S_i$
  satisfying $t_i \circ F = t_i \circ \bar{U}_s$. The category of
  algebras $\Alg_{s'}$ is as the following equaliser in $\Cat$:
  \[
  \xymatrix{
    \Alg_{s'} \ar[r]^-{e} &\dialgcat{F}{\bar{U}_s} \ar[r]^-{V} \ar[d]^-{V^I} &\Alg_s \ar[r]^-{\bar{U}_s} &S_i \ar[r]^{t_i} &S_{i-1} \ar[d]^-{\id} \\
    &S_i^I \ar[rrr]^{t_i^I} && &S_{i-1}^I }
  \]
  where $e$ is the projection map of the equaliser, $t_i^I$ is the
  functor $t_i$ lifted to a functor between the respective arrow
  categories and $\id$ is the functor that assigns to each object the
  identity morphism of that object.

The forgetful functor $U_{s'} : \Alg_s' \to \SortCat{\Ss}$ is defined as the composite:
\[
\xymatrix{
    \Alg_{s'} \ar[r]^-{e} &\dialgcat{F}{\bar{U}_s} \ar[r]^-{V} &\Alg_s \ar[r]^-{U_s} &\SortCat{\Ss}
}
\]
\end{definition}

\begin{remark}
  To explicate the phenomenon of a category of dialgebras containing
  ``too much'', we will look at how the category of algebras of the
  following inductive-inductive definitions is built up:
  %
  \begin{sorts}
    \sortnamety{\Aty}{\Set} \\
    \sortnamety{\Bty}{\Aty \to \Set}
  \end{sorts}
  %
  \begin{datatype}{\Aty}{}
    \constr{\Aco}{\Aty}
  \end{datatype}
  %
  \begin{datatype}{\Bty}{}
    \constr{\Bci}{(x : X) \to \emptyty \to \Bty\ x}
  \end{datatype}
  %
  We can see that $\Aty$ is equivalent to $\unitty$. The second
  constructor $\Bci$ does not add anything to any $\Bty\ x$: $B$ is
  the constantly empty family.

  The constructor $\Aco$ can be described by
  the functor:
  \begin{align*}
    &F_0 : \Func{\Fam}{\Set} \\
    &F_0 (X , P) \ddefeq \unitty
  \end{align*}
  The category of algebras containing only the first constructor is
  $\dialgcat{F_0}{V}$ where $V : \Func{\Fam}{\Set}$ is the forgetful
  functor. The second constructor $\Bci$ , which does not add anything
  to the inductive type, can be described by the functor:
  \begin{align*}
    &F_1 : \Func{\dialgcat{F_0}{V}}{\Fam} \\
    &F_1 ((X , P) , \theta) \ddefeq (X , \lambda x . \emptyty)
  \end{align*}
  It is clear that this functor satisfies the condition that
  $V \circ F_1 = V \circ U_0$ where
  $U_0 : \Func{\dialgcat{F_0}{V}}{\Fam}$ is the forgetful functor.

  If we then unfold the definition of $\dialgcat{F_1}{U_0}$, we see
  that it has objects:
  \begin{align*}
    | \dialgcat{F_1}{U_0} | &= &(X : \Set) \times (P : X \to \Set) \\
    &\times &(\theta_0 : \unitty \to X) \times (\theta_1 : X \to X) \times (\theta_2 :  (x : X) \to \emptyty \to P\ (\theta_1\ x) \\
    &= &(X : \Set) \times (P : X \to \Set) \times (\theta_0 : X) \times (\theta_1 : X \to X)
  \end{align*}
  
  As mentioned before: we see that we get a superfluous $X \to X$
  function. For the inductive definition on its own, we are just
  interested in the initial object of the category of algebras. Here
  we see that the initial object of the dialgebra category is the
  natural numbers with a constantly empty family over it.
\end{remark}


\subsection{1-constructors}

Specifying the arguments for a path constructor is done in exactly the
same way as for a point constructor, while the endpoints of the path
is given by natural transformations. Suppose $s : \specty$, then a path
constructor structure of sort $\sortsin{S_i}{\Ss}$ on an object
$(X_0, \hdots, X_n, \theta_0,\hdots,\theta_m) : | \Alg_s |$ is of the
form:
\begin{align}
\label{eq:theta}
  \begin{split}
    &\theta : (x : R_i (X_0, \hdots, X_{i-1})) \\
    &\ \ \to (y : F_1\ (X_0, \hdots, X_n, \theta_0, \hdots, \theta_m)\ x \\
    &\ \ \to l^1_{(X_0,\hdots,X_n,\theta_0,\hdots,\theta_m)}\ x\ y =_{X_i\ x} r^1_{(X_0,\hdots,X_n,\theta_0,\hdots,\theta_m)}\ x\ y 
  \end{split}
\end{align}
where
\begin{itemize}
\item $F_1 : (X : | \Alg_s |) \to R_i (\bar{U}_0 X) \to \Set$, such
  that $F X \ddefeq (\bar{U}_0 X, F_1 X)$ is a functor $\Alg_s \to S_i$, and
\item
  $l^1, r^1 : (X : | \Cc |) (x : R_i (\bar{U}_0\ X)) (y : F_1\ X\ x)
  \to \bar{U}_1\ X\ x$
  such that $l_X \ddefeq (\id_{\bar{U}_0 X}, l^1)$ and
  $r_X \ddefeq (\id_{\bar{U}_0 X}, r^1)$ are natural transformations
  $\Nat{F}{\bar{U}_s}$.
\end{itemize}
Algebra morphisms $(X,\theta) \to (Y,\rho)$ are simply morphisms
$X \to Y$ in $\Alg_s$. As we are working with sets, we do not need
computation rules for the paths: any equation between paths is
trivial.

Summarising the above, we get to the following definition of
1-constructor specification:

\begin{definition}
  Given a specification $s : \specty$, a 1-constructor of sort
  $\sortsin{S_i}{\Ss}$ is specified by a functor
  $F : \Alg_s \to S_i$ satisfying $t_i \circ F = t_i \circ \bar{U}_s$
  and two natural transformations $\ell, r : F \to \bar{U}_s$ satisfying
  $t_i\ \ell = t_i\ r = \id_{t_i \circ \bar{U}_s}$, \ie
\begin{align*}
\Constr_1\ s\ S_i\ p \ddefeq (F : \Alg_s \to S_i) &\times (p : t_i \circ F = t_i \circ \bar{U}_s) \\ \times (\ell : F \to \bar{U}_s) &\times (q_\ell : t_i\ \ell = \id_{t_i \circ \bar{U}_s}) \\ \times (r : F \to \bar{U}_s) &\times (q_r : t_i\ r = \id_{t_i \circ \bar{U}_s}) \enspace .
\end{align*}
\end{definition}

The restriction on the natural transformations $\ell$ and $r$ is the
same kind of restriction as the restriction on $F$: the natural
transformations must leave the sorts below $S_i$ untouched.

Note that by function extensionality, the type of $\theta$ in
\eqref{eq:theta} is equivalent to $l^1_X = r^1_X$. Since
$t_i\ (l\ X) = t_i\ (r\ X) = \id_{t_i \circ
  \bar{U}}$, %: S_{i-1} (t_i(\bar{U} X), t_i (\bar{U} X))$,
the equality $l_1\ X = r_1\ X$ of dependent functions in
$\Set$ is equivalent to the equality $l\ X = r\ X
$ of morphisms in
$S_i$. We also observe that a natural transformation $\alpha : F \to
\bar{U}$ gives rise to a functor $\hat{\alpha} : \Alg_s \to
S_i^I$, mapping $X : | \Alg_s |$ to $\alpha_X : S_i(F\ X,\bar{U}\
X)$. Functoriality of this functor comes from the naturality of
$\alpha$. This leads us to the definition of the category of algebras
for a path constructor:

\begin{definition}
  Let $s' : \specty$ be the specification
  $s$ extended with a path constructor of sort
  $S_i$ given by a functor $F : \Alg_s \to S_i$ satisfying $t_i \circ
  F = t_i \circ \bar{U}_s$ and natural transformations $l, r : F \to
  \bar{U}_s$ satisfying $t_i\ l = t_i\ r = \id_{t_i \circ
    \bar{U}_s}$. The category of algebras
  $\Alg_{s'}$ is defined as the following equaliser in $\Cat$:
  \[
  \xymatrix{
    \Alg_{s'} \ar[r]^{e} &\Alg_s \ar@<-.5ex>[r]_-{\hat{r}} \ar@<.5ex>[r]^-{\hat{l}} &S_i^I
  }
  \]
  where $e$ is the projection map of the equaliser.

The forgetful functor $U_{s'} : \Alg_s' \to \SortCat{\Ss}$ is defined as the composite
\[
\xymatrix{
    \Alg_{s'} \ar[r]^{e} &\Alg_s \ar[r]^{U_s} &\SortCat{\Ss}
}
\]
\end{definition}

\subsection{Other constructors}

If we look at the constructors we have seen so far, they all are of
the shape:
$$
\Ac : (x : F\ X) \to G (X , x)
$$
where $F : | \Cc | \to \Type$ and
$G : (X : | \Cc |) \to F\ X \to \Type$ where $\Cc$ is some category of
algebras and $F$ and $G$ are in some sense functorial. For $G$ we seen
that it was either a forgetful functor or yielding some equation on
the carrier of the type we are defining. This begs the question if we
can then generalise inductive definitions even further, \ie can we
have constructors such as:
$$
\Ac : \Aty \to \List\ \Aty
$$
It turns out that this particular example does not work out.

There are examples of constructors that do make sense. If we want to
truncate our inductive type to be propositional, we can add a
constructor:
$$
\Ac : \isprop\ \Ac
$$
This works out in this case, as $\isprop\ \Ac$ is equivalent to
$(x\ y : \Ac) \to x = y$. 

\section{From syntax to functors}
\label{from-syntax-to-functors}

We have given a specification of inductive descriptions in terms of
its algebraic semantics. Sometimes the algebraic semantics is very
close to what one would want to write down in a proof assistant, \ie a
list of types of the constructors. There are some limitations to this
approach. When we want to fit an inductive definition into our schema,
we have to perform some translations first: we have the uncurry the
type and translate it into the ``Henry Ford''-version.

Other limitations are that the arguments part must be functorial:
recursive occurrences may only be in positive positions. One example
of a data type where this is not the case is the higher order abstract
syntax embedding of untyped lambda calculus:
%
\begin{datatype}{\tttmty}{\Set}
  \constr{\ttapp}{\tttmty \to \tttmty \to \tttmty} \\
  \constr{\ttlam}{(\tttmty \to \tttmty) \to \tttmty}
\end{datatype}
%
In the constructor $\ttlam$, there is a recursive occurrence in both
negative as well as a positive position. The map
$\lambda X . (X \to X)$ is therefore not functorial: it is neither
contravariant nor covariant. 

This is problematic with pattern matching ``semantics''. Having an
inductive type such as $\tttmty$ along with pattern matching (even
when recursion is restricted to structurally smaller subterms), is
unsound and allows us to write diverging terms.

Another example of this phenomenon is if we write down an inductive
definition with as constructors the axioms of a field:
%
\begin{datatype}{\fieldty}{\Set}
  \constr{\fieldzero}{\fieldty} \\
  \constrdots \\
  \constr{\fieldinv}{(x : \fieldty) \to ((x = \fieldzero) \to \emptyty) \to \fieldty} \\
  \constrdots
\end{datatype}
%
The category of algebras of this specification should be equivalent to
the category of fields. If the datatype $\fieldty$ were to exist, it
then would be the initial object in this category. However, the
category of fields does not have an initial object. The problem with
the datatype is that the constructor $\fieldinv$ has a recursive
occurrence in a negative position: the constructor $\fieldzero$ occurs
in a negative position.

One difference between how one writes down inductive definitions in
Agda and our specification type is that in Agda we have to group all
the constructors per sort, \ie we cannot write down a definition with
sorts $\Aty : \Set$, $\Bty : \Aty \to \Set$ and constructors:
%
\begin{itemize}
\item $\Aco : \Aty$
\item $\Bci : \Bty\ \Aco$
\item $\Acii : \Bci = \Bci \to \Aty$
\end{itemize}
%
In Agda we cannot alternate between the sorts, which prevents us from
defining types as the one given above.
