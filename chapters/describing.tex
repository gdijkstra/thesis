\chapter{Describing inductive definitions}
\label{describing}

In this chapter we will give a formal specification of quotient
inductive-inductive definitions. The specification is given mutually
with the interpretation of the specification as a category of
algebras.

In order to specify an inductive definition, we have to give four sets
of rules:
\begin{itemize}
\item \emph{type formation rules}: we have to specify the \emph{sorts}
  of the definition. For example, for the contexts and types
  definition we have a rule stating that $\ttconty$ is a type and that
  for every $\Gamma : \ttconty$, $\tttyty\ \Gamma$ is a type.
\item \emph{introduction rules}: we have to have means of creating
  instances of the inductive data we are defining: we need
  \emph{constructors}.
\item \emph{elimination rules}: we also need means to inspect the
  data: we need an induction principle.
\item \emph{computation rules}: the elimination rules and introduction
  rules need to interact in a certain way.
\end{itemize}

As soon as we have the first two sets of rules, the latter two follow
from these in a systematic way \cite{Backhouse1989}. This is also
reflected in how one declares an inductive definition in proof
assistants such as Agda and Coq: we provide the type signature of the
inductive definition (its type formation rules) and a list of
constructors (its introduction rules).

There are several equivalent ways to characterise inductive
definitions formally: we can formulate a syntax of constructors and
describe the elimination principle by induction on terms in this
syntax. This syntax is a subset of the syntax of type theory as a
whole: we need to be able to write down a list of constructors which
is just a sequence of types of a certain form. One can take an
``analytic'' approach to this: take the syntax of type theory and
define a predicate on it that tells us whether a term is in the
appropriate subset. This is effectively what systems like Agda do: you
can write down a list of constructors and Agda checks whether it makes
sense, \eg whether the result types of the constructors are correct
and whether the arguments are strictly positive. Doing this in type
theory itself will be rather involved, as formalising the syntax of
type theory in type theory is generally not something lightweight.

A more semantic approach is to start from the characterisation of
inductive definitions as the initial algebra given some endofunctor on
an appropriately chosen category. Ordinary inductive types can be
explained as initial algebras of strictly positive endofunctors on
$\SET$. These functors can be described as \emph{containers}
\cite{Abbott2005}, which can be easily formalised in type theory. The
initiality property only uses the objects and morphisms of the
category. Algebras of a container and algebra morphisms can be readily
stated in type theory. It has been shown in type theory that for these
inductive types, the property of being an initial algebra and that of
satisfying the induction principle are logically equivalent
\cite{Awodey2012}. In this case this concretely means that having
W-types available is the same as having initial algebras of
containers.

From the initial algebra semantics we can directly read off the
introduction rules along with the recursion principle and its
computation rules. Algebras package the type along with its
constructors. Algebra morphisms package the functions between the
types along with a proof that the functions preserve the algebra
structure. This categorical setting is on the one hand close to the
syntax, but it also abstracts enough that it allows us to generalise
without having to keep track of too many moving parts.

While the recursion principle can be straightforwardly recovered from
initiality, the induction principle is another story. Formulating the
induction principle requires a bit more machinery, as does showing its
logical equivalence to initiality. This is covered in
\cref{induction}. In this chapter we will concern ourselves with
uncovering what a description of a quotient inductive-inductive
definition ought to be in a formal way.

We have seen in the examples in \cref{qits} that quotient
inductive-inductive definitions differ from ordinary inductive
definitions in three ways:
%
\begin{itemize}
\item constructors may refer to any previous constructor
\item we are not defining one type, but a collection of types and type
  families
\item apart from point constructors we also have path constructors
\end{itemize}

The goal of this chapter is to find a notion of algebra that supports
all of this. We start out by reviewing initial algebra semantics of
ordinary inductive types in \cref{algebraic-semantics}, as well as
generalisations of this . In
\cref{set-sorted-inductive-inductive-definitions} we see how this
approach can be generalised to support having constructors that refer
to previous constructors by considering iterated
dialgebras. \Cref{dependent-sorts} formalises the notion of
\emph{dependent sorts}, which deals with the type formation rules for
quotient inductive-inductive definitions. In
\cref{categories-of-algebras} the full formal definition of
declarations of quotient inductive-inductive definitions is given as a
form of iterated dialgebras with equations. In this formal definition,
we only consider certain functors for the result type of the
constructors. In \cref{other-forms-of-constructors} and
\cref{positivity} we discuss the consequences of working with
dialgebras, both the limitations as well as the opportunities for
generalising the current definitions. Finally in
\cref{describing-related-work} we discuss related work.

\section{Algebraic semantics}
\label{algebraic-semantics}

Let us look at a list of constructors of an ordinary data type, \eg:
%
\begin{datatype}{\Aty}{\Set}
  \constr{\Aco}{F_0\ \Aty \to \Aty} \\
  \constr{\Aci}{F_1\ \Aty \to \Aty} \\
  \constrdots \\
  \constr{\Ack}{F_k\ \Aty \to \Aty}
\end{datatype}
%
with every $F_i : \Set \to \Set$ being a function that gives us the
arguments of the constructors. Note that we have to rewrite
constructors with no arguments to $\Ac : \unitty \to \Aty$ and have to
uncurry constructors with multiple arguments. One observation is that
if we have coproducts, we can rewrite the definition into one with
just a single constructor:
%
\begin{datatype}{\Aty}{\Set}
  \constr{\Ac}{F_0\ \Aty + F_1\ \Aty + \hdots + F_k\ \Aty \to \Aty}
\end{datatype}
%
For ordinary inductive types it is therefore sufficient to consider
definitions with a single constructor. The type formation rule for
such a definition is always the same: $\Aty$ is a type. The
introduction rule is given by supplying a function
$F : \Set \to \Set$, yielding the constructor
$\Ac : F\ \Aty \to \Aty$.

Moving on the recursion principle, we notice that we need more
structure on the function $F$. The recursion principle gives us a way
to define a function $\Aty \to X$ for some type $X$, given some
additional structure on $X$. Intuitively we need to specify for every
constructor what the corresponding ``constructor'' in the target type
of the recursion is. For example, for the natural numbers we have:
$$
\natrec : (X : \Set)\ (\theta_0 : A)\ (\theta_1 : X \to X) \to \natty \to X
$$
with computation rules giving us equalities
$\natrec\ X\ \theta_0\ \theta_1\ \natzero = \theta_0$ and
$\natrec\ X\ \theta_0\ \theta_1\ (\natsucc\ n) = \theta_1\ (\natrec\
A\ \theta_0\ \theta_1\ n)$.
These rules tell us that applying $\natrec$ to constructors of
$\natty$ is the same as first applying $\natrec$ to the recursive
arguments and then applying the ``constructors'' of the target of the
recursion.

In order to generalise the recursion principle and its computation
rules to any inductive type $\Aty$ with constructor
$\Ac : F\ \Aty \to \Aty$, we need $F$ to be a functor. We can then
state the recursion principle for $\Aty$ as:
$$
\Arec : (X : \Set)\ (\theta : F\ X \to X) \to \Aty \to X
$$
with as its computation rule:
$$
\Arec\ X\ \theta\ (\Ac\ x) = \theta\ (F\ (\Arec\ X\ \theta)\ x)
$$
The type $\Aty$ along with its constructor $\Ac$ and the $X$ and
$\theta$ in the recursion principle are both $F$-algebras, where $F$
is an endofunctor on $\Set$. The notion of $F$-algebra can be defined
for any category $\Cc$:

\begin{definition}
  Given an endofunctor $F$ on $\Cc$, an \emph{$F$-algebra} is an
  object $X : | \Cc |$ along with an \emph{$F$-algebra structure}
  $\theta : \Cc(F X, X)$. The object $X$ is also referred to as the
  \emph{carrier} or \emph{underlying object} of the algebra.
\end{definition}

The function $\Arec\ X\ \theta$ is a function between the carriers of
the algebras $(A,c)$ and $(X,\theta)$. Its computation rule states
that it respects the algebra structure: it is an algebra morphism:

\begin{definition}
  Given $F$-algebras $(X,\theta)$ and $(Y,\rho)$ an \emph{$F$-algebra
    morphism} consists of a morphism $f : \Cc(X,Y)$ such that the
  following commutes:
  $$
  \xymatrix{
    FX \ar[r]^{\theta} \ar[d]_{Ff} &X \ar[d]^{f} \\
    FY \ar[r]^{\rho} &Y
  }
  $$
\end{definition}

Algebra morphisms can be composed and we have identity algebra
morphisms: algebras form a category:

\begin{definition}
  The category $\algcat{F}$ is the category with $F$-algebras as
  objects and $F$-algebra morphisms as morphisms.
\end{definition}

\subsection{Monad algebras}

Given an endofunctor $F$ on $\SET$, we can consider its \emph{free
  monad} $F^*$, which is defined pointwise as the carrier of the
initial algebra of the functor $\bar{F}_X Y \ddefeq X + FY$. Note that
the free monad need not exist: $F$ is required to be a strictly
positive functor for $\bar{F}_X$ to be strictly positive as well.

We can write the functor $F^*$ down as a parametrised inductive type,
with $X : \Set$ as its parameter:
%
\begin{datatype}{F^* X}{\Set}
  \constr{\Fstareta}{X \to F^* X} \\
  \constr{\Fstarc}{F (F^* X) \to F^* X}
\end{datatype}
%
Note that if we want to write down the abovementioned definition in
Agda, we have to make sure that $F$ is a strictly positive functor. We
cannot have the definition be parametric in the functor $F$.

\begin{proposition}
  \label{free-monad-thm}
  $F^*$, if it exists, is a monad on $\SET$
\end{proposition}

\begin{proof}
  We show that it is a monad by showing that $F^*$ gives us a left
  adjoint to the forgetful functor $U : \Func{\algcat{F}}{\SET}$ where
  $U (X , \theta) \ddefeq X$. We define the left adjoint
  $L : \Func{\SET}{\algcat{F}}$ as follows:
  $$
  L X \ddefeq (F^* X , \Fstarc_X)
  $$
  We then show that for any $X : \Set$ and $(Y,\rho) : | \algcat{F} |$ that
  $$
  \algcat{F}(L X , (Y,\rho)) = (X \to Y)
  $$
  using the equational reasoning in \cref{f-star-monad}.

  This shows that $L \dashv U$ and since $UL = F^*$, that therefore
  $F^*$ is a monad.
\end{proof}

\begin{figure}
  \centering
    \begin{align*}
    &&&X \to Y \\
    &&=&\ \reasontext{initiality of $F^* X$} \\
    &&&(p : X \to Y) \times \algcat{\bar{F}_X}((F^* X , \Fstarc_X , \Fstareta_X),(Y,\rho,p)) \\
    &&=&\ \reasontext{definition $\bar{F}_X$-algebra morphism} \\
    &&&(p : X \to Y) \times (f : F^* X \to Y) \times (f_0 : f \circ \Fstarc_X = \rho \circ Ff) \times (f_1 : f \circ \Fstareta_X = p) \\
    &&=&\ \reasontext{singleton contraction of $p$ and $f_1$} \\
    &&&(f : F^* X \to Y) \times (f_0 : f \circ \Fstarc_X = \rho \circ Ff) \\
    &&=&\ \reasontext{definition of $F$-algebra morphisms and $L$} \\
    &&&\algcat{F}(L X , (Y,\rho))
  \end{align*}
  \caption{$F^*$ is a monad}
  \label{f-star-monad}
\end{figure}

Note that since $L$ is a left adjoint it preserves colimits, in
particular initial objects, hence $L \initobj$ is the initial object
of $\algcat{F}$. The carrier of $L \initobj$ is $F^* \initobj$, which
is the inductive type as defined by the endofunctor $F$.

$F^*$ is called the \emph{free} monad as it is a free object with
regards to the forgetful functor of the category of monads on $\SET$
to endofunctors on $\SET$. The free monad $F^*$ allows us to make
precise what the relationship between monads and algebras of an
endofunctor is. To this end, let us first recall the definition of
\emph{monad algebras}:

\begin{definition}
  Given a monad $M : \Func{\Cc}{\Cc}$ with $\eta : \Nat{1_{\Cc}}{M}$
  its unit and $\mu : \Nat{M^2}{M}$ is multiplication, a monad algebra
  on $M$ is an object $X : | \Cc |$ and a morphism
  $\theta : \Cc(MX,X)$ such that it respects the monad operations, \ie
  the following commutes:
  $$
  \xymatrix{
    X \ar[r]^{\eta_X} \ar[dr]_{\id_X} &MX \ar[d]^{\theta} \\
    &X }
  $$
  and
  $$
  \xymatrix{
    &M^2 X \ar[r]^{M \theta} \ar[d]_{\mu_X} &MX \ar[d]^{\theta} \\
    &MX \ar[r]_{\theta} &X }
  $$
  
  Monad algebra morphisms are defined in the same way as morphisms of
  algebras of an endofunctor.
\end{definition}

Monad algebras and monad algebra morphisms form a category, denoted
$\monalgcat{M}$, also called the \emph{Eilenberg-Moore category} of
$M$.

\begin{theorem}[\cite{Gambino2013}]
  Let $F : \Func{\Cc}{\Cc}$ be an endofunctor on $\Cc$ with
  $F^* : \Func{\Cc}{\Cc}$ its free monad, then $\monalgcat{F^*}$ is
  equivalent to $\algcat{F}$.
\end{theorem}

This theorem shows us that we can think of the class free monads being
the same as the class of ordinary inductive types. This suggests that
generalising ordinary inductive types amounts to carving out a class
of monads that includes free monads. In \cite{Shulman2011} the author
proposes that a higher inductive type should correspond to a notion of
\emph{presented monad}, \ie a monad that is defined in terms of
generators and relations, or in HIT terminology: point and path
constructors. In \cite{Lumsdaine2013}, the authors give semantics of
HITs by constructing these presented monads. As these constructions
are done in a wide class of model categories, it is a construction
external to type theory.

As opposed to constructing the monads directly, we will first define
the categories of algebras in this chapter. The reason for this is
twofold. In the case of algebras of an endofunctor we have fewer
equations to work with: they only pop up in the definition of algebra
morphisms. The definition of monads already requires us to talk about
functors that satisfy certain equalities. Monad algebras also come
with equations. Generalising from the endofunctor situation, we hope
that we also do not have to introduce equations, which might lead to
more coherence issues.

The other reason why we chose to do it this way is that it allows us
to talk about algebras (the ``syntax'') separately from their
existence (``semantics''). In this chapter we give a definition of the
algebras and in \cref{constructing} we show how one can construct
initial algebras and left adjoints to the forgetful functors of
categories of algebras.

\section{$\SET$-sorted inductive-inductive definitions}
\label{set-sorted-inductive-inductive-definitions}

We have mentioned that one of the defining features of the inductive
definitions we want to be able to handle, is any constructor may refer
to any of its previous constructors. Some examples we have seen of
this phenomenon are:
%
\begin{itemize}
\item the constructor $\intseg : \intzero = \intone$ of the interval
  type, $\intty$, which refers to both its previous constructors,
\item the constructor
  $\ttpi : (\Gamma : \ttconty)\ (A : \tttyty\ \Gamma) \to \tttyty\
  (\ttcons{\Gamma}{A}) \to \tttyty\ \Gamma$,
  which refers to the previous constructor
  $\ttcons{\_}{\_} : (\Gamma : \ttconty) \to \tttyty\ \Gamma \to
  \ttconty$.
\end{itemize}

Describing inductive definitions with such constructors is not
something we can do with a single endofunctor on an appropriately
chosen category. Instead of having one functor, we need a functor for
every constructor. The domain of the $n$-th functor will then be the
``category of algebras of all previous constructors''. 

\begin{example}
  \label{silly-type}
  To illustrate this idea, we consider the following example (which we
  can easily show to be equivalent to the booleans):
  % 
  \begin{datatype}{\Tty}{\Set}
    \constr{\Ta}{\unitty \to \Tty} \\
    \constr{\Tb}{(t : \Tty) \times \Ta\ \unitval = t \to \Tty}
  \end{datatype}
  % 
\end{example}

The first constructor $\Ta$ can be described as being an $F_0$-algebra
structure on $\Tty$, with $F_0 : \Func{\SET}{\SET}$ being defined as
$F_0 X \ddefeq \unitty$. The arguments of $\Tb$ are described by the
functor $F_1 : \Func{\algcat{F_0}}{\SET}$ with:
$$
F_1 (X,a) \ddefeq (x : X) \times a\ \unitval = x
$$
Since $F_1$ is not an endofunctor, $\Tb$ cannot be described as an
$F_1$-algebra structure. However, $\algcat{F_0}$ comes with a
forgetful functor $U_0 : \Func{\algcat{F_0}}{\SET}$ which gives us the
carrier of the algebra. We therefore have that
$\Tb : F_1(\Tty,\Ta) \to U_0(\Tty,\Ta)$, \ie $\Tb$ is an
$(F_1,U_0)$-\emph{dialgebra}~\cite{Hagino1987} structure on
$(\Tty,\Ta) : \algcat{F_0}$.
%
\begin{definition}
  \label{dialg}
  Let $F, G : \Cc \to \Dd$ be functors. The category $\dialgcat{F}{G}$ has
  as objects pairs $(X, \theta)$ where $X : |\Cc|$ and $\theta : F X \to
  G X$. A morphism from $(X, \theta)$ to $(Y, \rho)$ is a morphism $f : X
  \to Y$ in $\Cc$ such that the following commutes:
  $$
  \xymatrix{
  F X \ar[r]^{\theta} \ar[d]_{F f} &G X \ar[d]^{G f} \\
  F Y \ar[r]^{\rho}  &G Y
  }
  $$
\end{definition}
%

\begin{remark}
  Any dialgebra category $\dialgcat{F}{G}$ comes with a forgetful
  functor $V : \dialgcat{F}{G} \to \Cc$ which projects out the carrier
  of the algebra.
\end{remark}

Recall the example $\Tty$ with constructors $\Ta$ and $\Tb$, where we
have given functors $F_0 : \Func{\SET}{\SET}$ and
$F_1 : \Func{\algcat{F_0}}{\SET}$. We have a forgetful functor
$V_1 : \dialgcat{F_1}{U_0} \to \algcat{F_0}$ which we can compose with
the forgetful functor $U_0 : \Func{\algcat{F_0}}{\SET}$, which we will
denote as $U_1$. If we were to add a third and a fourth constructor,
we would have to define functors
$F_2 : \Func{\dialgcat{F_1}{U_0}}{\SET}$ and
$F_3 : \Func{\dialgcat{F_2}{U_1}}{\SET}$ to describe their
arguments. The objects we are interested in are \emph{iterated}
dialgebras. For the situation described above we have:
$$
\xymatrix@!C{
\SET 
\ar[d]_{F_0}
&\algcat{F_0} 
\ar[d]_{F_1}
\ar[l]_{U_0}
&\dialgcat{F_1}{U_0}
\ar[d]_{F_2}
\ar[l]_{V_1}
&\dialgcat{F_2}{U_1}
\ar[d]_{F_3}
\ar[l]_{V_2}
&\dialgcat{F_3}{U_2}
\ar[l]_{V_3}
\\
\SET
&\SET
&\SET
&\SET
&
}
$$

Note that we build the category of dialgebras over another category of
dialgebras, \ie we are working with \emph{iterated} dialgebras. A
constructor has arguments described by a functor out of the category
of algebras containing all the previous constructors. We can formalise
the concept $\SET$-sorted inductive-inductive definitions as a
inductive-recursive type, defining the specification and the
interpretation of the specification as a category of algebras
simultaneously:
%
\begin{definition}
  \label{type-sorted-spec}
  The type $\specty$ of specifications of a $\SET$-sorted
  inductive-inductive definition and its category of algebras ($\Alg$)
  and underlying carrier functor $(\Und)$ is given by the following
  inductive-recursive definition of
  %
  \begin{sorts}
    \sortnamety{\specty}{\Set} \\
    \functy{\Alg}{\specty \to \Cat} \\
    \functy{\Und}{(s : \specty) \to \Func{\Alg_s}{\SET}}
  \end{sorts}
  %
  where $\specty$ is inductively generated by
  %
  \begin{datatype}{\specty}{}
    \constr{\specnil}{\specty} \\
    \constr{\specsnoc}{(s : \specty) \to (F : \Func{\Alg_s}{\SET}) \to \specty}
  \end{datatype}
  %
  and $\Alg$ and $\Und$ are defined by
  %
  \begin{align*}
    &\Alg_{\specnil} \ddefeq \SET \\
    &\Alg_{(\specsnoc\ s\ F)} \ddefeq \dialgcat{F}{\Und_s} \\
    \\
    &\Und_{\specnil} \ddefeq\ \id \\
    &\Und_{(\specsnoc\ s\ F)} \ddefeq U_s \circ V
  \end{align*}
  %
  where $V$ is the forgetful functor that gives the underlying object of
  a dialgebra.
\end{definition}

As $\specty$ is essentially a list type, we will use list notation for
its values, \eg we denote $\specsnoc\ (\specsnoc\ \specnil\ F_0)\ F_1$
as $[F_0,F_1]$.

\begin{example}
  The data type given in \cref{silly-type} can be represented by the
  specification $[F_0, F_1]$ where $F_0$ and $F_1$ are the same
  functors as before, as we have that $\SET \defeq \Alg_{[]}$,
  $\algcat{F_0} \defeq \Alg_{[F_0]}$ and
  $\dialgcat{F_1}{\Und_{[F_0]}} \defeq \Alg_{[F_0,F_1]}$.
\end{example}

\begin{example}
  The natural numbers can be represented in the usual way with one
  endofunctor $F X \ddefeq \unitty + X$. In our framework, however, we
  can treat the constructors separately, staying a bit closer to the
  syntax. We define:
  \begin{align*}
    &F_0 : \Func{\SET}{\SET} \\
    &F_0\ X \ddefeq \unitty \\
    &F_1 : \Func{\Alg_{[F_0]}}{\SET} \\
    &F_1\ (X,\theta_0) \ddefeq X
  \end{align*}

  Unfolding definitions, we have
  $\Alg_{[F_0,F_1]} = \dialgcat{F_1}{\Und_{[F_0]}}$ and
  $\Alg_{[F_0]} = \dialgcat{F_0}{\id} = \algcat{F_0}$. The objects of
  $\Alg_{[F_0,F_1]}$ are then:
  %
  \begin{align*}
    \Alg_{[F_0,F_1]} =&\ (X : | \Alg_{[F_0]} |) \times (\theta : F_1 X \to \Und_{[F_0]} X)  \\
    =&\ (X : \Set) \times (\theta_0 : \unitty \to X) \times (\theta_1 : X \to X)
  \end{align*}
  %
  For the morphisms of $\Alg_{[F_0,F_1]}$, we have for algebras
  $(X,\theta_0,\theta_1), (Y,\rho_0,\rho_1)$:
  \begin{align*}
    &\ \Alg_{[F_0,F_1]}((X,\theta_0,\theta_1),(Y,\rho_0,\rho_1))  \\
    =&\ (f : \Alg_{[F_0]}((X,\theta_0),(Y,\rho_0))) \times (f_1 : \Und_{[F_0]} f \circ \theta_1 = \rho_1 \circ F_1 f) \\
    =&\ (f : X \to Y) \times (f_0 : f \circ \theta_0 = \rho_0) \times (f_1 : f \circ \theta_1 = \rho_1 \circ f)
  \end{align*}
\end{example}

\subsection{Avoiding induction-recursion}
\label{avoiding-induction-recursion}

The type of specifications in \cref{type-sorted-spec} is given
inductive-recursively. However, we want our framework to be
implementable in a small core type theory. In such a setting, one
would not expect to have induction-recursion available. A class of
inductive-recursive definitions can be translated into definitions
making use of indexed inductive definitions instead
\cite{Malatesta2012}. In this section we will use a different
translation, which does not need indexed inductive definitions.

Intuitively the type is just a snoc-list of functors. The
induction-recursion allows us to succinctly make sure that the domain
of the functors is always a category of algebras. We can avoid
induction-recursion by separately defining the snoc-list of functors
and a predicate on that list that ensures the domain of the functors
is correct:

\begin{definition}
  % 
  \begin{datatype}{\specaltty}{\Set}
    \constr{\specaltnil}{\specaltty} \\
    \constr{\specaltsnoc}{\specaltty \to (\Cc : \Cat)\ (\Func{\Cc}{\SET}) \to \specaltty}
  \end{datatype}
  % 
  On this type, we define a predicate mutually with its interpretation
  function $\Algalt$ with forgetful functor $\Undalt$:
  %
  \begin{sorts}
    \functy{\specaltiscorrect}{\specaltty \to \Set} \\
    \functy{\Algalt}{(s : \specaltty) \times (\specaltiscorrect\ s) \to \Cat} \\
    \functy{\Undalt}{(s : \specaltty) \times (p : \specaltiscorrect\ s) \to \Func{\Algalt_{(s,p)}}{\SET}}
  \end{sorts}
  %
  where
  %
  \begin{align*}
    &\specaltiscorrect\ \specaltnil \ddefeq \unitty \\
    &\specaltiscorrect\ (\specaltsnoc\ s\ \Cc\ F) \ddefeq (p : \specaltiscorrect\ s) \times (\Cc = \Algalt_{(s,p)})
  \end{align*}
  %
  The definitions of $\Alg'$ and $\Und'$ are similar to the previous
  definitions: we can pattern match on the equality proofs we get from
  $\specaltiscorrect$ and then use the previous definitions.
\end{definition}

\begin{remark}
  The mutual definition of $\specaltiscorrect$, $\Alg'$ and $\Und'$
  can be avoided by combining all three definitions into one function
  with all its arguments and result types combined in a big
  $\Sigma$-type.
\end{remark}

\begin{proposition}
  The types $\specty$ and $(s : \specaltty) \times \specaltiscorrect\ s$ are equivalent.
\end{proposition}

\begin{proof}
  This is a straightforward proof by induction on the types involved
  and applying singleton contraction where needed.
\end{proof}

\section{Dependent sorts}
\label{dependent-sorts}

In the last section we saw how we can deal with referring to previous
constructors. In this section we will tackle the issue of generalising
the form of the type formation rules, which were hitherto just of the
form ``$A$ is a set''. We want to generalise this to arbitrary lists
of types and type families. Such a list is referred to as the
\emph{dependent sorts} of the inductive definition. Examples can be
something simple like $A : \Set, B : A \to \Set$, which we have seen
in the example of contexts and type in a context in
\cref{syntax-of-type-theory}, or something more involved like:
$A : \natty \to \natty \to \Set, B : (x : \natty) \to A\ n\ n \to
\Set$.

Describing how a sort depends on the previous sorts can be done by
providing a functor of the previous category of sorts into $\SET$. A
complete description is then a snoc-list of functors, which can be
formalised inductive-recursively together with the function that
interprets the list as a category.
% 
\begin{definition}
  The specification of sorts and their interpretation as a
  category is given by the following inductive-recursive
  definition
  % 
  \begin{sorts}
    \sortnamety{\sortsty}{\Set} \\
    \functy{\SortCat{\_}}{\sortsty \to \Cat}
  \end{sorts}
  where $\sortsty$ is inductively generated by
  %
  \begin{datatype}{\sortsty}{}
    \constr{\sortsnil}{\sortsty} \\
    \constr{\sortssnoc}{(\Ss : \sortsty) \to (R : \Func{\SortCat{\Ss}}{\SET}) \to \sortsty}
  \end{datatype}
  % 
  with $\SortCat{\sortsnil}$ defined as the terminal category $\termcat$, and given
  $\Ss : \sortsty$ and $R : \Func{\SortCat{\Ss}}{\SET}$,
  the category $\SortCat{\sortssnoc\ \Ss\ R}$ has:
  % 
  \begin{itemize}
  \item objects: $(X : | \SortCat{\Ss} |) \times (R X \to \Set)$,
  \item morphisms $(X,Z) \to (Y,W)$ consist of
    \begin{itemize}
    \item a morphism $f : \SortCat{\Ss}(X,Y)$
    \item a dependent function
      $g : (x : R X) \to Z\ x \to W\ (R\ f\ x)$.
    \end{itemize}
  \end{itemize}
\end{definition}

\begin{remark}
  The use of induction-recursion can be avoided here as well, using
  the same techniques as in \cref{avoiding-induction-recursion}
\end{remark}

\begin{example}
  The sort of an ordinary inductive definition can be represented by
  the list $[R_0]$ (\ie $\sortssnoc\ \sortsnil\ R_0$) where
  $R_0 : \Func{\termcat}{\SET}$ is defined as the constant functor
  $R_0\ x \ddefeq \unitty$. The resulting category $\SortCat{R_0}$ has
  objects $(\unitval : \unitty) \times (A : \unitty \to \Set)$ and a
  morphism $(x, A) \to (y, B)$ is given by, since trivially
  $x = y = \unitval$, a trivial morphism $\unitty \to \unitty$
  together with a function $f\ x : A\ x \to B\ x$ for every $x : 1$. In
  other words, this category is equivalent to the category $\SET$.
\end{example}

In the above example it may seem superfluous to have the empty list
interpreted as the terminal category and not as $\SET$. However, this
choice allows us to have the first sort be indexed by some other type,
\eg $\natty$. Hence a definition of the vectors would have as sort
specification the list $[R_0]$ with $R_0\ x \ddefeq \natty$.

\begin{example}
  The sort of the context and types example $(\ttconty, \tttyty)$ can be
  represented by the list $[R_0, R_1]$ with
  \begin{itemize}
  \item $R_0 : \Func{\termcat}{\SET}$, $R_0\ x \ddefeq \unitty$
  \item $R_1 : \Func{\SortCat{R_0}}{\SET}$, $R_1 (x, A) \ddefeq A\ x$
  \end{itemize}
  The category $\SortCat{R_0,R_1}$ has objects
  $(x : \unitty) \times (A : \unitty \to \Set) \times (B : A\ x \to
  \Set)$.
  We see that this category is equivalent to the category $\FAM$ of
  families of sets.
\end{example}

\begin{example}
  \label{rel-sorts}
  Similarly, the category $\REL$ can be represented by the list
  $[R_0, R_1]$ with
  \begin{itemize}
  \item $R_0 : \Func{\termcat}{\SET}$, $R_0\ x \ddefeq 1$
  \item $R_1 : \Func{\SortCat{R_0}}{\SET}$, $R_1 (x, A) \ddefeq A\ x \times A\ x$
  \end{itemize}
  We see that $\SortCat{R_0,R_1}$ is equivalent to the category with
  objects $(X : \Set, R : X \to X \to \Set)$ and morphisms
  $(X,R) \to (Y,S)$ given by $f : X \to Y$ together with
  $g : (x\ y: X) \to R\ x\ y \to S\ (f\ x)\ (f\ y)$.
\end{example}

\subsection{Sort membership}

When we have multiple sorts, we need a way to select a particular sort
from this collection. When defining a constructor, we first have to
say what its sort is. To this end we define in this section a sort
membership relation.

Given a specification $\Ss : \sortsty$ and a functor
$R : \Func{\SortCat{\Ss}}{\SET}$, we can define a forgetful functor
$t : \Func{\SortCat{\sortssnoc\ s\ R}}{\SortCat{\Ss}}$ which maps an object
$(X , P) : \SortCat{\sortssnoc\ s\ R}$ to $X$. A specification
$\Ss = [R_0, \ldots, R_n] : \sortsty$ therefore defines a chain of
categories:
$$
\xymatrix{
\termcat &S_0 \ar[l]_{t_0} &S_1 \ar[l]_{t_1} &\hdots \ar[l]_{t_2} &S_n \ar[l]_{t_n}
}
$$
where $n$ is the number of functors in the list and
$S_i = \SortCat{R_0, \ldots, R_i}$ is the category of sorts truncated
to the first $i$ elements. Every $t_i$ is the forgetful functor into
the previous category.

\begin{example}
In the case of $\REL$, we get the sequence
\[
\xymatrix{
\termcat &\SET \ar[l]_{t_0} &\REL \ar[l]_{t_1}
}
\]
\end{example}

We define a membership relation
$$
  \sortsin{\_}{\_} : \Cat \to \sortsty \to \Set
$$
where $\sortsin{\Cc}{\Ss}$ means that $\Cc$ is one of the $S_i$ in the
chain ${S_0 \leftarrow \ldots \leftarrow S_n}$. We do not want
$\sortsin{\termcat}{\Ss}$, as adding a constructor of that sort does
not add anything to the inductive definition. 

\begin{definition}[Sort membership]
  We formalise the membership relation as the following inductive
  type:
%
  \begin{datatype}{\sortsin{\_}{\_}}{\Cat \to \sortsty \to \Set}
    \constr{\sortsinhere}{(\Ss : \sortsty)\ (R : \Func{\SortCat{\Ss}}{\SET}) \to \sortsin{\SortCat{\sortssnoc\ \Ss\ R}}{\sortssnoc\ \Ss\ R}} \\
    \constr{\sortsinthere}{(\Ss : \sortsty)\ (R :
      \Func{\SortCat{\Ss}}{\SET})\ (\Cc : \Cat) \to \sortsin{\Cc}{\Ss}
      \to \sortsin{\Cc}{\sortssnoc\ \Ss\ R}}
  \end{datatype}
\end{definition}

\begin{example}
  Consider the specification of $\REL$ (\cref{rel-sorts}). If we want
  to say that $\sortsin{\SortCat{[R_0]}}{[R_0,R_1]}$ (recall that
  $\SortCat{[R_0]}$ is equivalent to $\SET$), then we can do so by
  giving the following term:
  $$
  \sortsinthere\ [R_0]\ R_1\ \SortCat{R_0}\ (\sortsinhere\ \sortsnil\ R_0) : \sortsin{\SortCat{ [ R_0 ] }}{[R_0,R_1]}
  $$
\end{example}
%

Suppose we have a chain of sorts
$S_0 \from S_1 \from \hdots \from S_n$ and a functor
$\Und : \Func{\Cc}{S_n}$, then naturally we can extend this functor to
$\extendfunc{\Und} : \Func{\Cc}{S_i}$ for any $S_i$ in the chain by
composing with the forgetful functors. We can implement this operation
with our inductive definition of sort membership:

\begin{definition}[Extending functors along sort membership]
  For every specification $\Ss : \sortsty$ with a functor
  $\Und : \Func{\Cc}{\SortCat{\Ss}}$, we define the function:
  $$
  \extendfunc{\Und} : (S_i : \Cat) \to \sortsin{S_i}{\Ss} \to
  \Func{\Cc}{S_i}
  $$
  This function is defined by induction over the proof of
  $\sortsin{S_i}{\Ss}$. 

  For the action of $\extendfunc{\Und}$ on objects and morphisms we
  will usually leave the membership proof argument implicit, \eg we
  just write $\extendfunc{\Und} X$ and $\extendfunc{\Und} f$.
\end{definition}

\subsection{Makkai's dependent sorts}

As mentioned before, giving an inductive definition is similar to
defining an equational theory: we specify the type formation rules, or
the sorts, we specify the point constructors, or the function symbols
and we specify the path constructors, or the equations. The inductive
types themselves are the term models of the theory described by the
constructors. One important aspect of our inductive definitions is
that our type formation rules do not just give us a collection of
types, but also type \emph{families}: we do have \emph{dependent
  sorts}.

In Makkai's FOLDS (first-order logic with dependent sorts) \cite{Makkai1995}, these
dependent sorts are represented as presheaves over certain
categories. Observe that the category of families $\FAM$ can either be
defined as having objects $(X : \Set) \times (P : X \to \Set)$ or as
having as objects $(X\ Y : \Set) \times (p : Y \to X)$. The latter
category can be explained as the presheaf category $\SET^I$, where $I$
is the arrow category $\cdot \to \cdot$.

\begin{example}
  Suppose we have an inductive definition of a category, which has
  sorts
%
  \begin{itemize}
  \item $O : \Set$
  \item $A : O \to O \to \Set$ (a family of arrows)
  \item $T : (x\ y\ z : O) \to A\ x\ y \to A\ y\ z \to A\ x\ z \to \Set$
    (a family of triangles)
  \end{itemize}
%
  The corresponding category of sorts can be represented as presheaves
  over the category:
$$
\xymatrix{ \cdot \ar@<-.5ex>[r] \ar@<.5ex>[r] &\cdot \ar@<-.75ex>[r]
  \ar@<.0ex>[r] \ar@<.75ex>[r] &\cdot }
$$
\end{example}

In Makkai, they consider dependent sorts to be specified by presheaves
on a \emph{direct category}.
\begin{definition}[Direct category]
  A category $\Cc$ is \emph{direct} if $\Cc$ contains no infinite
  descending chain of non-identity morphisms.
\end{definition}
Intuitively this means that all the arrows go in the ``same
direction'' and that there are no non-trivial automorphisms.

If a category $\Cc$ is such that $\opcat{\Cc}$ is direct, then $\Cc$
is an \emph{inverse category}. Considering presheaves on a direct
category is the same as considering functors of an inverse category
into $\SET$.

There is also no finiteness restriction on direct categories, so one
could also talk about presheaves from the simplex category, without
the degeneracies, $\Delta^+$:
$$
\xymatrix{
\cdot     
\ar@<-.5ex>[r]
\ar@<.5ex>[r]
&\cdot
\ar@<-1ex>[r]
\ar@<0ex>[r]
\ar@<1ex>[r]
&\cdot
\ar@<-1.5ex>[r]
\ar@<-.5ex>[r]
\ar@<.5ex>[r]
\ar@<1.5ex>[r]
&\hdots
}
$$
Our definition of sorts does not support infinitely many sorts,
however one could take a coinductive interpretation of the $\sortsty$
type.

Some sorts do not translate easily to the presheaf approach. Take for
example the sorts:
\begin{itemize}
\item $A : \Set$
\item $B : \List\ A \to \Set$
\end{itemize}
With the $\sortsty$ datatype, we are allowed to use arbitrary
functors, so this readily translates to that setting. In the presheaf
setting, there is no such a straightforward translation possible.

We have chosen our specific definition of sorts in this way as it
follows our syntax closely. Most importantly, the sort membership
relation can be defined easily and used in a straightforward manner.

\subsection{Sort categories via comma categories}

Another perspective on sort categories is seeing them as comma
categories. Recall that the category $\FAM$ can be seen as the arrow
category $\SET^I$. $\SET^I$ is a presheaf category having as objects
functors $\Func{I}{\SET}$. Alternatively, this arrow category is the
comma category $\SET \downarrow \SET$. By considering other functors
into $\SET$ on the right of this comma category instead of just the
identity functor, we arrive at our sort categories. For example,
suppose we have the following sequence of sort categories:
$$
\xymatrix{
\termcat
\ar[d]^{R_0}
&S_0
\ar[d]^{R_1}
\ar[l]_{t_0}
&S_1
\ar[d]^{R_2}
\ar[l]_{t_1}
&S_2
\ar[l]_{t_2} \\
\SET
&\SET
&\SET
}
$$
where $R_i$ are the defining functors of the sorts. We have that
$S_0 = \SET \downarrow R_0$, $S_1 = \SET \downarrow R_1$ and
$S_2 = \SET \downarrow R_2$.

\section{Categories of algebras}
\label{categories-of-algebras}

Now that we have a way of specifying the type formation rules of an
inductive definition, we can talk about the introduction rules. We
have also seen how to deal with constructors referring to previous
constructors in a $\SET$-sorted setting. We move on to the final two
pieces of the puzzle: constructors of arbitrary sort and path
constructors.

\subsection{A $\REL$-sorted quotient inductive-inductive type}

As a warm-up we will give an example of how the specification and the
categories of algebras look like for the following quotient
inductive-inductive definition:
%
\begin{sorts}
  \sortnamety{\Aty}{\Set} \\
  \sortnamety{\Bty}{\Aty \to \Aty \to \Set}
\end{sorts}
%
\begin{datatype}{\Aty}{}
  \constr{\Aco}{\Aty} \\
  \constr{\Aci}{\Aty}
\end{datatype}
%
\begin{datatype}{\Bty}{}
  \constr{\Bcii}{\natty \to \Bty\ \Aco\ \Aci} \\
  \constr{\Bciii}{(n : \natty) \to \Bcii\ n = \Bcii\ (n+1)}
\end{datatype}

In this section we will show step by step, \ie constructor by
constructor, how the category of algebras of the above inductive
definition is built up. We will get a chain of categories:
$$
\xymatrix{
\Alg_0
&\Alg_1
\ar[l]_{V_0}
&\Alg_2
\ar[l]_{V_1}
&\Alg_3
\ar[l]_{V_2}
&\Alg_4
\ar[l]_{V_3}
}
$$
where $\Alg_i$ is the category that ``contains'' the first $i$
constructors. The functors $V_i$ are the forgetful functors. $\Alg_4$
is the category we are ultimately interested in: this is the category
of algebras that is associated with the full inductive definition.

\subsubsection{Sorts: $(A : \Set) \times (B : A \to A \to \Set)$} 

The category of sorts is the category $\REL$ of (proof-relevant)
relations. In \cref{rel-sorts} we saw how this can be represented as a
list of functors. This category is also the first category of
algebras, \ie the algebras with no constructors, and will as such also
be referred to as $\Alg_0$. It is important to note that we have the
forgetful functor $t_1 : \Func{\REL}{\SET}$, giving us the underlying
set of a relation.

\subsubsection{First constructor: $\Aco : \Aty$}

The first constructor $\Aco$ has no arguments and is of sort
$\Aty : \Set$. Its arguments can be described by the functor
$F_0 : \Func{\REL}{\SET}$ with $F_0\ (X,R) \ddefeq \unitty$. The
category of algebras for the first constructor is then
$\dialgcat{F_0}{t_1}$, where $t_1 : \Func{\REL}{\SET}$ is the
forgetful functor. Strictly speaking, an $(F_0,t_1)$-dialgebra
structure on a relation $(X,R)$ is a function $1 \to X$, but for this
example we will work with the equivalent definition: the category
$\Alg_1$ has:
\begin{itemize}
\item objects: $(X : \Set) \times (R : X \to X \to \Set) \times (\theta_0 : X)$.
\item morphisms $(X,R,\theta_0) \to (Y,S,\rho_0)$ consist of:
  \begin{itemize}
  \item a function $f : X \to Y$
  \item a dependent function $g : (x\ y : X) \to R\ x\ y \to S\ (f\ x)\ (f\ y)$
  \item an equality $f_0 : f\ \theta_0 = \rho_0$
  \end{itemize}
\end{itemize}
%
We see that we get a morphism $(f,g)$ in $\REL$ along with a
computation rule $f_0$ that tells us that the morphism in $\REL$
preserves the $(F_0,t_1)$-dialgebra structure.
%
Note that $F_0$ is a functor from $\REL$ to $\SET$ and is not an
endofunctor on $\SET$: the constructor may refer to elements of fibres
of the relation $X \to X \to \Set$ being defined. The category
$\Alg_1$ also comes with a forgetful functor
$V_1 : \Func{\Alg_1}{\Alg_0}$ defined by
$V_1 ((X,R),\theta_0) \ddefeq (X,R)$ --- in fact, every category of
algebras $\Alg_{i+1}$ has a similarly defined forgetful functor
$V_{i+1} : \Func{\Alg_{i+1}}{\Alg_i$}. Chaining all these together
until we get to $\REL$, we get functors
$U_i : \Func{Alg_{i+1}}{\REL}$.

\subsubsection{Second constructor: $\Aci : \Aty$}

For the second constructor $\Aci$, the specification is largely
similar: it is given by the functor $F_1 : \Func{\Alg_1}{\SET}$
defined by $F_1\ (X, R, \theta_0) \ddefeq \unitty$. $\Alg_2$ has the
same objects as $\Alg_1$, but extended with an extra point:
$| \Alg_2 | = ((X,R,\theta_0) : | \Alg_1 |) \times (\theta_1 : X)$.
Equivalently, $\Alg_2$ can be thought of as being the dialgebra
category $\dialgcat{F_1}{t_1 \circ U_1}$.

\subsubsection{Third constructor: $\Bcii : \natty \to \Bty\ \Aco\ \Aci$}

The third constructor $\Bcii$ maps into a different sort which is not
$\SET$, hence its definition will be slightly different. We want the
resulting category $\Alg_3$ of algebras for constructors
$\Aco, \Aci, \Bcii$ to have as objects:
$$
((X,R,\theta_0,\theta_1) : | \Alg_2 |) \times (\theta_2 : \natty \to R\ \theta_0\ \theta_1)
$$
The morphisms is where it gets a bit hairy: we want morphisms
$((X,R),\theta_0,\theta_1,\theta_2) \to ((Y,S),\rho_0,\rho_1,\rho_2)$
to consist of
$(f,g,f_0,f_1) :
\Alg_2(((X,R),\theta_0,\theta_1),((Y,S),\rho_0,\rho_1))$
together with an equality
$$
g_2 : (n : \natty)  \to \pathover{S}{(f_0,f_1)}{g\ \theta_0\ \theta_1\ (\theta_2\ n)}{\rho_2\ n}
$$

Note how we have to use the equalities $f_0 : f\ \theta_0 = \rho_0$ and
$f_1 : f\ \theta_1 = \rho_1$ to reconcile the types of
$$
g\ \theta_1\ \theta_2\ (\theta_2\ n) : S\ (f\ \theta_0)\ (f\ \theta_1)
$$
and 
$$
\rho_2 : S\ \rho_0\ \rho_1 .
$$
Realising the above as a dialgebra category is a bit tricky. We now
have to deal with dependent functions and dependent equalities. The
situation can be simplified however. Observe that if we have the
following type
$$
(x : A) \to P\ (e\ x)
$$
for some $P : B \to \Set$ and $e : A \to B$, we can rewrite it to the
equivalent type:
$$
(x : A)\ (b : B) \to b = e\ x \to P\ b
$$
By singleton contraction, we can show that the two types are indeed
equivalent. The latter version is sometimes referred to as the ``Henry
Ford''-style type (you can have any $b : B$ you want, as long as it is
$e\ x$). Along these lines, we can rewrite the type of $\theta_2$ to the equivalent:
$$
\hat{\theta_2} : (x\ y : X) \to ((x = \theta_0) \times (y = \theta_1) \times \natty) \to R\ x\ y 
$$
and define the functor $F_2 : \Func{\Alg_2}{\REL}$ by
$F_2 ((X,Y),\theta_0,\theta_1) \ddefeq (X , \lambda x\ y . (x =
\theta_0) \times (y = \theta_1) \times \natty)$
in order to see that $\hat{\theta_2}$ is a $(F_2,U_2)$-dialgebra. The
objects in this category give us ``too much'': such a dialgebra gives
us a morphism $F_2((X,Y),\theta_0,\theta_1) \to (X,Y)$ in $\REL$, so
we also get a function $X \to X$. We can solve this problem by adding
an equation that the function $X \to X$ need be the identity. $\Alg_3$
is therefore not a category of dialgebras, but a subcategory of one,
as we will elucidate later on in \cref{point-constructors}.

\subsubsection{Fourth constructor: $\Bciii : (n : \natty) \to \Bcii\ n = \Bcii\ (n+1)$}

The fourth constructor $\Bciii$ is a path constructor, hence we not
only need to supply a functor $F_3 : \Func{\Alg_3}{\Alg_0}$ to specify
the arguments, but we also need to specify the endpoints of the
path. Just as for $\Bcii$, we will first need to rewrite the type of
the constructor. We denote again by $\hat{\theta_2}$ the Henry
Ford-version of $\theta_2$.  We then have that the type
$(n : \natty) \to \theta_2\ n = \theta_2\ (n+ 1)$ is equivalent to the
type
%
\begin{multline*}
(x\ y : X) \to \big((p : x =  \theta_0) \times (q : y = \theta_1) \times (n : \natty)\big) \\
\ \ \ \ \to \hat{\theta_2}\ x\ y\ p\ q\ n = \hat{\theta_2}\ x\ y\ p\ q\ (n+1)
\end{multline*}
%
The endpoints can then be specified as natural transformations
$\ell, r : \Nat{F_3}{U_3}$, where $F_3 : \Func{\Alg_3}{\REL}$ is defined in a
way similar to $F_2$. Given an algebra $A : \Alg_3$, $\ell_A$ and $r_A$
both define a morphism in
$\REL$. $\ell_{(X,R,\theta_0,\theta_1,\theta_2)}$ and
$r_{(X,R,\theta_0,\theta_1,\theta_2)}$ are defined as
$(\id_X, \ell^1_{(X,R,\theta_0,\theta_1,\theta_2)})$ and
$(\id_X,r^1_{(X,R,\theta_0,\theta_1,\theta_2)})$ respectively, with
%
\begin{align*}
&\ell^1_{(X,R,\theta_0,\theta_1,\theta_2)}\ a\ b\ (p, q, n) \ddefeq \hat{\theta_2}\ a\ b\ p\ q\ n \\
&r^1_{(X,R,\theta_0,\theta_1,\theta_2)}\ a\ b\ (p, q, n) \ddefeq \hat{\theta_2}\ a\ b\ p\ q\ (n+1)
\end{align*}
%
By function extensionality, we can then say the category of algebras
$\Alg_4$ has objects
$(X : | \Alg_4 |) \times (\theta_3 : \ell_X = r_X)$, which can be
described as an equaliser category. The morphisms are just morphisms
in $\Alg_3$ with no extra structure. For higher inductive types, one
usually expects a path computation rule for any path constructor, but
as we are working with sets, equalities between paths are trivial.

\subsection{Specification of a quotient inductive-inductive definition}

So far we have seen how to specify dependent sorts, deal with
constructors referring to previous ones and have worked out how the
category of algebras for a specific example, exhibiting point and path
constructors of arbitrary sort, can be built up. In this section we
will put everything together, arriving at our formal definition of a
specification of a quotient inductive-inductive definition.

A quotient inductive-inductive definition is given by a specification
of its sorts $\Ss : \sortsty$ plus a list of constructors, which may
be point or path constructors, each of which has a sort
$\sortsin{\Aa}{\Ss}$ and builds upon the category of
algebras of the previous constructors. We can formalise this as
follows:

\begin{definition}[Specification of quotient
inductive-inductive definitions]
\label{qiids-spec}

The specification of a quotient inductive-inductive definition with
sorts $\Ss : \sortsty$, along with its category of algebras and
underlying carrier functor is given by the following
inductive-recursive definition of
\begin{sorts}
  \sortnamety{\specty}{\Set} \\
  \functy{\Constr}{(s : \specty)\ (\Aa: \Cat) \to \sortsin{\Aa}{\Ss} \to \Set} \\
  \functy{\Alg}{\specty \to \Cat} \\
  \functy{\Und}{(s : \specty) \to \Func{\Alg_s}{\SortCat{\Ss}}} \\
\end{sorts}
% 
with
%
\begin{datatype}{\specty}{}
  \constr{\specnil}{\specty} \\
  \constr{\specsnoc}{(s : \specty)\ (\Aa: \Cat)\ (p : \sortsin{\Aa}{\Ss}) \to \Constr\ s\ \Aa\ p \to \specty}
\end{datatype}
%
where $\Constr\ s\ \Aa\ p$ is defined as:
$$
\Constr\ s\ \Aa\ p \ddefeq \Constr_{\ident{point}}\ s\ \Aa\ p + \Constr_{\ident{path}}\ s\ \Aa\ p
$$
%
The functions $\Constr_{\ident{point}}$, $\Constr_{\ident{path}}$, $\Alg$ and $\Und$ will be
defined in the remainder of this section, treating point constructors
in \cref{point-constructors} and path constructors in \cref{path-constructors}.

\end{definition}

Let us compare this definition to the previous descriptions of
$\SET$-sorted definitions (\cref{type-sorted-spec}). It looks largely
similar in that we mutually define the type of specifications with the
definition of its categories of algebras and forgetful functors. There
is the addition of the function $\Constr$, $\specsnoc$ constructor has
a different type, as does the forgetful functor $\Und$.

In the constructor $\specsnoc$, instead of having as argument a
functor from a category of algebras into $\SET$, we have:
$$
\specsnoc : (s : \specty)\ (\Aa: \Cat)\ (p : \sortsin{\Aa}{\Ss}) \to \Constr\ s\ \Aa\ p \to \specty
$$
The arguments $\Aa : \Cat$, $p : \sortsin{\Aa}{\Ss}$ define the sort
of this particular constructor, where the type $\Constr\ s\ \Aa\ p$
contains the further data needed to specify the constructor. What this
data is, \ie the definition of $\Constr_{\ident{point}}$ and
$\Constr_{\ident{path}}$ will be given in \cref{point-constructors}
and \cref{path-constructors}.

The forgetful functors $\Und$ now do not map into $\SET$, but into the
category of sorts $\SortCat{\Ss}$.

\subsection{Point constructors}
\label{point-constructors}

In this section we will define three things:
%
\begin{itemize}
\item what the data for a point constructor is, \ie we will define $\Constr_{\ident{point}}$,
\item what, given these data, the category of algebras is,
\item what the forgetful functor from this new category of algebras
  into the category of sorts is.
\end{itemize}
%
Suppose we have $\sortsin{S_i}{\Ss}$ and $s : \specty$, and we have
already constructed
%
\begin{itemize}
\item $\Alg_s : \Cat$,
\item $\Und_s : \Func{\Alg_s}{\SortCat{\Ss}}$ its forgetful functor, and
\item the extension $\extendfunc{\Und}_s : \Func{\Alg_s}{S_i}$ of $\Und_s$, which we
  get from $\sortsin{S_i}{\Ss}$.
\end{itemize}
%
From the proof that $\sortsin{S_i}{\Ss}$, we get some information
about the category $S_i$. We know that we get a functor
$t_i : \Func{S_i}{S_{i-1}}$ for some category $S_{i-1}$ and that the
objects of $S_i$ are of the form
$(X : | S_{i-1} |) \times (R_i X \to \Set)$ for some functor
$R_i : \Func{S_{i-1}}{\SET}$.

To make this more concrete: suppose $\Ss$ contains $n$ sorts and $s$
describes $m$ constructors, then an object in $X : \Alg_s$ is a tuple
$(X_0, \hdots, X_n, \theta_0, \hdots, \theta_m)$. The functor $\Und_s$
gives us back all underlying carriers, \ie
$\Und_s(X_0, \hdots, X_n, \theta_0, \hdots, \theta_m) = (X_0, \hdots,
X_n)$
and the functor $\extendfunc{\Und}_s$ further projects down to the $i$ first
carriers $X_0, \hdots, X_i$, with
$(X_0, \hdots, X_{i-1}) : | S_{i-1} |$ and
\[
X_i : R_i (X_0, \hdots, X_{i-1}) \to \Set \enspace .
\]
Recall that $R_i : \Func{S_{i-1}}{\SET}$ is the functor that describes how
the family $X_i$ depends on the previous sorts $X_0, \hdots,
X_{i-1}$. A point constructor structure on $X$ is of the form
$$
\theta : (x : R_i (X_0, \hdots, X_{i-1})) \to F^1\ (X_0, \hdots, X_n, \theta_0, \hdots, \theta_m)\ x \to X_i\ x
$$
where
$$
F^1 : ((X_0,\hdots,X_n,\theta_0,\hdots,\theta_m) : | \Alg_s |) \to R_i (X_0, \hdots, X_{i-1}) \to \Set
$$
Note that the functor $\extendfunc{\Und}_s$ can be decomposed into two parts: we
have $\extendfunc{\Und}^0 : \Alg_s \to S_{i-1}$ and
$\extendfunc{\Und}^1 : (X : \Alg_s) \to R_i\ (\extendfunc{\Und}^0\ X) \to \Set$.
$\extendfunc{\Und}^0$ can also be written as $t_i \circ \extendfunc{\Und}_s$, where
$t_i : S_i \to S_{i-1}$ is the forgetful functor of $S_i$. In order
for the point constructor specified by $F^1$ to be well-defined, \ie
to make sense of its computation rule, we need
$F X \ddefeq (\extendfunc{\Und}^0\ X, F^1\ X)$ to be a functor
$\Func{\Alg_s}{S_i}$.  This leads us to the definition of a point
constructor specification:

\begin{definition}[Data for a point constructor]
  \label{data-point-constructor}

  Given a specification $s : \specty$, a point constructor of sort
  $\sortsin{S_i}{\Ss}$ is specified by giving a functor
  $F : \Func{\Alg_s}{S_i}$ such that the following commutes:
  $$
  \xymatrix{
    \Alg_s \ar[r]^{F} \ar[d]_{\extendfunc{\Und}_s} &S_i \ar[d]^{t_i} \\
    S_i \ar[r]^{t_i} &S_{i-1}
  }
  $$
  In other words, we have
  $$
  \Constr_{\ident{point}}\ s\ S_i\ p \ddefeq (F : \Func{\Alg_s}{S_i}) \times (p : t_i \circ F = t_i \circ \extendfunc{\Und}_s) \enspace .
  $$
\end{definition} 

The fact that $F$ must satisfy the commutativity condition intuitively
means that $F$ leaves the sorts $(X_0, \hdots, X_{i-1})$
``untouched''. We can think of $F$ as describing a family of functors,
fibred over the sorts $(X_0, \hdots, X_{i-1})$.

We now explain how to construct the category $\Alg_{s'}$ of algebras
for a specification with an additional point constructor. Suppose
the specification $s'$ has been obtained as the extension of a
specification $s$ by a point constructor given by a functor
$F : \Alg_s \to S_i$, which decomposes as $F = (\extendfunc{\Und}^0, F^1)$. The
previous characterisation of a point constructor algebra structure on
an object $X : | \Alg_s |$ can be summarised as having a dependent
function of morphisms
\[
\theta : (x : R_i (\extendfunc{\Und}^0\ X)) \to F^1\ X\ x \to \extendfunc{\Und}^1\ X\ x
\]
A morphism $(X,\theta) \to (Y,\rho)$ consists of a morphism
$f : \Alg_s(X,Y)$ along with a ``computation rule'':
\begin{multline*}
f_0 : (x : R_i \ (\extendfunc{\Und}^0\ X))\ (y : F^1\ X\ x) \to \\ 
\extendfunc{\Und}^1\ f\ x\ (\theta\ x\ y) = \rho\ (R_i(\extendfunc{\Und}^0\ f\ x)\ (F^1\ f\ x\ y))
\end{multline*}
This category of algebras look similar to
$\dialgcat{F}{\extendfunc{\Und}_s}$. However, as we have seen previously, the
category of dialgebras contains too much: morphisms there also come
with a superfluous endomorphism in $S_{i-1}$. We want this morphism to
be an identity morphism, which we can achieve by taking an
equaliser. The category $\dialgcat{F}{\extendfunc{\Und}_s}$ comes with two
forgetful functors: $V$ that gives us the carrier of the algebra and
$V^I$ that gives us algebra structure on the carrier, which is a
morphism in $S_i$ or equivalently, an object in the arrow category
$S_i^I$. The definition of the new category of algebras is as follows:

\begin{definition}[Category of algebras for a point constructor]
  \label{algebras-point-constructor}

  Let $s' : \specty$ be the specification $s$ extended with a
  point constructor of sort $S_i$ given by a functor $F : \Alg_s \to S_i$
  satisfying $t_i \circ F = t_i \circ \extendfunc{\Und}_s$. The category of
  algebras $\Alg_{s'}$ is as the following equaliser in $\Cat$:
  \[
  \xymatrix{
    \Alg_{s'} \ar[r]^-{e} &\dialgcat{F}{\extendfunc{\Und}_s} \ar[r]^-{V} \ar[d]^-{V^I} &\Alg_s \ar[r]^-{\extendfunc{\Und}_s} &S_i \ar[r]^{t_i} &S_{i-1} \ar[d]^-{\id} \\
    &S_i^I \ar[rrr]^{t_i^I} && &S_{i-1}^I }
  \]
  where $e$ is the projection map of the equaliser, $t_i^I$ is the
  functor $t_i$ lifted to a functor between the respective arrow
  categories and $\id$ is the functor that assigns to each object the
  identity morphism of that object.

  The forgetful functor $\Und_{s'} : \Alg_s' \to \SortCat{\Ss}$ is defined as the composite:
  \[
    \xymatrix{
      \Alg_{s'} \ar[r]^-{e} &\dialgcat{F}{\extendfunc{\Und}_s} \ar[r]^-{V} &\Alg_s \ar[r]^-{\Und_s} &\SortCat{\Ss}
    }
  \]
\end{definition}

Note that usually the construction of equalisers in the category
$\Cat$ is \emph{evil} as it uses equality on objects. Since we are
working with univalent categories, equality of objects coincides with
isomorphism of objects, hence this is not an issue in our setting.

\begin{remark}
  To explicate the phenomenon of a category of dialgebras containing
  ``too much'', we will look at how the category of algebras of the
  following inductive-inductive definitions is built up:
  %
  \begin{sorts}
    \sortnamety{\Aty}{\Set} \\
    \sortnamety{\Bty}{\Aty \to \Set}
  \end{sorts}
  %
  \begin{datatype}{\Aty}{}
    \constr{\Aco}{\Aty}
  \end{datatype}
  %
  \begin{datatype}{\Bty}{}
    \constr{\Bci}{(x : \Aty) \to \emptyty \to \Bty\ x}
  \end{datatype}
  %
  We can see that $\Aty$ is equivalent to $\unitty$. The second
  constructor $\Bci$ does not add anything to any $\Bty\ x$: $B$ is
  the constantly empty family.

  The constructor $\Aco$ can be described by
  the functor:
  \begin{align*}
    &F_0 : \Func{\FAM}{\SET} \\
    &F_0 (X , P) \ddefeq \unitty
  \end{align*}
  The category of algebras containing only the first constructor is
  $\dialgcat{F_0}{V}$ where $V : \Func{\FAM}{\SET}$ is the forgetful
  functor. The second constructor $\Bci$, which does not add anything
  to the inductive type, can be described by the functor:
  \begin{align*}
    &F_1 : \Func{\dialgcat{F_0}{V}}{\FAM} \\
    &F_1 ((X , P) , \theta) \ddefeq (X , \lambda x . \emptyty)
  \end{align*}
  It is clear that this functor satisfies the condition that
  $V \circ F_1 = V \circ U_0$ where
  $U_0 : \Func{\dialgcat{F_0}{V}}{\FAM}$ is the forgetful functor.

  If we then unfold the definition of $\dialgcat{F_1}{U_0}$, we see
  that it has objects:
  \begin{align*}
    &&| \dialgcat{F_1}{U_0} | = &\ (X : \Set) \times (P : X \to \Set) \\
    &&\times&\ (\theta_0 : \unitty \to X) \\
    &&\times&\ (\theta_1 : X \to X) \times (\theta_2 :  (x : X) \to \emptyty \to P\ (\theta_1\ x) \\
    &&=&\ (X : \Set) \times (P : X \to \Set) \times (\theta_0 : X) \times (\theta_1 : X \to X)
  \end{align*}
  
  As mentioned before: we see that we get a superfluous $X \to X$
  function. For the inductive definition on its own, we are just
  interested in the initial object of the category of algebras. Here
  we see that the initial object of the dialgebra category is the
  natural numbers with a constantly empty family over it, which is
  different from what we want: a \emph{unit type} with a constantly
  empty family over it.
\end{remark}

\subsection{Path constructors}
\label{path-constructors}

Specifying the arguments for a path constructor is done in exactly the
same way as for a point constructor, while the endpoints of the path
are given by natural transformations. Suppose $s : \specty$, then a
path constructor structure of sort $\sortsin{S_i}{\Ss}$ on an object
$(X_0, \hdots, X_n, \theta_0,\hdots,\theta_m) : | \Alg_s |$ is of the
form:
\begin{align*}
  &\theta : (x : R_i (X_0, \hdots, X_{i-1})) \\
  &\ \ \to (y : F^1\ (X_0, \hdots, X_n, \theta_0, \hdots, \theta_m)\ x \\
  &\ \ \to \ell^1_{(X_0,\hdots,X_n,\theta_0,\hdots,\theta_m)}\ x\ y =_{X_i\ x} r^1_{(X_0,\hdots,X_n,\theta_0,\hdots,\theta_m)}\ x\ y 
\end{align*}
where
\begin{itemize}
\item
  $F^1 : (X : | \Alg_s |) \to R_i (\extendfunc{\Und}^0 X) \to \Set$,
  such that $F X \ddefeq (\extendfunc{\Und}^0 X, F^1 X)$ is a functor
  $\Func{\Alg_s}{S_i}$, and
\item
  $\ell^1, r^1 : (X : | \Cc |)\ (x : R_i (\extendfunc{\Und}^0\ X))\ (y : F^1\ X\ x)
  \to \extendfunc{\Und}^1\ X\ x$
  such that $\ell_X \ddefeq (\id_{\extendfunc{\Und}^0 X}, \ell^1)$ and
  $r_X \ddefeq (\id_{\extendfunc{\Und}^0 X}, r^1)$ are natural transformations
  $\Nat{F}{\extendfunc{\Und}_s}$.
\end{itemize}
Algebra morphisms $(X,\theta) \to (Y,\rho)$ are simply morphisms
$X \to Y$ in $\Alg_s$. As we are working with sets, we do not need
computation rules for the paths: any equation between paths is
trivial.

Summarising the above, we get to the following definition of
path constructor specification:

\begin{definition}[Data for a path constructor]
  \label{data-path-constructor}

  Given a specification $s : \specty$, a path constructor of sort
  $\sortsin{S_i}{\Ss}$ is specified by a functor
  $F : \Func{\Alg_s}{S_i}$ satisfying
  $t_i \circ F = t_i \circ \extendfunc{\Und}_s$ and two natural
  transformations $\ell, r : \Nat{F}{\extendfunc{\Und}_s}$, such that
  when whiskered\footnote{Whiskering a natural transformation
    $\alpha : \Nat{F}{G}$, with $F, G : \Func{\Cc}{\Dd}$ with a
    functor $H : \Func{\Dd}{\Ee}$ yields a natural transformation
    $H \alpha : \Nat{HF}{HG}$ by applying $H$ on every component of
    $\alpha$.} with $t_i$ they are the identity natural
  transformation, \ie they satisfy
  $t_i\ \ell = t_i\ r = \id_{t_i \circ \extendfunc{\Und}_s}$:
\begin{align*}
  \Constr_{\ident{path}}\ s\ S_i\ p \ddefeq (F : \Alg_s \to S_i) &\times (p : t_i \circ F = t_i \circ \extendfunc{\Und}_s) \\ 
  \times (\ell : \Nat{F}{\extendfunc{\Und}_s}) &\times (q_\ell : t_i\ \ell = \id_{t_i \circ \extendfunc{\Und}_s}) \\ 
  \times (r : \Nat{F}{\extendfunc{\Und}_s}) &\times (q_r : t_i\ r = \id_{t_i \circ \extendfunc{\Und}_s}) \enspace .
\end{align*}
\end{definition}

The restriction on the natural transformations $\ell$ and $r$ is the
same kind of restriction as the restriction on $F$: the natural
transformations must leave the sorts below $S_i$ untouched.

Note that by function extensionality, the type of $\theta$ is
equivalent to $\ell^1_X = r^1_X$. Since
$t_i\ \ell_X = t_i\ r_X = \id_{t_i \circ \extendfunc{\Und}_s}$ the
equality $\ell^1_X = r^1_X$ of dependent functions in $\SET$ is
equivalent to the equality $\ell_X = r_X$ of morphisms in $S_i$. We
also observe that a natural transformation
$\alpha : \Nat{F}{\extendfunc{\Und}_s}$ gives rise to a functor
$\hat{\alpha} : \Func{\Alg_s}{S_i^I}$, mapping $X : | \Alg_s |$ to
$\alpha_X : S_i(F\ X,\extendfunc{\Und}_s\ X)$. Functoriality of this
functor comes from the naturality of $\alpha$. This leads us to the
definition of the category of algebras for a path constructor:

\begin{definition}[Category of algebras for a path constructor]
  \label{algebras-path-constructor}

  Let $s' : \specty$ be the specification
  $s$ extended with a path constructor of sort
  $S_i$ given by a functor $F : \Alg_s \to S_i$ satisfying $t_i \circ
  F = t_i \circ \extendfunc{\Und}_s$ and natural transformations $l, r : F \to
  \extendfunc{\Und}_s$ satisfying $t_i\ l = t_i\ r = \id_{t_i \circ
    \extendfunc{\Und}_s}$. The category of algebras
  $\Alg_{s'}$ is defined as the following equaliser in $\Cat$:
  \[
  \xymatrix{
    \Alg_{s'} \ar[r]^{e} &\Alg_s \ar@<-.5ex>[r]_-{\hat{r}} \ar@<.5ex>[r]^-{\hat{\ell}} &S_i^I
  }
  \]
  where $e$ is the projection map of the equaliser.

The forgetful functor $\Und_{s'} : \Alg_s' \to \SortCat{\Ss}$ is defined as the composite
\[
\xymatrix{
    \Alg_{s'} \ar[r]^{e} &\Alg_s \ar[r]^{\Und_s} &\SortCat{\Ss}
}
\]
\end{definition}

\section{Other forms of constructors}
\label{other-forms-of-constructors}

We have characterised quotient inductive-inductive definitions as
(subcategories of) iterated dialgebras. For the dialgebras we have
looked at, we only had the freedom to choose the left functor, \ie if
we look at the point constructors we have seen so far, they all are of
the shape:
$$
\Ac : S_i(F X , U X)
$$
where $s : \specty$ and $F, U : \Func{\Alg_s}{S_i}$ for some sort
category $S_i$. We have only considered the case where $U$ is a
forgetful functor. This begs the question if we generalise this to a
larger class of dialgebras. For example, can we have constructors such
as:
$$
\Ac : \Aty \to \List\ \Aty
$$
It turns out that this particular example does not work out. To see
this, let us define the following inductive definition:
\begin{datatype}{\Aty}{\Set}
  \constr{\Aco}{\Aty} \\
  \constr{\Aci}{\Aty \to \List\ \Aty}
\end{datatype}

\begin{proposition}
  $\Aty$ does not exist, \ie the category of algebras that corresponds
  to the above inductive definition does not have an initial algebra.
\end{proposition}

\begin{proof}
  Suppose $(X,x,\theta)$ is an initial algebra, \ie a pointed set
  $(X,x)$ with a function $\theta : X \to \List\ X$. By pattern
  matching, we know that $\theta\ x$ is either $\listnil$ or
  $\listcons\ a\ as$ for some $a : X$ and $as : \List\ A$.

  If $\theta\ x = \listnil$, then we can define an algebra
  $(\unitty, \unitval, \lambda x . [ \unitval ])$. We observe that there are no
  algebra morphisms from $(X,x,\theta)$ into
  $(\unitty, \unitval, \lambda x . [ \unitval ]$): for $f : X \to \unitty$, which
  obviously satisfies $f\ x = \unitval$, we have that
  $\listnil = \List\ f\ (\theta\ x) \neq [ \unitval ]$.

  In the case that $\theta\ x = \listcons\ a\ as$, we can do something
  similar: instead of having a singleton list as the algebra on
  $(\unitty, \unitval)$, we have the empty list. We can then observe
  that there are no algebra morphisms from $(X,x,\theta)$ into
  $(\unitty, \unitval, \lambda x . \listnil)$.
\end{proof}

There are examples of constructors that do make sense. If we want to
truncate our inductive type to be propositional, we can add a
constructor:
$$
\Ac : \isprop\ \Aty
$$
This works out in this case, as $\isprop\ \Aty$ is equivalent to
$(x\ y : \Aty) \to x = y$. 

Other examples that are allowed, are constructors of the form
$B \to \Aty \times \Aty$, as this is equivalent to have two
constructors with type $B \to \Aty$. Generalising this, the result type
may be given by any representable functor. One notable example of such
a representable functor is the stream functor, \eg we can have a
constructor, with $B : \Set$:
$$
\Ac : B \to \Stream\ \Aty
$$
as this is equivalent to $B \to \natty \to \Aty$.

\subsection{Dependent dialgebras}

As an earlier attempt to unifying the treatment of point and path
constructors, we have considered \emph{dependent dialgebras}
\cite{Altenkirch2015ii}, \ie given $F : \Func{\Cc}{\SET}$ and
$G : \Func{\int_{\Cc} F}{\SET}$ a dependent dialgebra is an object
$X : | \Cc |$ along with:
$$
\theta : (x : FX) \to G (X , x)
$$
This turned out not to be a nice notion to work with, as the category
$\int_{\Cc} F$ is not a well-behaved category to work with for our
purposes. In particular, when defining what morphisms between these
algebras should be, we need to lift a morphism in $\Cc$ to one in
$\int_{\Cc} F$. There is a canonical way of doing so, given an
$x : FX$ for some $X : | \Cc |$: given $f : \Cc(X,Y)$ with $x : FX$,
we define:
%
\begin{align*}
  &\hat{f}_x : \int_{\Cc} F ((X,x),(Y,F\ f\ x)) \\
  &\hat{f}_x \ddefeq (f , \refl)
\end{align*}
%
This operation is not functorial in the untruncated setting: we do not
have $\widehat{g \circ f}_x = \hat{g}_{F f x} \circ \hat{f}_x$. This
makes the approach unattractive if we want to generalise to higher
inductive types.

\subsection{Currying}

When a constructor has multiple arguments, we often write things down
in its curried form, \eg suppose we have $K, L : \Set$ and define the
following constructor for type $\Aty$:
$$
\Ac : K \to (L \to \Aty)
$$
In our presentation, we consider dialgebras where the functor
describing the target of the constructor is usually a forgetful
functor. As such, we are forced to have all our constructors in
uncurried form, \eg the above case would be $K \times L \to \Aty$. To
describe the curried constructor $\Ac$, we can see it as a
$(F,G)$-dialgebra with $F X \ddefeq K$ and $G X \ddefeq (L \to X)$.
This approach does not always work, if we were to consider instead the
constructor:
$$
\Ac : K \to (\Aty \to \Aty)
$$
We cannot define $G X \ddefeq (X \to X)$ as it is not functorial. So
it seems that at this level of syntax, dialgebras are not the
appropriate concept to describe what is going on.

\section{Positivity}
\label{positivity}

Not all expressions of the type $\Set \to \Set$ are functorial: the
arguments may only be in positive positions in the result. As we have
mentioned in \cref{intro}, $\lambda X . (X \to X)$ is
problematic. Whilst problematic, such negative occurrences can be
useful. One example of is the higher order abstract syntax embedding
of untyped lambda calculus:
%
\begin{datatype}{\tttmty}{\Set}
  \constr{\ttapp}{\tttmty \to \tttmty \to \tttmty} \\
  \constr{\ttlam}{(\tttmty \to \tttmty) \to \tttmty}
\end{datatype}
%
In the constructor $\ttlam$, there is a recursive occurrence in both
negative as well as a positive position. The map
$\lambda X . (X \to X)$ is therefore not functorial: it is neither
contravariant nor covariant. 

This is problematic with pattern matching semantics. Having an
inductive type such as $\tttmty$ along with pattern matching (even
when recursion is restricted to structurally smaller subterms), is
unsound and allows us to write diverging terms.

Another example of this phenomenon is if we write down an inductive
definition with as constructors the axioms of a field:
%
\begin{datatype}{\fieldty}{\Set}
  \constr{\fieldzero}{\fieldty} \\
  \constrdots \\
  \constr{\fieldinv}{(x : \fieldty) \to ((x = \fieldzero) \to \emptyty) \to \fieldty} \\
  \constrdots
\end{datatype}
%
The category of algebras of this specification should be equivalent to
the category of fields. If the datatype $\fieldty$ were to exist, it
then would be the initial object in this category. However, the
category of fields does not have an initial object. The problem with
the datatype is that the constructor $\fieldinv$ has a recursive
occurrence in a negative position: the constructor $\fieldzero$ occurs
in a negative position.

\section{Related work}
\label{describing-related-work}

\subsection{Inductive-inductive definitions}

The approach we have taken in our framework builds heavily on the work
on inductive-inductive types \cite{Altenkirch2011}. In the article,
the authors describe the categorical interpretation of an
inductive-inductive definition with one $\SET$-sorted point
constructor, followed by one $\FAM$-sorted point constructor. We have
slightly altered their idea of using an equaliser category for the
$\FAM$-sorted constructor to allow us to iterate the construction more
easily. Furthermore, we have extended the framework to support a
larger class of sorts rather than $\FAM$ and have added support for
path constructors.

\subsection{Inductive definitions in Agda}
Our framework allows us to specify most of the inductive definitions
we can write down in Agda. The notable exception is that we do not
support induction-recursion. However, some forms of
induction-recursion can be simulated, using the methods described in
\cite{Hancock2013}.

Apart from the absence of induction-recursion, there is another
fundamental difference between our framework and that of Agda. In Agda
we have to group all the constructors per sort, \ie we cannot write
down a definition with sorts $\Aty : \Set$, $\Bty : \Aty \to \Set$ and
constructors:
%
\begin{itemize}
\item $\Aco : \Aty$
\item $\Bci : \Bty\ \Aco$
\item $\Acii : \Bci = \Bci \to \Aty$
\end{itemize}
%
We cannot alternate between the sorts in Agda, which prevents us from
defining types as the one given above. Our framework has no such
restriction.

Furthermore, Agda allows for certain negative inductive
definitions. Its positivity checker only checks whether the recursive
occurrences referring to the type being defined are in strictly
positive positions. It does not check whether references to previous
\emph{constructors} are in strictly positive positions. For example,
the following definition is accepted:
%
\begin{datatype}{\Aty}{\Set}
  \constr{\Aco}{\Aty} \\
  \constr{\Aci}{((\Aco = \Aco) \to \Aty) \to \Aty}
\end{datatype}
%
The operation $\lambda (X,\theta) . (\theta = \theta) \to \Aty$ is not
functorial, so we cannot represent this example in our framework. As
of yet, it is unclear whether this is a bug in Agda's positivity
checker, \ie we have not found a way yet to use this to prove falsity.

Similarly, Agda allows for sorts which are not positive. For example,
Agda accepts the following definition:
%
\begin{sorts}
    \sortnamety{\Aty}{\Set} \\
    \sortnamety{\Bty}{(\Aty \to \Aty) \to \Set}  
\end{sorts}
%
\begin{datatype}{\Aty}{}
  \constr{\Aco}{\Aty}
\end{datatype}
%
\begin{datatype}{\Bty}{}
  \constr{\Bci}{\Bty\ (\lambda x . x)}
\end{datatype}
%
We cannot formalise definitions of this shape in our framework, as the
operation $\lambda X . (X \to X)$ is not functorial, hence we cannot
define its dependent sorts. As with the previous example, it is as of
yet unclear to us whether definitions of this form may lead to
inconsistencies.

\subsection{Higher inductive types}

Our quotient inductive-inductive definitions are a first approximation
to a theory of higher inductive types. The presentation here has been
inspired by work on the semantics of higher inductive types
\cite{Lumsdaine2013} via monads in model categories. Furthermore,
\cite{Capriotti2014ii} and \cite{Altenkirch2015ii}, which also build
upon that note, have influenced the design choices of this framework.
