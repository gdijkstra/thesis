\chapter{Describing inductive definitions}

\section{Algebraic semantics}

\section{$\Set$-sorted inductive-inductive definitions}

We have mentioned that one of the defining features of the inductive
definitions we want to be able to handle, is any constructor may refer
to any of its previous constructors. Some examples we have seen of
this phenomenon are:
%
\begin{itemize}
\item the constructor $\intseg : \intzero = \intone$ of the interval
  type, $\intty$, which refers to both its previous constructor,
\item the constructor
  $\ttpi : (\Gamma : \ttconty) (A : \tttyty\ \Gamma) \to \tttyty\
  (\ttcons{\Gamma}{A}) \to \tttyty\ \Gamma$,
  which refers to the previous constructor
  $\ttcons{\_}{\_} : \Gamma : \ttconty) \to \tttyty\ \Gamma \to
  \ttconty$.
\end{itemize}

Describing inductive definitions with such constructors is not
something we can do with a single endofunctor on an appropriately
chosen category. Instead of having one functor, we need a functor for
every constructor. The domain of the $n$-th functor will then be the
``category of algebras of all previous constructors''. 

\begin{example}
  \label{silly-type}
  To illustrate this idea, we consider the following example (which we
  can easily show to be equivalent to the booleans):
  % 
  \begin{datatype}{\Tty}{\Type}
    \constr{\Ta}{\unitty \to \Tty} \\
    \constr{\Tb}{(t : \Tty) \times \Ta\ \unitval = t \to \Tty}
  \end{datatype}
  % 
\end{example}

The first constructor $\Ta$ can be described as being an $F_0$-algebra
structure on $\Tty$, with $F_0 : \Type \to \Type$ being defined as
$F_0 X \ddefeq \unitty$. The arguments of $\Tb$ are described by the
functor $F_1 : \algcat{F_0} \to \Type$ with:
$$
F_1 (X,a) \ddefeq (x : X) \times a\ \unitval = x
$$
Since $F_1$ is not an endofunctor, $\Tb$ cannot be described as an
$F_1$-algebra structure. However, $\algcat{F_0}$ comes with a
forgetful functor $U_0 : \algcat{U_0} \to \Type$ which gives us the
carrier of the algebra. We therefore have that
$\Tb : F_1(\Tty,\Ta) \to U_0(\Tty,\Ta)$, \ie $\Tb$ is an
$(F_1,U_0)$-\emph{dialgebra}~\cite{Hagino1987} structure on
$(\Tty,\Ta) : \algcat{F_0}$.
%
\begin{definition}
  \label{dialg}
  Let $F, G : \Cc \to \Dd$ be functors. The category $\dialgcat{F}{G}$ has
  as objects pairs $(X, \theta)$ where $X : |\Cc|$ and $\theta : F X \to
  G X$. A morphism from $(X, \theta)$ to $(Y, \rho)$ is a morphism $f : X
  \to Y$ in $\Cc$ such that the following commutes:
  $$
  \xymatrix{
  F X \ar[r]^{\theta} \ar[d]_{F f} &G X \ar[d]^{G f} \\
  G X \ar[r]^{\rho}  &G Y
  }
  $$
\end{definition}
%

As $\specty$ is essentially a list type, we will use list notation for
its values, \eg we denote $\specsnoc\ (\specsnoc\ F_0\ \specnil)\ F_1$
as $[F_0,F_1]$.

Any dialgebra category $\dialgcat{F}{G}$ comes with a forgetful
functor $U : \dialgcat{F}{G} \to \Cc$ which projects out the carrier
of the algebra. This means in particular that we have a forgetful
functor $U_1 : \dialgcat{F_1}{U_0} \to \algcat{F_0}$. If we were to
add a third and a fourth constructor, we would have to define a
functors $F_2 : \dialgcat{F_1}{U_0} \to \Type$ and
$F_3 : \dialgcat{F_2}{U_0 \circ U_1} \to \Type$ to describe
their arguments. The objects we are interested in are \emph{iterated}
dialgebras. For the situation described above we have:
$$
\xymatrix{
\Type 
\ar[d]_{F_0}
&\algcat{F_0} 
\ar[d]_{F_1}
\ar[l]_{U_0}
&\dialgcat{F_1}{U_0}
\ar[d]_{F_2}
\ar[l]_{U_1}
&\dialgcat{F_2}{U_0 \circ U_1}
\ar[d]_{F_3}
\ar[l]_{U_2}
&\dialgcat{F_3}{U_0 \circ U_1 \circ U_2}
\ar[l]_{U_3}
\\
\Type
&\Type
&\Type
&\Type
&
}
$$

Note that we build the category of dialgebras over another category of
dialgebras, \ie we are working with \emph{iterated} dialgebras. All of
the categories of dialgebras have a forgetful functor into $\Type$. We
can formalise the concept $\Type$-sorted inductive-inductive
definitions as a inductive-recursive type:
%
\begin{definition}
  \label{type-sorted-spec}
  The specification of a $\Type$-sorted inductive-inductive definition
  and its category of algebras and underlying carrier functor is given
  by the following inductive-recursive
  definition of
  %
  \begin{sorts}
    \sortnamety{\specty}{\Type} \\
    \functy{\Alg}{\specty \to \Cat} \\
    \functy{\Und}{(s : \specty) \to \Func{\Alg_s}{\Type}}
  \end{sorts}
  %
  where $\specty$ is inductively generated by
  %
  \begin{datatype}{\specty}{}
    \constr{\specnil}{\specty} \\
    \constr{\specsnoc}{(s : \specty) \to \Func{\Alg_s}{\Type} \to \specty}
  \end{datatype}
  %
  and $\Alg$ and $\Und$ are defined by
  %
  \begin{align*}
    \Alg\ \specnil &\ddefeq \Type \\
    \Alg\ (\specsnoc\ s\ F) &\ddefeq \dialgcat{F}{U_s} \\
    \\
    \Und\ \specnil &\ddefeq\ \id \\
    \Und\ (\specsnoc\ s\ F) &\ddefeq U_s \circ V
  \end{align*}
  %
  where $V$ is the forgetful functor that gives the underlying object of
  a dialgebra.
\end{definition}

\begin{example}
  The example in \cref{silly-type} can be represented by the
  specification $[F_0, F_1]$ where $F_0$ and $F_1$ are the same
  functors as before, as we have that $\Type \defeq \Alg_{[]}$,
  $\algcat{F_0} \defeq \Alg_{[F_0]}$ and
  $\dialgcat{F_1}{U_0} \defeq \Alg_{[F_0,F_1]}$.
\end{example}

\subsection{Avoiding induction-recursion}
\label{avoiding-induction-recursion}

The type of specifications in \cref{type-sorted-spec} is given
inductive-recursively. Intuitively the type is just a snoc-list of
functors. The induction-recursion allows us to succinctly make sure
that the domain of the functors is always a category of algebras. We
can avoid induction-recursion by separately defining the snoc-list of
functors and a predicate on that list that ensures the domain of the
functors is correct:

\begin{definition}
  % 
  \begin{datatype}{\specaltty}{\Type}
    \constr{\specaltnil}{\specaltty} \\
    \constr{\specaltsnoc}{\specaltty \to (\Cc : \Cat)\ (\Func{\Cc}{\Type}) \to \specaltty}
  \end{datatype}
  % 
  On this type, we define a predicate mutually with its interpretation
  function $\Algalt$ with forgetful functor $\Undalt$:
  %
  \begin{sorts}
    \functy{\specaltiscorrect}{\specaltty \to \Type} \\
    \functy{\Algalt}{(s : \specaltty) \times (\specaltiscorrect\ s) \to \Cat} \\
    \functy{\Undalt}{(s : \specaltty) \times (p : \specaltiscorrect\ s) \to \Func{\Algalt_{(s,p)}}{\Type}}
  \end{sorts}
  %
  where
  %
  \begin{align*}
    \specaltiscorrect\ \specaltnil &\ddefeq \unitty \\
    \specaltiscorrect\ (\specaltsnoc\ s\ \Cc\ F) &\ddefeq (p : \specaltiscorrect) \times (\Cc = \Algalt_{(s,p)})
  \end{align*}
  %
  The definitions of $\Alg'$ and $\Und'$ are similar to the previous
  definitions: we can pattern match on the equality proofs we get from
  $\specaltiscorrect$ and then use the previous definitions.
\end{definition}

\begin{remark}
  The mutual definition of $\specaltiscorrect$, $\Alg'$ and $\Und'$
  can be avoided by combining all three definitions into one function
  with all its arguments and result types combined in a big
  $\Sigma$-type.
\end{remark}

\begin{proposition}
  The types $\specty$ and $(s : \specaltty) \times \specaltiscorrect\ s$ are equivalent.
\end{proposition}

\begin{proof}
  This is a straightforward proof by induction on the types involved.
\end{proof}

\section{Dependent sorts}

Describing how a sort depends the previous sorts can be done by
providing a functor of the previous category of sorts into $\Type$. A
complete description is then a snoc-list of functors, which can be
formalised inductive-recursively together with the function that
interprets the list as a category.
% 
\begin{definition}
  The specification of sorts and their interpretation as a
  categories is given by the following inductive-recursive
  definition
  % 
  \begin{sorts}
    \sortnamety{\sortsty}{\Type} \\
    \functy{\SortCat{\_}}{\sortsty \to \Cat}
  \end{sorts}
  where $\sortsty$ is inductively generated by
  %
  \begin{datatype}{\sortsty}{}
    \constr{\sortsnil}{\sortsty} \\
    \constr{\sortssnoc}{(\Ss : \sortsty) \to (\Func{\SortCat{\Ss}}{\Type}) \to \sortsty}
  \end{datatype}
  % 
  with $\SortCat{\sortsnil}$ defined as the terminal category $\termcat$, and given
  $\Ss : \sortsty$ and $R : \Func{\SortCat{\Ss}}{\Type}$,
  the category $\SortCat{\sortssnoc\ \Ss\ R}$ has:
  % 
  \begin{itemize}
  \item objects: $(X : | \SortCat{\Ss} |) \times (R X \to \Type))$,
  \item morphisms $(X,Z) \to (Y,W)$ consists of
    \begin{itemize}
    \item a morphism $f : \SortCat{\Ss}(X,Y)$
    \item a dependent function
      $g : (x : R X) \to Y\ x \to W\ (R\ f\ x)$.
    \end{itemize}
  \end{itemize}
\end{definition}

\begin{remark}
  The use of induction-recursion can be avoided here as well, using
  the same techniques as in \cref{avoiding-induction-recursion}
\end{remark}

\begin{example}
  The sort of an ordinary inductive definition can be represented by
  the list $[R_0]$ (\ie $\sortssnoc\ \sortsnil\ R_0$) where
  $R_0 : \Func{\termcat}{\Type}$ is defined as the constant functor
  $R_0\ x \ddefeq \unitty$. The resulting category $\SortCat{R_0}$ has
  objects $(\unitval : \unitty) \times (A : \unitty \to \Type)$ and a
  morphism $(x, A) \to (y, B)$ is given by, since trivially
  $x = y = \unitval$, a trivial morphism $\unitty \to \unitty$
  together with a function $f\ x : A\ x \to B\ x$ for every $x : 1$. In
  other words, this category is equivalent to the category $\Type$.
\end{example}

In the above example it may seem superfluous to have the empty list
interpreted as the terminal category and not as $\Type$. However, this
choice allows us to have the first sort be indexed by some other type,
\eg $\natty$. Hence a definition of the vectors would have as sort
specification the list $[R_0]$ with $R_0\ x \ddefeq \natty$.

\begin{example}
  The sort of the context and types example $(\ttconty, \tttyty)$ can be
  represented by the list $[R_0, R_1]$ with
  \begin{itemize}
  \item $R_0 : \Func{\termcat}{\Type}$, $R_0\ x \ddefeq \unitty$
  \item $R_1 : \Func{\SortCat{R_0}}{\Type}$, $R_0 (x, A) \ddefeq A\ x$
  \end{itemize}
  The category $\SortCat{R_0,R_1}$ has objects
  $(x : \unitty) \times (A : \unitty \to \Type) \times (B : A\ x \to
  \Type)$.
  We see that this category is equivalent to the category $\Fam$ of
  families of sets.
\end{example}

\begin{example}
  \label{rel-sorts}
  Similarly, the category $\Rel$ can be represented by the list
  $[R_0, R_1]$ with
  \begin{itemize}
  \item $R_0 : \Func{\termcat}{\Type}$, $R_0\ x \ddefeq 1$
  \item $R_1 : \Func{\SortCat{R_0}}{\Type}$, $R_0 (x, A) \ddefeq A\ x \times A\ x$
  \end{itemize}
  We see that $\SortCat{R_0,R_1}$ is equivalent to the category with
  objects $(X : \Type, R : X \to X \to \Type)$ and morphisms
  $(X,R) \to (Y,S)$ given by $f : X \to Y$ together with
  $g : (x\ y: X) \to R\ x\ y \to S\ (f\ x)\ (f\ y)$.
\end{example}

\subsection{Sort membership}

A specification $\Ss = [R_0, \ldots, R_n] : \sortsty$ defines a chain of categories
\[
\xymatrix{
1 &S_0 \ar[l]_{t_0} &S_1 \ar[l]_{t_1} &\hdots \ar[l]_{t_2} &S_n \ar[l]_{t_i}
}
\]
where $n$ is the number of functors in the list and
$S_i = \SortCat{R_0, \ldots, R_i}$ is the category of sorts truncated
to the first $i$ elements. Every $t_i$ is the forgetful functor that
maps $(X,Y)$ to $X$.

\begin{example}
In the case of $\Rel$, we get the sequence
\[
\xymatrix{
1 &\Type \ar[l]_{t_0} &\Rel \ar[l]_{t_1}
}
\]
\end{example}

When giving a quotient inductive-inductive definition, we start out by
defining its sorts. When specifying a constructor, we need to say what
sort we want to construct points or paths in. To this end, we can
define a membership relation
\[
  \_ \in \_ : \Cat \to \sortsty \to \Type
\]
where $\Cc \in \Ss$ means that $\Cc$ appears in the chain
${1 \leftarrow S_0 \leftarrow \ldots \leftarrow S_n}$ corresponding to
$\Ss$, \ie $\Cc$ is either $1$, or $S_i$ for some $0 \leq i \leq
n$.
For a quotient inductive-inductive definition with sorts
$\Ss : \sortsty$, specifying the sort for a constructor is done by
giving a category $\Aa : \Cat$ along with a proof of $\Aa \in \Ss$.

\subsection{Makkai's dependent sorts}

\section{Categories of algebras}

\subsection{A $\Rel$-sorted quotient inductive-inductive type}

As a warm-up, in this section we will give an example of how the
specification and the categories of algebras look like for the
following quotient inductive-inductive definition:
%
\begin{sorts}
  \sortnamety{\Aty}{\Set} \\
  \sortnamety{\Bty}{\Aty \to \Aty \to \Set}
\end{sorts}
%
\begin{datatype}{\Aty}{}
  \constr{\Aco}{\Aty} \\
  \constr{\Aci}{\Aty}
\end{datatype}
%
\begin{datatype}{\Bty}{}
  \constr{\Bcii}{\natty \to \Bty\ \Aco\ \Aci} \\
  \constr{\Bciii}{(n : \natty) \to \Bcii\ n = \Bcii\ (n+1)}
\end{datatype}

The sorts of the definition are
$(A : \Set) \times (B : A \to A \to \Set)$: the category of sorts is
the category $\Rel$. In \cref{rel-sorts} we saw how this can be
represented as a list of functors. This category is also the first
category of algebras, \ie algebras with no constructors, and will as
such also be referred to as $\Alg_0$.

\subsubsection{Specifying constructors}
The first constructor $\Aco$ has no arguments and is of sort
$\Aty : \Set$. Its arguments can be described by the functor
$F_0 : \Func{\Rel}{\Set}$ with $F_0\ (X,R) \ddefeq \unitty$. The
category of algebras for the first constructor is then
$\dialgcat{F_0}{t_1}$, where $t_1 : \Func{\Rel}{\Set}$ is the
forgetful functor. Strictly speaking, an $(F_0,t_1)$-dialgebra
structure on a relation $(X,R)$ is a function $1 \to X$, but for this
example we will work with the equivalent definition
$| \Alg_1 | \equiv (X : \Set) \times (R : X \to X \to \Set) \times
(\theta_0 : X)$.
Morphisms $(X,R,\theta_0) \to (Y,S,\rho_0)$ consist of:
%
\begin{itemize}
\item $f : X \to Y$
\item $g : (x\ y : X) \to R\ x\ y \to S\ (f\ x)\ (f\ y)$
\item $f_0 : f\ \theta_0 = \rho_0$
\end{itemize}
%
We see that we get a morphism in $\Rel$ along with a computation rule
that tells us that the morphism in $\Rel$ preserves the
$(F_0,t_1)$-dialgebra structure.
%
Note that $F_0$ is a functor from $\Rel$ to $\Set$ and is not an
endofunctor on $\Set$: the constructor may refer to elements of fibres
of the relation $X \to X \to \Set$ being defined. The category
$\Alg_1$ also comes with a forgetful functor $U_1 : \Func{\Alg_1}{\Alg_0}$
defined by $U_1 ((X,R),\theta_0) \ddefeq (X,R)$ --- in fact, every
category of algebras $\Alg_{i+1}$ has a similarly defined forgetful
functor $U_{i+1} : \Func{\Alg_{i+1}}{\Alg_0$}.

For the second constructor $\Aci$, the specification is largely
similar: it is given by the functor $F_1 : \Func{\Alg_1}{\Set}$
defined by $F_1\ (X, R, \theta_0) \ddefeq \unitty$.

The third constructor $\Bcii$ maps into a different sort, hence its
definition will be slightly different. We want the resulting category
$\Alg_3$ of algebras for constructors $\Aco, \Aci, \Bcii$ to have
objects
$((X,R) : \Rel) \times (\theta_0 : X) \times (\theta_1 : X) \times
(\theta_2 : \natty \to R\ \theta_0\ \theta_1)$,
and we want morphisms
$((X,R),\theta_0,\theta_1,\theta_2) \to ((Y,S),\rho_0,\rho_1,\rho_2)$
to consist of
$(f,g,f_0,f_1) :
\Alg_2(((X,R),\theta_0,\theta_1),((Y,S),\rho_0,\rho_1))$
together with an equality
$$
g_2 : (n : \natty)  \to \pathover{S}{(f_0,f_1)}{g\ \theta_0\ \theta_1\ (\theta_2\ n)}{\rho_2\ n}
$$
%WAS: g_2 : (x\ y: X) (n : \natty)  \to g\ x\ y\ (\theta_2\ n) = \rho_2\ n
% -- CHECK new version is correct!
Note how we have to use the equalities $f_0 : f\ \theta_0 = \rho_0$ and
$f_1 : f\ \theta_1 = \rho_1$ to reconcile the types of
$g\ \theta_1\ \theta_2\ (\theta_2\ n) : S\ (f\ \theta_0)\ (f\
\theta_1)$ and $\rho_2 : S\ \rho_0\ \rho_1$.
%
Realising the above directly as a dialgebra category is a bit
tricky. However, we can rewrite the type of
$\theta_2 : \natty \to R\ \theta_0\ \theta_1$ to the equivalent ``Henry
Ford''-style type (you can have any $(x, y)$ you want, as long as it's
$(\theta_0, \theta_1)$)\
\[
\theta_2' : (x\ y : X) \to \big((x = \theta_0) \times (y = \theta_1) \times \natty\big) \to R\ x\ y 
\]
 %
and define the functor $F_2 : Alg_2 \to \Rel$ by
$F_2 ((X,Y),\theta_0,\theta_1) \ddefeq (X , \lambda x\ y . (x =
\theta_0) \times (y = \theta_1) \times \natty)$
in order to see that $\theta_2'$ is a $(F_2,U_2)$-dialgebra. The
objects in this category give us ``too much'': such a dialgebra gives
us a morphism $F_2((X,Y),\theta_0,\theta_1) \to (X,Y)$ in $\Rel$, so
we also get a function $X \to X$. We can solve this problem by adding
an equation that the function $X \to X$ need be the identity. $\Alg_3$
is therefore not a category of dialgebras directly, but an equaliser
of one, as we will elucidate later on in some section.

The fourth constructor $\Bciii$ is a path constructor. Hence, not only
do we need to supply a functor $F_3 : \Func{\Alg_3}{\Alg_0}$ to
specify the arguments, but we also need to specify the endpoints of
the path. Just as for $\Bcii$, we will first need to rewrite the type
of the constructor. We denote again by $\theta_2'$ the Henry
Ford-version of $\theta_2$.  We then have that the type
$(n : \natty) \to \theta_2\ n = \theta_2\ (n+ 1)$ is equivalent to the
type
%
\begin{multline*}
(x\ y : X) \to \big((p : x =  \theta_0) \times (q : y = \theta_1) \times (n : \natty)\big) \\
\ \ \ \ \to \theta_2'\ x\ y\ p\ q\ n = \theta_2'\ x\ y\ p\ q\ (n+1)
\end{multline*}
%
The endpoints can then be specified as natural transformations
$l, r : \Nat{F_3}{U_3}$, where $F_3 : \Func{\Alg_3}{\Rel}$ is defined in a
way similar to $F_2$. Given an algebra $A : \Alg_3$, $l_A$ and $r_A$
both define a morphism in
$\Rel$. $l_{((X,Y),\theta_0,\theta_1,\theta_2)}$ and
$r_{((X,Y),\theta_0,\theta_1,\theta_2)}$ are defined as
$(\id_X, l^1_{((X,Y),\theta_0,\theta_1,\theta_2)})$ and
$(\id_X,r^1_{((X,Y),\theta_0,\theta_1,\theta_2)})$ respectively, with
%
\begin{align*}
&l^1_{((X,Y),\theta_0,\theta_1,\theta_2)}\ a\ b\ (p, q, n) \ddefeq \theta_2'\ a\ b\ p\ q\ n \\
&r^1_{((X,Y),\theta_0,\theta_1,\theta_2)}\ a\ b\ (p, q, n) \ddefeq \theta_2'\ a\ b\ p\ q\ (n+1)
\end{align*}
%
By function extensionality, we can then say the category of algebras
$\Alg_3$ has objects $(X : | \Alg_2 |) \times (\theta_3 : l_X = r_X)$,
\ie it is an equaliser category. The morphisms are just morphisms in
$\Alg_2$ with no extra structure. For higher inductive types, one
usually expects a path computation rule for any path constructor, but
as we are working with sets, equalities between paths are trivial.

\subsection{Inductive-recursive definition of specifications}

We have already seen how $\Set$-sorted inductive-inductive definitions
can be formalised. Generalising this to arbitrary quotient
inductive-inductive definitions means that we have to generalise in
two aspects: we have to be able to deal arbitrary sorts, as well as
with path constructors.

Let $\Ss : \sortsty$ be a specification of sorts. Recall that we have a
predicate $\Aa \in \Ss$ that tells us that $\Aa : \Cat$ is one of the
sort categories in $\Ss$. Specifying a constructor now requires us to
specify a sort, which is done by using the predicate. The type of
quotient inductive-inductive specifications is then refined to the
following definition:

\begin{definition}[Specification of quotient
inductive-inductive types]
The specification of a quotient inductive-inductive type and its
category of algebras and underlying carrier functor is given by the
following inductive-recursive definition of
\begin{sorts}
  \sortnamety{\specty}{\Set} \\
  \functy{\Constr}{(s : \specty)\ (\Aa: \Cat) \to \Aa \in \Ss \to \Set} \\
  \functy{\Alg}{\specty \to \Cat} \\
  \functy{\Und}{(s : \specty) \to \Func{\Alg_s}{\SortCat{\Ss}}} \\
\end{sorts}
% 
with
%
\begin{datatype}{\specty}{}
  \constr{\specnil}{\specty} \\
  \constr{\specsnoc}{(s : \specty) (\Aa: \Cat) (p : \Aa \in \Ss) \to \Constr\ s\ \Aa\ p \to \specty}
\end{datatype}
%
where $\Constr\ s\ \Aa\ p$ is defined by recursion on $p : \Aa \in \Ss$ such that
\begin{align*}
&\Constr\ s\ 1\ p \ddefeq 0 \\
&\Constr\ s\ \Aa\ p \ddefeq \Constr_0\ s\ \Aa\ p + \Constr_1\ s\ \Aa\ p
\end{align*}
%
The functions $\Constr_0$, $\Constr_1$, $\Alg$ and $\Und$ will be
defined in the remainder of this section.
\end{definition}

Let us briefly discuss the defining clauses for $\Constr\ s\ \Aa\ p$,
which is meant to describe the data needed to specify a constructor of
sort $\Aa$. There should not be any constructors of the trivial sort
$\Aa = \termcat$, and if $\Aa$ is a non-trivial sort, then a
constructor can either be a point constructor specified by
$\Constr_0\ s\ \Aa\ p$, or a path constructor specified by
$\Constr_1\ s\ \Aa\ p$. The next two subsections will describe the
data needed for point and path constructors respectively.

\subsection{0-constructors}

Suppose we have $S_i \in \Ss$ and $s : \specty$, and we have already
constructed
%
\begin{itemize}
\item $\Alg_s : \Cat$,
\item $U_s : \Alg_s \to \SortCat{\Ss}$ its forgetful functor, and
\item the extension $\bar{U}_s : \Alg_s \to S_i$ of $U_s$, which we
  get from $S_i \in \Ss$.
\end{itemize}
%
To make more concrete: suppose $\Ss$ contains $n$ sorts and $s$
describes $m$ constructors, then an object in $X : \Alg_s$ is a tuple
$(X_0, \hdots, X_n, \theta_0, \hdots, \theta_m)$. The functor $U_s$
gives us back all underlying carriers, \ie
$U_s(X_0, \hdots, X_n, \theta_0, \hdots, \theta_m) = (X_0, \hdots,
X_n)$
and the functor $\bar{U}_s$ further projects down to the $i$ first
carriers $X_0, \hdots, X_i$, with
$(X_0, \hdots, X_{i-1}) : | S_{i-1} |$ and
\[
X_i : R_i (X_0, \hdots, X_{i-1}) \to \Set \enspace .
\]
Recall that $R_i : \Func{S_{i-1}}{\Set}$ is the functor that describes how
the family $X_i$ depends on the previous sorts $X_0, \hdots,
X_{i-1}$. A point constructor structure on $X$ is of the form
$$
\theta : (x : R_i (X_0, \hdots, X_{i-1})) \to F_1\ (X_0, \hdots, X_n, \theta_0, \hdots, \theta_m)\ x \to X_i\ x
$$
where
$$
F_1 : ((X_0,\hdots,X_n,\theta_0,\hdots,\theta_m) : | \Alg_s |) \to R_i (X_0, \hdots, X_{i-1}) \to \Set
$$
Note that the functor $\bar{U}_s$ can be decomposed into two parts: we
have $\bar{U}_0 : \Alg_s \to S_{i-1}$ and
$\bar{U}_1 : (X : \Alg_s) \to R_i\ (\bar{U}_0\ X) \to \Set$.
$\bar{U}_0$ can also be written as $t_i \circ \bar{U}_s$, where
$t_i : S_i \to S_{i-1}$ is the forgetful functor of $S_i$. In order
for the point constructor specified by $F_1$ to be well-defined, \ie
to make sense of its computation rule, we need
$F X \ddefeq (\bar{U}_0\ X, F_1\ X)$ to be a functor
$\Func{\Alg_s}{S_i}$.  This leads us to the definition of a point
constructor specification:

\begin{definition}
  Given a specification $s : \specty$, a point constructor of sort
  $S_i \in \Ss$ is specified by giving a functor
  $F : \Func{\Alg_s}{S_i}$ such that the following commutes:
  $$
  \xymatrix{
    \Alg_s \ar[r]^{F} \ar[d]_{\bar{U}_s} &S_i \ar[d]^{t_i} \\
    S_i \ar[r]^{t_i} &S_{i-1}
  }
  $$
  In other words, we have
  $$
  \Constr_0\ s\ S_i\ p \ddefeq (F : \Func{\Alg_s}{S_i}) \times (p : t_i \circ F = t_i \circ \bar{U}_s) \enspace .
  $$
\end{definition} 

The fact that $F$ must satisfy the commutativity condition intuitively
means that $F$ leaves the sorts $(X_0, \hdots, X_{i-1})$ ``untouched''.

We now explain how to construct the category $\Alg_{s'}$ of algebras
for a an specification with an additional point constructor. Suppose
the specification $s'$ has been obtained as the extension of a
specification $s$ by a point constructor given by a functor
$F : \Alg_s \to S_i$, which decomposes as $F = (\bar{U}_0, F_1)$. The
previous characterisation of a point constructor algebra structure on
an object $X : | \Alg_s |$ can be summarised as having a dependent
function of morphisms
\[
\theta : (x : R_i (\bar{U}_0\ X)) \to F_1\ X\ x \to \bar{U}_1\ X\ x
\]
A morphism $(X,\theta) \to (Y,\rho)$ consists of a morphism
$f : \Alg_s(X,Y)$ along with a ``computation rule'':
\begin{multline*}
f_0 : (x : R_i \ (\bar{U}_0\ X))\ (y : F_1\ X\ x) \to \\ \bar{U}_1(f)\ x\ (\theta\ x\ y) = \rho\ (R_i(\bar{U}_0(f))\ x)\ (F_1(f)\ x\ y)
\end{multline*}
This category of algebras look similar to
$\dialgcat{F}{\bar{U}_s}$. However, as we have seen previously, the
category of dialgebras contains too much: morphisms there also come
with a superfluous endomorphism in $S_{i-1}$. We want this morphism to
be an identity morphism, which we can achieve by taking an
equaliser. The category $\dialgcat{F}{\bar{U}_s}$ comes with two
forgetful functors: $V$ that gives us the carrier of the algebra and
$V^I$ that gives us algebra structure on the carrier, which is a
morphism in $S_i$ or equivalently, an object in the arrow category
$S_i^I$. The definition of the new category of algebras is as follows:

\begin{definition}
  Let $s' : \specty$ be the specification $s$ extended with a
  0-constructor of sort $S_i$ given by a functor $F : \Alg_s \to S_i$
  satisfying $t_i \circ F = t_i \circ \bar{U}_s$. The category of
  algebras $\Alg_{s'}$ is as the following equaliser in $\Cat$:
  \[
  \xymatrix{
    \Alg_{s'} \ar[r]^-{e} &\dialgcat{F}{\bar{U}_s} \ar[r]^-{V} \ar[d]^-{V^I} &\Alg_s \ar[r]^-{\bar{U}_s} &S_i \ar[r]^{t_i} &S_{i-1} \ar[d]^-{\id} \\
    &S_i^I \ar[rrr]^{t_i^I} && &S_{i-1}^I }
  \]
  where $e$ is the projection map of the equaliser, $t_i^I$ is the
  functor $t_i$ lifted to a functor between the respective arrow
  categories and $\id$ is the functor that assigns to each object the
  identity morphism of that object.

The forgetful functor $U_{s'} : \Alg_s' \to \SortCat{\Ss}$ is defined as the composite:
\[
\xymatrix{
    \Alg_{s'} \ar[r]^-{e} &\dialgcat{F}{\bar{U}_s} \ar[r]^-{V} &\Alg_s \ar[r]^-{U_s} &\SortCat{\Ss}
}
\]
\end{definition}

\subsection{1-constructors}

Specifying the arguments for a path constructor is done in exactly the
same way as for a point constructor, while the endpoints of the path
is given by natural transformations. Suppose $s : \specty$, then a path
constructor structure of sort $S_i \in \Ss$ on an object
$(X_0, \hdots, X_n, \theta_0,\hdots,\theta_m) : | \Alg_s |$ is of the
form:
\begin{align}
\label{eq:theta}
  \begin{split}
    &\theta : (x : R_i (X_0, \hdots, X_{i-1})) \\
    &\ \ \to (y : F_1\ (X_0, \hdots, X_n, \theta_0, \hdots, \theta_m)\ x \\
    &\ \ \to l^1_{(X_0,\hdots,X_n,\theta_0,\hdots,\theta_m)}\ x\ y =_{X_i\ x} r^1_{(X_0,\hdots,X_n,\theta_0,\hdots,\theta_m)}\ x\ y 
  \end{split}
\end{align}
where
\begin{itemize}
\item $F_1 : (X : | \Alg_s |) \to R_i (\bar{U}_0 X) \to \Set$, such
  that $F X \ddefeq (\bar{U}_0 X, F_1 X)$ is a functor $\Alg_s \to S_i$, and
\item
  $l^1, r^1 : (X : | \Cc |) (x : R_i (\bar{U}_0\ X)) (y : F_1\ X\ x)
  \to \bar{U}_1\ X\ x$
  such that $l_X \ddefeq (\id_{\bar{U}_0 X}, l^1)$ and
  $r_X \ddefeq (\id_{\bar{U}_0 X}, r^1)$ are natural transformations
  $\Nat{F}{\bar{U}_s}$.
\end{itemize}
Algebra morphisms $(X,\theta) \to (Y,\rho)$ are simply morphisms
$X \to Y$ in $\Alg_s$. As we are working with sets, we do not need
computation rules for the paths: any equation between paths is
trivial.

Summarising the above, we get to the following definition of
1-constructor specification:

\begin{definition}
  Given a specification $s : \specty$, a 1-constructor of sort
  $S_i \in \SortCat{\Ss}$ is specified by a functor
  $F : \Alg_s \to S_i$ satisfying $t_i \circ F = t_i \circ \bar{U}_s$
  and two natural transformations $\ell, r : F \to \bar{U}_s$ satisfying
  $t_i\ \ell = t_i\ r = \id_{t_i \circ \bar{U}_s}$, \ie
\begin{align*}
\Constr_1\ s\ S_i\ p \ddefeq (F : \Alg_s \to S_i) &\times (p : t_i \circ F = t_i \circ \bar{U}_s) \\ \times (\ell : F \to \bar{U}_s) &\times (q_\ell : t_i\ \ell = \id_{t_i \circ \bar{U}_s}) \\ \times (r : F \to \bar{U}_s) &\times (q_r : t_i\ r = \id_{t_i \circ \bar{U}_s}) \enspace .
\end{align*}
\end{definition}

The restriction on the natural transformations $\ell$ and $r$ is the
same kind of restriction as the restriction on $F$: the natural
transformations must leave the sorts below $S_i$ untouched.

Note that by function extensionality, the type of $\theta$ in
\eqref{eq:theta} is equivalent to $l^1_X = r^1_X$. Since
$t_i\ (l\ X) = t_i\ (r\ X) = \id_{t_i \circ
  \bar{U}}$, %: S_{i-1} (t_i(\bar{U} X), t_i (\bar{U} X))$,
the equality $l_1\ X = r_1\ X$ of dependent functions in
$\Set$ is equivalent to the equality $l\ X = r\ X
$ of morphisms in
$S_i$. We also observe that a natural transformation $\alpha : F \to
\bar{U}$ gives rise to a functor $\hat{\alpha} : \Alg_s \to
S_i^I$, mapping $X : | \Alg_s |$ to $\alpha_X : S_i(F\ X,\bar{U}\
X)$. Functoriality of this functor comes from the naturality of
$\alpha$. This leads us to the definition of the category of algebras
for a path constructor:

\begin{definition}
  Let $s' : \specty$ be the specification
  $s$ extended with a path constructor of sort
  $S_i$ given by a functor $F : \Alg_s \to S_i$ satisfying $t_i \circ
  F = t_i \circ \bar{U}_s$ and natural transformations $l, r : F \to
  \bar{U}_s$ satisfying $t_i\ l = t_i\ r = \id_{t_i \circ
    \bar{U}_s}$. The category of algebras
  $\Alg_{s'}$ is defined as the following equaliser in $\Cat$:
  \[
  \xymatrix{
    \Alg_{s'} \ar[r]^{e} &\Alg_s \ar@<-.5ex>[r]_-{\hat{r}} \ar@<.5ex>[r]^-{\hat{l}} &S_i^I
  }
  \]
  where $e$ is the projection map of the equaliser.

The forgetful functor $U_{s'} : \Alg_s' \to \SortCat{\Ss}$ is defined as the composite
\[
\xymatrix{
    \Alg_{s'} \ar[r]^{e} &\Alg_s \ar[r]^{U_s} &\SortCat{\Ss}
}
\]
\end{definition}

\subsection{Other constructors}



\section{From syntax to functors}

We have given a specification of inductive descriptions in terms of
its algebraic semantics. Sometimes the algebraic semantics is very
close to what one would want to write down in a proof assistant, \ie a
list of types of the constructors. There are some limitations to this
approach. When we want to fit an inductive definition into our schema,
we have to perform some translations first: we have the uncurry the
type and translate it into the ``Henry Ford''-version.

Other limitations are that the arguments part must be functorial:
recursive occurrences may only be in positive positions. One example
of a data type where this is not the case is the higher order abstract
syntax embedding of untyped lambda calculus:
%
\begin{datatype}{\tttmty}{\Set}
  \constr{\ttapp}{\tttmty \to \tttmty \to \tttmty} \\
  \constr{\ttlam}{(\tttmty \to \tttmty) \to \tttmty}
\end{datatype}
%
In the constructor $\ttlam$, there is a recursive occurrence in both
negative as well as a positive position. The map
$\lambda X . (X \to X)$ is therefore not functorial: it is neither
contravariant nor covariant. 

This is problematic with pattern matching ``semantics''.

Another example of this phenomenon is if we write down an inductive
definition with as constructors the axioms of a field:
%
\begin{datatype}{Field}{\Set}
  \hdots \\
  \constr{inv}{(x : Field) \to ((x = 0) \to \emptyty) \to Field} \\
  \hdots 
\end{datatype}
%

One difference between how one writes down inductive definitions in
Agda and our specification type is that in Agda we have to group all
the constructors per sort, \ie we cannot write down a definition with
sorts $\Aty : \Set$, $\Bty : \Aty \to \Set$ and constructors:
%
\begin{itemize}
\item $\Aco : \Aty$
\item $\Bci : \Bty\ \Aco$
\item $\Acii : \Bci = \Bci \to \Aty$
\end{itemize}
%
In Agda we cannot alternate between the sorts, which prevents us from
defining types as the one given above.
