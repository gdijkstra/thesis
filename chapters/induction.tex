\chapter{Induction versus initiality}

In the previous chapter we have seen how we can specify a quotient
inductive-inductive definition by giving a list of sorts and a list of
constructors: we have to give the type formation and introduction
rules. From these rules, we can then derive the category of
algebras. The notion of algebra morphism looks a lot like the
recursion principle for the inductive definition. In fact, saying that
an algebra is \emph{weakly initial} is precisely the statement that
the algebra satisfies the recursion principle. The link between full
initiality and the induction principle is a bit more
involved. Initiality talks about the morphism we get from the
recursion principle being \emph{unique}: its statement involves
equality of morphisms. The induction principle is something that
allows us to produce dependent functions into families over our
inductive definitions.

Initial algebra semantics is a very attractive way of ``explaining''
inductive definitions: stating the property of being initial only
requires us to have defined the objects and morphisms:

\begin{definition}[Initiality]
  An object $X$ of a category $\Cc$ is \emph{initial} if for every
  $Y : | \Cc |$ the set $\Cc(X,Y)$ is contractible.
\end{definition}

From this definition it also immediate that being initial is
propositional.

\section{Categorical characterisation of induction}

The induction principle of an inductive type $\Tty$ gives us a way to
construct dependent functions for families defined on $\Tty$. The
family $P$ which we are eliminating into is also called the
\emph{motive} of the inductive. By providing \emph{methods} for every
constructor for this motive, the induction principle gives us a
function $(x : \Tty) \to P\ x$. Recall that in the case of the natural
numbers, the methods we have to supply have the following types:
%
\begin{itemize}
\item $m_{\natzero} : P\ \natzero$,
\item $m_{\natsucc} : (n : \natty) \to P\ n \to P\ (\natsucc\ n)$,
\end{itemize}
%
Given all this, the induction principle yields a dependent function
$s : (x : \natty) \to P\ x$ satisfying certain computation rules.

We can think of the triple $(P,m_{\natzero},m_{\natsucc})$ as a family
of algebras defined over the algebra $(\natty, \natzero, \natsucc)$:

\begin{definition}
  We define a type of algebra families for this particular category of
  algebras as:
%
  \begin{alignat*}{2}
    &\Fam_{\Alg_{\lambda X . 1 + X}} : | \Alg_{\lambda X . 1 + X} | \to \Type \\
    &\Fam_{\Alg_{\lambda X . 1 + X}} (X , \theta_0, \theta_1) &\ddefeq& (P : X \to \Type) \\
    &&\times& (m_0 : P\ \theta_0) \\
    &&\times& (m_1 : (x : X) \to P\ x \to P\ (\theta_1\ x))
  \end{alignat*}
%
\end{definition}

In order to see that this type does correspond to a notion of family,
recall that families on a type can also be represented as functions
into said type:

\begin{proposition}
Given $X : \Type$, there is an equivalence:
$$
(X \to \Type) = (Y : \Type) \times (p : Y \to X)
$$
\end{proposition}

\begin{proof}
  Let $P : X \to \Type$ be a family on $X$, we can map this to the
  pair $((x : X) \times P\ x, \pi_0)$, \ie the family's total space
  along with its projection map into its base space. In the other
  direction we map $(Y,p)$ to the preimage family
  $\lambda x . (y : Y) \times (p\ y = x)$. Checking that these two
  maps are eachother's inverses can be done by using function
  extensionality and univalence.
\end{proof}

For the aforementioned algebra families, we have a similar
equivalence:

\begin{proposition}
Given $X : \Alg_{\lambda X . 1 + X}$, there is an equivalence:
$$
\Fam_{\Alg_{\lambda X . 1 + X}}\ X = (Y : | \Alg_{\lambda X . 1 +
  X} |) \times (p : \Alg_{\lambda X . 1 + X}(Y,X))
$$
\end{proposition}

\begin{proof}
  The proof follows the same structure as the $\Type$ case. Given an
  algebra family $(P,m_0,m_1)$, we can define its ``total algebra'' as
  follows:
  $$
  \total\ (P,m_0,m_1) \ddefeq ((x : X) \times P\ x , (\theta_0, m_0), (\lambda (x,p) . (\theta_1\ x, m_1\ x\ p)))
  $$
  The projection function $\pi_0 : (x : X) \times P\ x \to X$ turns
  out to be an algebra morphism
  $\total\ (P,m_0,m_1) \to (X,\theta_0,\theta_1)$: it satisfies the
  computation rules definitionally. Let us denote this morphism as
  $\proj\ (P,m_0,m_1)$. The mapping from left to right maps
  $(P,m_0,m_1)$ to the pair
  $(\total\ (P,m_0,m_1), \proj\ (P,m_0,m_1))$.

  For the other direction we need to generalise the preimage family to
  algebras: given $(Y,\rho_0,\rho_1)$ with
  $(p,p_0,p_1) : \Alg_{\lambda X . 1 +
    X}((Y,\rho_0,\rho_1),(X,\theta_0,\theta_1))$,
  we define the following family:
  %
  \begin{align*}
  &(\ \lambda x . (y : Y) \times p\ y = x &&: X \to \Type \\
  &,\ (\rho_0 , p_0) &&: (y : Y) \times p\ y = \theta_0 \\
  &,\ \lambda x (y,z) . (\rho_1\ y , w) &&: (x : X) \to (y : Y) \times (p\ y = x) \to (y' : Y) \times (p\ y' = \theta_1\ x)\\
  &)
  \end{align*}
  % 
  where $w$ is defined as the following path:
  $$
  \xymatrix{
    p\ (\rho_1\ y) \ar@{-}[r]^-{p_1} &\theta_1\ (p\ y) \ar@{-}^-{\ap\ \theta_1\ z}[r] &\theta_1\ x
  }
  $$
\end{proof}

Given a family $P : X \to \Type$, a dependent function
$(x : X) \to P\ x$ corresponds to a \emph{section} of the projection
function $\pi_0 : (x : X) \times P\ x \to X$. As it turns out, the
corresponding notion of dependent function for an algebra family is a
dependent function along with computation rules, \ie everything we get
from the induction principle:

\begin{definition}
  Given an algebra family $(P,m_0,m_1)$, a \emph{dependent algebra
    morphism} is a dependent function $s : (x : X) \to P\ x$ equipped
  with the computation rules:
  % 
  \begin{itemize}
  \item $s_{\natzero} : s\ \natzero = m_{\natzero}$
  \item $s_{\natsucc} : (n : \natty) \to s\ (\natsucc\ n) = m_{\natsucc}\ n\ (s\ n)$
  \end{itemize}
\end{definition}

As the definitions of function into $X$ and section only refer to the
category structure, this generalises to any category. The induction
principle that gives us a dependent morphism for any family can be
therefore be phrased abstractly as follows:

\begin{definition}
  The \emph{section principle} for an object $X$ in a category $\Cc$
  says that for every $Y : | \Cc |$ and $p : \Cc(Y,X)$, there exists
  $s : \Cc(X,Y)$ and a proof of $p \circ s = \id_X$, \ie that there is
  a term of type:
  \[
    (Y : | \Cc |) \times (p : \Cc(Y,X)) \to (s : \Cc(X,Y)) \times (p \circ s = \id_X)
  \]
\end{definition}

\section{Section principle is logically equivalent to initiality}

Now we have a category theoretic characterisation of the induction
principle, we have to show that it is logically equivalent to
initiality. Assuming a bit more structure of the categories we are
working with, namely that finite limits exist, we can show that an
object satisfies the section principle if and only if it is an initial
object.

\begin{lemma}
  \label{initiality-to-section}
  Let $\Cc: \Cat$. If $X : | \Cc |$ is initial, then $X$ satisfies the
  section principle.
\end{lemma}
\begin{proof}
  Assume $X$ is initial. Given a morphism $p : Y \to X$, we need to
  produce a morphism $s : X \to Y$ such that $p \circ s = id_X$.
  Since $X$ is initial, we get a unique arrow $s : X \to Y$ such that:
  $$
  \xymatrix{
    X \ar[r]^{\id_{X}} \ar[rd]_{s} &X \\
    &Y \ar[u]_{p}
  }
  $$
  The composite has to be equal to the identity morphism on $X$, as
  that by initiality is the only endomorphism on $X$.
\end{proof}

\begin{lemma}
  \label{section-to-initiality}
  Let $\Cc: \Cat$ and assume $\Cc$ has finite limits. If $X : | \Cc |$
  satisfies the section principle, then $X$ is initial.
\end{lemma}
\begin{proof}
  Given $Y : |\Cc|$, we need to provide a unique arrow $X \to
  Y$. Consider the projection $\pi_0 : X \times Y \to X$, which is an
  arrow into $X$ and therefore has a section $s : X \to X \times
  Y$. Our candidate arrow is then the composite:
  $$
  \xymatrix{
    X \ar[r]^{s} &X \times Y \ar[r]^{\pi_1} &Y
  }
  $$
  which we have to show is unique. Using equalisers, we can show that
  any two arrows $f,g$ out of $X$ to some other object $Y$ are equal:
  \[
    \xymatrix{
      E \ar[r]^{i} &X \ar@<-.5ex>[r]_-{f} \ar@<.5ex>[r]^-{g} &Y \\
      X \ar[u]^{s} \ar[ur]_{\id_{X}}
    }
  \]
  Let $E$ be the equaliser of $f$ and $g$, then we get a projection map
  $i : E \to X$. By the section principle, this map has a section
  $s : X \to E$, hence we have:
  \begin{align*}
    f &= \id_X \circ f \\
      &= (s \circ i) \circ f \\
      &= s \circ (i \circ f) \\
      &= s \circ (i \circ g) \\
      &= (s \circ i) \circ g \\
      &= \id_X \circ g \\
      &= g
  \end{align*}
\end{proof}

Stating that an object is initial only requires us to define the type
of objects and type of morphisms of the category. This makes it an
attractive notion to internalise and work with, as defining it will
not give us any coherence issues. The section principle however, needs
a bit more structure: we need composition and identity morphisms. In
order to show that initiality and the section principle coincide, we
need even more structure: we need the identity \emph{laws} and
associativity and the existence of certain limits.

\section{Limits in categories of algebras}

In this section we will show that the categories of algebras we are
working with have products and equalisers, and hence satisfy the
assumption of~\cref{section-to-initiality}. This is done by induction
on the specification of the inductive definition, \ie by induction on
its number of constructors. We will see that we also need that the
forgetful functors into the category of sorts preserve these limits,
which we can prove simultaneously with the construction of the limits.

For the empty specification, an inductive definition with no
constructors, the resulting category of algebras is the category of
sorts. We will show that this category has the required limits:

\begin{lemma}
\label{sorts-products}
  For each sort $\Ss : \sortsty$, the category $\SortCat{\Ss}$ has
  products.
\end{lemma}

\begin{proof}
  We proceed by induction on the specification of sorts
  $\Ss : \sortsty$.  If $\Ss = \sortsnil$, then $\SortCat{\Ss} = \termcat$,
  which trivially satisfies our criteria.

  In the induction step case, we have $\SortCat{\Ss} = S_i$ for a
  category $S_i$ which is built out of the previous category of sorts
  $S_{i-1} : \Cat$ with $R_i : S_{i-1} \to \Set$. By the induction
  hypothesis $S_{i-1}$ has products and equalisers. We can then define
  products in $S_{i}$ as follows: suppose $(X,P), (Y,Q) : | S_{i} |$,
  \ie $X, Y : | S_{i-1} |$ and $P : R_i X \to \Set$,
  $Q : R_i Y \to \Set$, since $S_{i-1}$ has products, we can define:
  \[
    (X,P) \times (Y,Q) \ddefeq (X \times Y , P \times Q)
  \]
  where $P \times Q : R_i (X \times Y) \to \Set$ is defined pointwise
  as:
  \[
    (P \times Q)\ x \ddefeq P (R_i\ \pi_0\ x) \times Q (R_i\ \pi_1\ x)
  \]
  This definition satisfies the universal property of products, which
  can be shown by appealing to the universal properties of products in
  $S_{i-1}$ and $\Set$: let $(Z,T) : | S_{i} |$, then we have:
  % 
  \begin{align*}
    &&&S_i((Z,T),(X \times Y, P \times Q)) \\
    &=& &\reasontext{definition of products in $S_i$} \\
    &&& (f : S_{i-1}(Z,X \times Y)) \\
    &&& \times (g : (x : R_i Z) \to T\ x \to (P \times Q)\ (R_i\ f\ x)) \\
    &=& &\reasontext{universal property of $X \times Y$ in $S_{i-1}$ and functoriality of $R_i$} \\
    &&& (f_0 : S_{i-1}(Z,X)) \times (f_1 : S_{i-1}(Z,Y)) \\
    &&& \times (g : (x : R_iZ) \to T\ x \to P\ (R_i\ f\ x) \times Q\ (R_i\ g\ x)) \\
    &=& &\reasontext{universal property of $P\ (R_i\ f\ x) \times Q\ (R_i\ g\ x)$ in $\Set$} \\
    &&& (f_0 : S_{i-1}(Z,X)) \times (f_1 : S_{i-1}(Z,Y)) \\
    &&& \times (g_0 : (x : R_iZ) \to T\ x \to P\ (R_i\ f\ x)) \\
    &&& \times (g_1 : (x : R_iZ) \to T\ x \to Q\ (R_i\ g\ x)) \\
    &=& &\reasontext{definition of products in $S_i$} \\
    &&& S_i((Z,T),(X,P)) \times S_i((Z,T),(Y,Q))
  \end{align*}
\end{proof}

Equalisers are constructed in similar way to products, however it
involves equalities between morphisms, which we can simplify using the
following proposition:

\begin{proposition}
  Suppose $(f,f'), (g,g') : S_i((X,Y),(Z,W))$, then:
  % 
  \begin{align*}
    ((f,f') = (g,g')) &=& &(p : f = g) \\
                      &\times& &(p' : (x : X) (y : Y\ x) \to \pathover{W}{R_i\ p\ x}{f'\ x\ y}{g'\ x\ y})
  \end{align*}
  % 
  where we denote the action of $R_i$ on a proof of equality
  $p : f = g$ by $R_i(p)\ x : R_i\ f\ x = R_i(g)\ x$. Since
  $f'\ x\ y : W\ (R_i\ f\ x)$ and $g'\ x\ y : W\ (R_i\ g\ x)$, we have
  to transport the left hand side of the equation along the equality
  $R_i\ p\ x$.
\end{proposition}

\begin{proof}
  This holds by function extensionality and using that an equality of
  pairs is equivalent a pair of equalities.
\end{proof}
\begin{lemma}
\label{sorts-equalisers}
  For each sort $\Ss : \sortsty$, the category $\SortCat{\Ss}$ has
  equalisers.
\end{lemma}

\begin{proof}
  As before, we proceed by induction on the specification of sorts
  $\Ss : \sortsty$.  If $\Ss = \sortsnil$, then $\SortCat{\Ss} = \termcat$,
  which trivially satisfies our criteria.



  Given $(f,f'), (g,g') : S_i((X,Y),(Z,W))$, by the induction
  hypothesis we get an equaliser $E : |S_{i-1}|$ with a projection map
  $e : S_{i-1}(E,X)$. This equaliser comes equipped with a proof
  $p : f \circ e = g \circ e$. The equaliser is then defined as
  $(E,F)$ with:
  \begin{align*}
    F\ x & \ddefeq (y : Y\ (R_i\ e\ x)) \\
         & \times (\pathover{W}{R_i\ p\ x}{f'\ (R_i\ e\ x)\ y}{g'\ (R_i\ e\ x)\ y})
  \end{align*}
  with $(e,e') : S_i((E,F),(X,Y))$ the projection morphism where
  \[
    e'\ x\ (y , p) \ddefeq y
  \]
  Showing that $(f,f') \circ (e,e') = (g,g') \circ (e,e')$ is then
  straightforward. The universal property can be shown similarly to
  that of the product: we have to appeal to the universal properties
  of equalisers in $S_{i-1}$ and $\Set$.
\end{proof}

Combining this we get:

\begin{theorem}
  \label{limits-sorts}
  For each sort $\Ss : \sortsty$, the category $\SortCat{\Ss}$ has
  finite limits.
\end{theorem}

When specifying a quotient inductive-inductive type with at least one
constructor, we also need the category of algebras to have finite
limits.

\begin{lemma}[Limits in the category of algebras]
  For each sort $\Ss : \sortsty$ and specification $s : \specty$, the
  category of algebras $\Alg_s$ has products. Furthermore, the
  forgetful functor $U_s : \Alg_s \to \SortCat{\Ss}$ preserves these products.
\end{lemma}
\begin{proof}
  We prove both properties simultaneously by induction on
  $s : \specty$.  For the empty quotient inductive-inductive type
  specification, the first statement is \cref{limits-sorts}, and the
  forgetful functor of the category of algebras into the category of
  sorts is the identity functor, which trivially preserves limits. By
  the way the limits here are constructed, the functor
  $t_i : S_i \to S_{i-1}$ also preserves them. This means that if we
  have a forgetful functor $U : \Alg_s \to \Ss$ for some
  $s : \specty$, then for any $S_i \in \Ss$, the extension
  $\bar{U} : \Alg_s \to S_i$ of $U$ also preserves products and
  equalisers.

  For the induction step case, we have a specification $s : \specty$
  such that $\Alg_s : \Cat$ has products and the forgetful functor
  $U : \Alg_s \to \Ss$ preserves them. To define a constructor on $s$,
  we need to specify its sort first. Suppose we have $S_i \in \Ss$,
  then either $S_i = 1$ or $S_i$ is built out of $S_{i-1}$ with some
  functor $R_i : S_{i-1} \to \Set$ and we have a forgetful functor
  $t_i : S_i \to S_{i-1}$. In the first case, we are done: adding
  constructors to an object in $1$ does not do anything. In the
  remainder we will assume the latter is the case.

  A 0-constructor of sort $S_i$ on a specification $s : \specty$ is
  given by a functor $F : \Alg_s \to S_i$ such that
  $t_i \circ F = t_i \circ \bar{U}$. The algebras we are interested in
  are dialgebras $(X : \Alg_s) \times (\theta : S_i(FX, \bar{U}X))$
  such that $t_i \theta = \id_{t_i (\bar{U}X)}$.

  Let $(X,\theta), (Y,\rho) : | \dialgcat{F}{\bar{U}} |$, then by the
  induction hypothesis we have that the projections map
  $\bar{U}(X \times Y) \to \bar{U}X \times \bar{U}Y$ has an inverse
  $\phi$. We can define the algebra structure on $X \times Y$ as
  follows:
  $$
  \xymatrix{ F(X \times Y) \ar[r] &
    FX \times FY \ar[ld]_{\theta \times \rho} \\
    \bar{U}X \times \bar{U}Y \ar[r]^{\phi} & \bar{U}(X \times Y) }
  $$

  If $t_i\ \theta = \id_{t_i (\bar{U}X)}$ and
  $t_i\ \rho = \id_{t_i (\bar{U}Y)}$, then the composite will also
  satisfy this property, hence we are done. By the construction of
  products, the forgetful functor out of the new category of algebras
  preserves products.
\end{proof}



Together with \cref{initiality-to-section} and
\cref{section-to-initiality}, this immediately gives the main theorem
of this section:

\begin{theorem}
\label{thm:main}
  For each sort $\Ss : \sortsty$ and specification $s : \specty$, let $X$
  be an object in the category of algebras $\Alg_s$. Then $X$ is
  initial if and only if $X$ satisfies the section principle. \qed
\end{theorem}

In particular, this means that when implementing or formalising
quotient inductive-inductive types, one can restrict attention to the
conceptually simpler notion of initial algebra.

\section{Deriving the induction principle}

If we unfold the section principle for our categories of algebras, we
will not end up with a very natural induction principle. One of the
key features of type theory is that we have special notation for
families. If we want to define a predicate on a type $X$, the most 
natural way to do it is usually to define a family $X \to \Set$, not
to define another type $Y$ with a function $Y \to X$. 

Since our categories of sorts and algebras are built out of types, we
can try and derive a notion of families in these categories. In
$\Set$, we have the equivalence, for any $X : \Set$:
$$
(X \to \Set) \simeq (Y : \Set) \times (p : Y \to X)
$$
where the function left to right is defined as
$\lambda P . ((x : X) \times P\ x , \pi_0)$, \ie we map the family to
its ``total space'' and its projection function. The inverse operation
is the preimage family: $(Y,p)$ is mapped to
$\lambda x . (y : Y) \times (p\ y = x)$. 

\subsection{Induction for $F$-algebras}
If we want to derive the notion of families of $F$-algebras for some
endofunctor $F : \Func{\Set}{\Set}$, then we proceed as follows: let
$(X,\theta) : | \algcat{F} |$, we want to solve the equivalence for
the type $\tau$:
%
\begin{align*}
&\ \ \ \ \ \ (P : X \to \Set) \times (m : \tau) \\
&\simeq ((Y,\rho) : | \algcat{F} |) \times ((p,p_0) : \algcat{F}((Y,\rho),(X,\theta)))  
\end{align*}
%
We set $Y$ to $(x : X) \times P\ x$ and $p$ to $\pi_0$. We then have
to simplify the type
$(\rho : F ((x : X) \times P\ x)) \times (p_0 : \pi_0\ \circ \rho =
\theta \circ F\ \pi_0)$, which leads us to:
$$
m : (x : F ((x : X) \times P\ x)) \to P\ (F\ \pi_0\ x)
$$
This can be simplified even further if we define the operation
$\Box_F : (X \to \Set) \to FX \to \Set$, \ie the action of $F$ on type
families, which has the defining equation
$F ((x : X) \times P\ x) \simeq (x : FX) \times \Box_F\ P\
x$. Rewriting the type of $m$ using this notation gives us:
$$
m : (x : FX) \times \Box_F\ P\ x \to P\ (\theta\ x)
$$
Intuitively the type $\Box_F\ P\ x$ is the induction hypothesis.

\subsection{General framework}

To derive notions of famlies and dependent morphism in the categories
of algebras, we will introduce some notation, making precise what we
have to generalise. We want to define a type of families over an
object that is equivalent to the type of morphisms into that same
object. We will call such a structure the \emph{family structure} on
that category. This definition on its own is not very useful: we can
always trivially satisfy the definition by letting the type of
families exactly be the type of morphisms into an object. However, our
categories are not completely arbitrary: they are always in some way
built out of objects and morphisms in $\Set$. We can therefore use the
notion of families in $\Set$ for those parts and see how the remaining
parts simplify.

\begin{definition}[Family structure on a category]
  The operations we need from a category $\Cc$ to talk about families
  are as follows:
%
  \begin{itemize}
  \item $\Fam_{\Cc} : | \Cc | \to \Type$
  \item $\total : (X : | \Cc |) \to \Fam_{\Cc}\ X \to | \Cc |$
  \item
    $\proj : (X : | \Cc |) (P : \Fam_{\Cc}\ X) \to \Cc(\total\ X\ P,
    X)$
  \item
    $\preimage : (X : | \Cc |)\ (Y : | \Cc |)\ (p : \Cc(Y,X)) \to
    \Fam_{\Cc}\ X$
  \end{itemize}
%
  The operations should also satisfy the following correctness
  conditions, for any $X : | \Cc |$:
%
  \begin{itemize}
  \item for any family $P : \Fam_{\Cc}\ X$,
  $$\preimage\ X\ (\total\ X\ P , \proj\ X\ P) = P$$
\item for any object $Y : | \Cc |$ with $p : \Cc(Y,X)$,
  %
  \begin{align*}
    &\ \ \ \ \ \ (\total\ X\ (\preimage\ X\ (Y,p)) , \proj\ X\ (\preimage\ X\ (Y,p))) \\
    &= (Y,p)
  \end{align*}
\end{itemize}
%
\end{definition}
To define these operations for the sort and algebra categories, we can
perform induction on the specification and apply the same techniques
as we did to derive the notion of families in $\algcat{F}$.

Given these operations, we can generalise the $\Box$ operator to any
functor $F : \Func{\Cc}{\Dd}$.

\begin{definition}[Functorial action on families]
  Given family structures $\Fam_{\Cc}$ and $\Fam_{\Dd}$, and
  $X : | \Cc |$ and $P : \Fam_{\Cc}\ X$,
  $\Box_F : (X : | \Cc |) \to \Fam_{\Cc} \to \Fam_{\Dd}$ is defined
  as:
  $$
  \Box_F\ X\ P \ddefeq \preimage_{\Dd}\ FX\ (F\ (\total_{\Cc}\ X\ P) ,
  F\ (\proj_{\Cc}\ X\ P))
  $$
\end{definition}

\begin{proposition}
  \label{box-thm}
  Given family structures $\Fam_{\Cc}$ and $\Fam_{\Dd}$, and
  $X : | \Cc |$ and $P : \Fam_{\Cc}\ X$, we have
  $$
  F (\total_{\Cc}\ X\ P) = \total_{\Dd}\ (F X) (\Box_F\ P)
  $$
\end{proposition}

\begin{proof}
  This follows directly from the correctness condition of the family
  structure on $\Dd$:
  \begin{align*}
    &&&F (\total_{\Cc}\ X\ P) \\
    &=& &\reasontext{correctness condition of $\Fam_{\Dd}$} \\
    &&&\total_{\Dd}\ (F X) (\preimage_{\Dd}\ (F X) (F (\total_{\Cc}\ X\ P), F (\proj_{\Cc}\ X\ P))) \\
    &=& &\reasontext{definition of $\Box_F$} \\
    &&&\total_{\Dd}\ (F X) (\Box_F\ P)
  \end{align*}
\end{proof}

\begin{corollary}
  Applying \cref{box-thm} to endofunctors on $\Set$, we get, given
  $F : \Func{\Set}{\Set}$, $X : \Set$, $P : X \to \Set$:
  $$
  F ((x : X) \times P x) = (x : FX) \times \Box_F\ P\ x
  $$
\end{corollary}

Having defined families, we can then go on to generalise the notion of
dependent functions. In $\Set$, given a family $P : X \to \Set$, a
dependent function $(x : X) \to P\ x$ corresponds to a function
$s : X \to (x : X) \times P\ x$ along with
$s_0 : \pi_0 \circ s = \id_X$. The function from left to right sends a
dependent function $s$ to its graph $\lambda x . (x , s\ x)$, which is
trivially a section. The other direction composes the section $s$ with
$\pi_1$, but we have to transport along the proof given by $s_0$ to
make it typecheck.

\begin{definition}
  The type of \emph{sections} in a category $\Cc$ is defined as:
  \begin{align*}
    &\Sect_{\Cc} : (X : | \Cc |) (Y : | \Cc |) (p : \Cc(Y,X)) \to \Set \\
    &\Sect_{\Cc}\ X\ Y\ p \ddefeq (s : \Cc(X,Y)) \times (s_0 : p \circ s = \id_X)
  \end{align*}
\end{definition}

A dependent morphism structure on a category with a family structure
is something that allows us to perform the same construction as in
$\Set$:

\begin{definition}[Dependent morphism structure]
  To generalise dependent morphisms to a category $\Cc$, we need a
  family
  $\DepHom_{\Cc} : (X : | \Cc |)\ (P : \Fam_{\Cc}\ X) \to \Type$ along
  with the following operations, given an object $X : | \Cc |$ and a
  family $P : \Fam_{\Cc}\ X$:
%
  \begin{itemize}
  \item
    $\grph : \DepHom\ X\ P \to \Sect\ X\ (\total\ X\ P,\proj\ X\ P)$
  \item
    $\snd : \Sect\ X\ (\total\ X\ P,\proj\ X\ P) \to \DepHom_{\Cc}\ X\
    P$
  \end{itemize}
%
  The correctness conditions are:
%
  \begin{itemize}
  \item for any $f : \DepHom_{\Cc}\ X\ P$,
  $$\snd\ X\ P\ s\ (\grph\ X\ P\ f) = f$$
\item for any $s : \Sect\ X\ (\total\ X\ P, \proj\ X\ P)$,
  $$\grph\ X\ P\ (\snd\ X\ P\ s) = s$$
\end{itemize}
%
\end{definition}

Note that the correctness conditions give us an equivalence
$$
\DepHom_{\Cc}\ X\ P = \Sect_{\Cc}\ (\total_{\Cc}\ X\ P)\ X\ (\proj_{\Cc}\ X\ P)
$$

\subsection{Induction for quotient inductive-inductive definitions}

The family structure on $\Set$ is the usual one. We can derive
definitions of the family structure on categories of algebras by
induction. Since they are defined ``on top of'' $\Set$, we can use the
specification and the family structure on $\Set$ to derive appropriate
definitions.

\subsubsection{Family and dependent morphism structure on $\Fam$}

Before we move on to sort categories and categories of algebras, let
us first consider the families and dependent morphisms in the category
$\Fam$. Recall that $\Fam$ is the sort category for the
inductive-inductive type $(\ttconty,\tttyty)$ of contexts and types in
a context. We will use the intuition of the induction principle of
that inductive-inductive definition to make sense of what is going on
here.

Our first goal is to derive a family $\Fam_{\Fam} : | \Fam | \to \Set$
that satisfies, for any $X : | \Fam |$:
$$
\Fam_{\Fam} = (Y : | \Fam |) \times \Fam(Y,X)
$$
We derive the definition by taking the right hand side of the above
equation and performing the following equational reasoning:
\begin{align*}
  &&&(Y : | \Fam |) \times \Fam(Y,X) \\
  &=& &\reasontext{definition of objects and morphisms in $\Fam$} \\
  &&&(Y : \Set) \times (Q : Y \to \Set) \times (p : Y \to X) \\
  &&&\times (q : (y : Y) \to Q\ y \to P\ (p\ y)) \\
  &=& &\reasontext{combining $Y$ and $P$ using the family structure on $\Set$} \\
  &&&(V : X \to \Set) \times (Q : (x : X) \times V\ x \to \Set) \\
  &&&\times (q : (y : (x : X) \times V\ x) \to Q\ y \to P\ (\pi_1\ y)) \\
  &=& &\reasontext{currying} \\
  &&&(V : X \to \Set) \times (Q : (x : X) \to V\ x \to \Set) \\
  &&&\times (q : (x : X) \to (y : V\ x) \to Q\ x\ y \to P\ x) \\
  &=& &\reasontext{combining $Q$ and $q$ using family structure on $\Set$} \\
  &&&(V : X \to \Set) \times (W : (x : X) \to V\ x \to P\ x \to \Set)
\end{align*}
What we ended up with does match with what a motive for $(\ttconty,\tttyty)$
is, namely:
$$
(P : \ttconty \to \Set) \times (Q : (\Gamma : \ttconty) \to P\ \Gamma \to \tttyty\ \Gamma \to \Set)
$$
A motive consists of a motive on $\ttconty$, which is just a family
on it, along with a family on $\tttyty$, for every
$\Gamma : \ttconty$. Since we may also refer to results we get from
doing induction on $\Gamma$, we also have a $P\ \Gamma$ in there.

We then give the following definitions:
%
\begin{align*}
  \Fam_{\Fam}\ (X , P) &\ddefeq (V : X \to \Set) \times (W : (x : X) \to V\ x \to P\ x \to \Set) \\
  \total_{\Fam}\ (X , P)\ (V , W) &\ddefeq ((x : X) \times P x , \lambda (x,y) . (z : V\ x) \times W\ x\ z\ y) \\
  \proj_{\Fam}\ (X, P)\ (V, W) &\ddefeq (\lambda (x , y) . x , \lambda (x , y) (z , w) . y) \\
  \preimage_{\Fam}\ (X, P)\ ((Y,Q),(p, q)) &\ddefeq (\lambda x . (y : Y) \times p\ y = x , \lambda x\ y\ z . ?)
\end{align*}
%
Now we have a family structure on $\Fam$, we need to define what
dependent morphisms of these families are. Returning to the
$(\ttconty,\tttyty)$ example, given a motive $P : \ttconty \to \Set$,
$Q : (\Gamma : \ttconty) \to P\ \ttconty \to \tttyty\ \Gamma \to \Set$
and the appropriate methods, the induction principle gives us two
functions:
%
\begin{align*}
  &\ttconind : (\Gamma : \ttconty) \to P\ \Gamma \\
  &\tttyind : (\Gamma : \ttconty) (\tau : \tttyty\ \Gamma) \to Q\ \Gamma\ (\ttconind\ \Gamma)\ \tau
\end{align*}
%
The function $\tttyind$ refers to $\ttconind$ in its type as well: the
results we get from $\ttconind$ may be used in the motive of
$\tttyty$.

\subsubsection{Sort categories}

The family structure on a sort category can be given by induction on
the specification. In the case of an empty specification, we define
$\Fam_{\termcat}\ X \ddefeq \unitty$ for any $X : | \termcat |$. The
other definitions are equally trivial.

In the induction step case, we get a family structure on $S_{i-1}$ and
have to provide one on the category $S_i$ which is built out of
$S_{i-1}$ with the functor $R_i : \Func{S_{i-1}}{\Set}$. Our goal is
to find, given $X : | S_{i-1} |$ and $P : R_i X \to \Set$, a set
$\Fam_{S_i} (X, P)$ such that:
$$
\Fam_{S_i} (X, P) = ((Y , Q) : | S_i |) \times (p : S_i((Y,Q),(X,P)))
$$
We can perform the following equational reasoning on the right hand
side of the equation above:
\begin{align*}
  &&&(Y : | S_i |) \times (p : S_i(Y,(X,P))) \\
  &=& &\reasontext{definition of $S_i$} \\
  &&&(Y : | S_{i-1} |) \times (Q : R_i Y \to \Set) \times (p : S_{i-1}(Y,X)) \times (q : (x : R_i Y) \to Q\ x \to P\ (R_i\ p\ x)) \\
  &=& &\reasontext{combining $Y$ and $p$ using family structure on $S_{i-1}$} \\
  &&&(V : \Fam_{S_{i-1}}\ X) \times (Q : R_i (\total_{S_{i-1}}\ X\ V) \to \Set) \\
  &&&\times (q : (x : R_i (\total_{S_{i-1}}\ X\ V)) \to Q\ x \to P\ (R_i (\proj_{S_{i-1}}\ X\ V)\ x)) \\
  &=& &\reasontext{rewrite $R_i (\total_{S_{i-1}}\ X\ V)$ with $\Box_{R_i}$} \\
  &&&(V : \Fam_{S_{i-1}}\ X) \times (Q : (x : R_i X) \times \Box_{R_i}\ X\ V\ x \to \Set) \\
  &&&\times (q : (x : R_i X) \times (y : \Box_{R_i}\ X\ V\ x) \to Q\ (x , y) \to P\ x)) \\
  &=& &\reasontext{combining $Q$ and $q$ using family structure on $\Set$} \\
  &&&(V : \Fam_{S_{i-1}} X) \times (W : (x : R_i X) \to \Box_{R_i}\ X\ V\ x \to P\ x \to \Set)
\end{align*}



\subsubsection{0-constructors}

\subsubsection{1-constructors}
