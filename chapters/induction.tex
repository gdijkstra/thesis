\chapter{Induction versus initiality}
\label{induction}

In the previous chapter we have seen how we can specify a quotient
inductive-inductive definition by giving a list of sorts and a list of
constructors: we have to give the type formation and introduction
rules. From these rules, we can then derive the category of
algebras. The notion of algebra morphism looks a lot like the
recursion principle for the inductive definition. In fact, saying that
an algebra is \emph{weakly initial} is precisely the statement that
the algebra satisfies the recursion principle. The link between full
initiality and the induction principle is a bit more
involved. Initiality talks about the morphism we get from the
recursion principle being \emph{unique}: its statement involves
equality of morphisms. The induction principle is something that
allows us to produce dependent functions into families over our
inductive definitions.

Initial algebra semantics is a very attractive way of ``explaining''
inductive definitions: stating the property of being initial only
requires us to have defined the objects and morphisms:

\begin{definition}[Initiality]
  An object $X$ of a category $\Cc$ is \emph{initial} if for every
  $Y : | \Cc |$ the set $\Cc(X,Y)$ is contractible.
\end{definition}

From this definition it also immediate that being initial is
propositional.

\section{Categorical characterisation of induction}

The induction principle of an inductive type $\Tty$ gives us a way to
construct dependent functions for families defined on $\Tty$. The
family $P$ which we are eliminating into is also called the
\emph{motive} of the inductive. By providing \emph{methods} for every
constructor for this motive, the induction principle gives us a
function $(x : \Tty) \to P\ x$. Recall that in the case of the natural
numbers, the methods we have to supply have the following types:
%
\begin{itemize}
\item $m_{\natzero} : P\ \natzero$,
\item $m_{\natsucc} : (n : \natty) \to P\ n \to P\ (\natsucc\ n)$,
\end{itemize}
%
Given all this, the induction principle yields a dependent function
$s : (x : \natty) \to P\ x$ satisfying certain computation rules.

We can think of the triple $(P,m_{\natzero},m_{\natsucc})$ as a family
of algebras defined over the algebra $(\natty, \natzero, \natsucc)$:

\begin{definition}
  We define a type of algebra families for this particular category of
  algebras as:
%
  \begin{alignat*}{2}
    &\Fam_{\Alg_{\lambda X . 1 + X}} : | \Alg_{\lambda X . 1 + X} | \to \Type \\
    &\Fam_{\Alg_{\lambda X . 1 + X}} (X , \theta_0, \theta_1) &\ddefeq& (P : X \to \Type) \\
    &&\times& (m_0 : P\ \theta_0) \\
    &&\times& (m_1 : (x : X) \to P\ x \to P\ (\theta_1\ x))
  \end{alignat*}
%
\end{definition}

In order to see that this type does correspond to a notion of family,
recall that families on a type can also be represented as functions
into said type:

\begin{proposition}
Given $X : \Type$, there is an equivalence:
$$
(X \to \Type) = (Y : \Type) \times (p : Y \to X)
$$
\end{proposition}

\begin{proof}
  Let $P : X \to \Type$ be a family on $X$, we can map this to the
  pair $((x : X) \times P\ x, \pi_0)$, \ie the family's total space
  along with its projection map into its base space. In the other
  direction we map $(Y,p)$ to the preimage family
  $\lambda x . (y : Y) \times (p\ y = x)$. Checking that these two
  maps are eachother's inverses can be done by using function
  extensionality and univalence.
\end{proof}

For the aforementioned algebra families, we have a similar
equivalence:

\begin{proposition}
Given $X : \Alg_{\lambda X . 1 + X}$, there is an equivalence:
$$
\Fam_{\Alg_{\lambda X . 1 + X}}\ X = (Y : | \Alg_{\lambda X . 1 +
  X} |) \times (p : \Alg_{\lambda X . 1 + X}(Y,X))
$$
\end{proposition}

\begin{proof}
  The proof follows the same structure as the $\Type$ case. Given an
  algebra family $(P,m_0,m_1)$, we can define its ``total algebra'' as
  follows:
  $$
  \total\ (P,m_0,m_1) \ddefeq ((x : X) \times P\ x , (\theta_0, m_0), (\lambda (x,p) . (\theta_1\ x, m_1\ x\ p)))
  $$
  The projection function $\pi_0 : (x : X) \times P\ x \to X$ turns
  out to be an algebra morphism
  $\total\ (P,m_0,m_1) \to (X,\theta_0,\theta_1)$: it satisfies the
  computation rules definitionally. Let us denote this morphism as
  $\proj\ (P,m_0,m_1)$. The mapping from left to right maps
  $(P,m_0,m_1)$ to the pair
  $(\total\ (P,m_0,m_1), \proj\ (P,m_0,m_1))$.

  For the other direction we need to generalise the preimage family to
  algebras: given $(Y,\rho_0,\rho_1)$ with
  $(p,p_0,p_1) : \Alg_{\lambda X . 1 +
    X}((Y,\rho_0,\rho_1),(X,\theta_0,\theta_1))$,
  we define the following family:
  %
  \begin{align*}
  &(\ \lambda x . (y : Y) \times p\ y = x &&: X \to \Type \\
  &,\ (\rho_0 , p_0) &&: (y : Y) \times p\ y = \theta_0 \\
  &,\ \lambda x (y,z) . (\rho_1\ y , w) &&: (x : X) \to (y : Y) \times (p\ y = x) \to (y' : Y) \times (p\ y' = \theta_1\ x)\\
  &)
  \end{align*}
  % 
  where $w$ is defined as the following path:
  $$
  \xymatrix{
    p\ (\rho_1\ y) \ar@{-}[r]^-{p_1} &\theta_1\ (p\ y) \ar@{-}^-{\ap\ \theta_1\ z}[r] &\theta_1\ x
  }
  $$
\end{proof}

Given a family $P : X \to \Type$, a dependent function
$(x : X) \to P\ x$ corresponds to a \emph{section} of the projection
function $\pi_0 : (x : X) \times P\ x \to X$. As it turns out, the
corresponding notion of dependent function for an algebra family is a
dependent function along with computation rules, \ie everything we get
from the induction principle:

\begin{definition}
  Given an algebra family $(P,m_0,m_1)$, a \emph{dependent algebra
    morphism} is a dependent function $s : (x : X) \to P\ x$ equipped
  with the computation rules:
  % 
  \begin{itemize}
  \item $s_{\natzero} : s\ \natzero = m_{\natzero}$
  \item $s_{\natsucc} : (n : \natty) \to s\ (\natsucc\ n) = m_{\natsucc}\ n\ (s\ n)$
  \end{itemize}
\end{definition}

As the definitions of function into $X$ and section only refer to the
category structure, this generalises to any category. The induction
principle that gives us a dependent morphism for any family can be
therefore be phrased abstractly as follows:

\begin{definition}
  The \emph{section principle} for an object $X$ in a category $\Cc$
  says that for every $Y : | \Cc |$ and $p : \Cc(Y,X)$, there exists
  $s : \Cc(X,Y)$ and a proof of $p \circ s = \id_X$, \ie that there is
  a term of type:
  \[
    (Y : | \Cc |) \times (p : \Cc(Y,X)) \to (s : \Cc(X,Y)) \times (p \circ s = \id_X)
  \]
\end{definition}

\section{Section principle is logically equivalent to initiality}

Now we have a category theoretic characterisation of the induction
principle, we have to show that it is logically equivalent to
initiality. Assuming a bit more structure of the categories we are
working with, namely that finite limits exist, we can show that an
object satisfies the section principle if and only if it is an initial
object.

\begin{lemma}
  \label{initiality-to-section}
  Let $\Cc: \Cat$. If $X : | \Cc |$ is initial, then $X$ satisfies the
  section principle.
\end{lemma}
\begin{proof}
  Assume $X$ is initial. Given a morphism $p : Y \to X$, we need to
  produce a morphism $s : X \to Y$ such that $p \circ s = id_X$.
  Since $X$ is initial, we get a unique arrow $s : X \to Y$ such that:
  $$
  \xymatrix{
    X \ar[r]^{\id_{X}} \ar[rd]_{s} &X \\
    &Y \ar[u]_{p}
  }
  $$
  The composite has to be equal to the identity morphism on $X$, as
  that by initiality is the only endomorphism on $X$.
\end{proof}

\begin{lemma}
  \label{section-to-initiality}
  Let $\Cc: \Cat$ and assume $\Cc$ has finite limits. If $X : | \Cc |$
  satisfies the section principle, then $X$ is initial.
\end{lemma}
\begin{proof}
  Given $Y : |\Cc|$, we need to provide a unique arrow $X \to
  Y$. Consider the projection $\pi_0 : X \times Y \to X$, which is an
  arrow into $X$ and therefore has a section $s : X \to X \times
  Y$. Our candidate arrow is then the composite:
  $$
  \xymatrix{
    X \ar[r]^{s} &X \times Y \ar[r]^{\pi_1} &Y
  }
  $$
  which we have to show is unique. Using equalisers, we can show that
  any two arrows $f,g$ out of $X$ to some other object $Y$ are equal:
  \[
    \xymatrix{
      E \ar[r]^{i} &X \ar@<-.5ex>[r]_-{f} \ar@<.5ex>[r]^-{g} &Y \\
      X \ar[u]^{s} \ar[ur]_{\id_{X}}
    }
  \]
  Let $E$ be the equaliser of $f$ and $g$, then we get a projection map
  $i : E \to X$. By the section principle, this map has a section
  $s : X \to E$, hence we have:
  \begin{align*}
    f &= \id_X \circ f \\
      &= (s \circ i) \circ f \\
      &= s \circ (i \circ f) \\
      &= s \circ (i \circ g) \\
      &= (s \circ i) \circ g \\
      &= \id_X \circ g \\
      &= g
  \end{align*}
\end{proof}

Stating that an object is initial only requires us to define the type
of objects and type of morphisms of the category. This makes it an
attractive notion to internalise and work with, as defining it will
not give us any coherence issues. The section principle however, needs
a bit more structure: we need composition and identity morphisms. In
order to show that initiality and the section principle coincide, we
need even more structure: we need the identity \emph{laws} and
associativity and the existence of certain limits.

The proof of initiality shown here is intuitively very similar to what
one would do if one had the concrete induction principle: we first
have to define a ``constant algebra family'' for the given algebra. In
the categorical setting this corresponds to forming the product and
considering the projection morphism. From this we get an algebra
morphism. Showing that this algebra morphism is unique can then be
done by again appealing to the induction principle. The motive of this
induction is then stating that the two morphisms are pointwise
equal. Giving the methods for this motive, \ie giving the algebra
family, corresponds to forming the equaliser.

\section{Limits in categories of algebras}
\label{limits-in-categories-of-algebras}

In this section we will show that the categories of algebras we are
working with have products and equalisers, and hence satisfy the
assumption of~\cref{section-to-initiality}. This is done by induction
on the specification of the inductive definition, \ie by induction on
its number of constructors. We will see that we also need that the
forgetful functors into the category of sorts preserve these limits,
which we can prove simultaneously with the construction of the limits.

\subsection{Sort categories}

For the empty specification, an inductive definition with no
constructors, the resulting category of algebras is the category of
sorts. We will show that this category has the required limits:

\begin{lemma}
  \label{sorts-products}
  For each sort $\Ss : \sortsty$, the category $\SortCat{\Ss}$ has
  binary products.
\end{lemma}

\begin{proof}
  We proceed by induction on the specification of sorts
  $\Ss : \sortsty$.  If $\Ss = \sortsnil$, then $\SortCat{\Ss} = \termcat$,
  which trivially satisfies our criteria.

  In the induction step case, we have $\SortCat{\Ss} = S_i$ for a
  category $S_i$ which is built out of the previous category of sorts
  $S_{i-1} : \Cat$ with $R_i : S_{i-1} \to \Set$. By the induction
  hypothesis $S_{i-1}$ has products and equalisers. We can then define
  products in $S_{i}$ as follows: suppose $(X,P), (Y,Q) : | S_{i} |$,
  \ie $X, Y : | S_{i-1} |$ and $P : R_i X \to \Set$,
  $Q : R_i Y \to \Set$, since $S_{i-1}$ has products, we can define:
  \[
    (X,P) \times (Y,Q) \ddefeq (X \times Y , P \times Q)
  \]
  where $P \times Q : R_i (X \times Y) \to \Set$ is defined pointwise
  as:
  \[
    (P \times Q)\ x \ddefeq P (R_i\ \pi_0\ x) \times Q (R_i\ \pi_1\ x)
  \]
  This definition satisfies the universal property of products, which
  can be shown by appealing to the universal properties of products in
  $S_{i-1}$ and $\Set$: let $(Z,T) : | S_{i} |$, then we have:
  % 
  \begin{align*}
    &&&S_i((Z,T),(X \times Y, P \times Q)) \\
    &=& &\reasontext{definition of products in $S_i$} \\
    &&& (f : S_{i-1}(Z,X \times Y)) \\
    &&& \times (g : (x : R_i Z) \to T\ x \to (P \times Q)\ (R_i\ f\ x)) \\
    &=& &\reasontext{universal property of $X \times Y$ in $S_{i-1}$ and functoriality of $R_i$} \\
    &&& (f_0 : S_{i-1}(Z,X)) \times (f_1 : S_{i-1}(Z,Y)) \\
    &&& \times (g : (x : R_iZ) \to T\ x \to P\ (R_i\ f\ x) \times Q\ (R_i\ g\ x)) \\
    &=& &\reasontext{universal property of $P\ (R_i\ f\ x) \times Q\ (R_i\ g\ x)$ in $\Set$} \\
    &&& (f_0 : S_{i-1}(Z,X)) \times (f_1 : S_{i-1}(Z,Y)) \\
    &&& \times (g_0 : (x : R_iZ) \to T\ x \to P\ (R_i\ f\ x)) \\
    &&& \times (g_1 : (x : R_iZ) \to T\ x \to Q\ (R_i\ g\ x)) \\
    &=& &\reasontext{definition of products in $S_i$} \\
    &&& S_i((Z,T),(X,P)) \times S_i((Z,T),(Y,Q))
  \end{align*}
\end{proof}

Equalisers are constructed in similar way to products, however it
involves equalities between morphisms, which we can simplify using the
following proposition:

\begin{proposition}
  Suppose $(f,f'), (g,g') : S_i((X,Y),(Z,W))$, then:
  % 
  \begin{align*}
    ((f,f') = (g,g')) &=& &(p : f = g) \\
                      &\times& &(p' : (x : X) (y : Y\ x) \to \pathover{W}{R_i\ p\ x}{f'\ x\ y}{g'\ x\ y})
  \end{align*}
  % 
  where we denote the action of $R_i$ on a proof of equality
  $p : f = g$ by $R_i(p)\ x : R_i\ f\ x = R_i(g)\ x$. Since
  $f'\ x\ y : W\ (R_i\ f\ x)$ and $g'\ x\ y : W\ (R_i\ g\ x)$, we have
  to transport the left hand side of the equation along the equality
  $R_i\ p\ x$.
\end{proposition}

\begin{proof}
  This holds by function extensionality and using that an equality of
  pairs is equivalent a pair of equalities.
\end{proof}
\begin{lemma}
\label{sorts-equalisers}
  For each sort $\Ss : \sortsty$, the category $\SortCat{\Ss}$ has
  equalisers.
\end{lemma}

\begin{proof}
  As before, we proceed by induction on the specification of sorts
  $\Ss : \sortsty$.  If $\Ss = \sortsnil$, then $\SortCat{\Ss} = \termcat$,
  which trivially satisfies our criteria.



  Given $(f,f'), (g,g') : S_i((X,Y),(Z,W))$, by the induction
  hypothesis we get an equaliser $E : |S_{i-1}|$ with a projection map
  $e : S_{i-1}(E,X)$. This equaliser comes equipped with a proof
  $p : f \circ e = g \circ e$. The equaliser is then defined as
  $(E,F)$ with:
  \begin{align*}
    F\ x & \ddefeq (y : Y\ (R_i\ e\ x)) \\
         & \times (\pathover{W}{R_i\ p\ x}{f'\ (R_i\ e\ x)\ y}{g'\ (R_i\ e\ x)\ y})
  \end{align*}
  with $(e,e') : S_i((E,F),(X,Y))$ the projection morphism where
  \[
    e'\ x\ (y , p) \ddefeq y
  \]
  Showing that $(f,f') \circ (e,e') = (g,g') \circ (e,e')$ is then
  straightforward. The universal property can be shown similarly to
  that of the product: we have to appeal to the universal properties
  of equalisers in $S_{i-1}$ and $\Set$.
\end{proof}

\begin{remark}
  \label{forgetful-into-sorts}
  Let $\termcat \from S_0 \from S_1 \from \hdots \from S_n$ be a chain
  of sort categories. All the forgetful functors
  $t_i : S_i \to S_{i-1}$ (with $S_{-1} \ddefeq \termcat$) preserve
  products and equalisers. This follows directly from the definition
  of the limits.
\end{remark}

\subsection{Categories of algebras}
For the categories of algebras, we will perform induction on the
number of constructors. We also need to simultaneously show that the
forgetful functors into the category of sorts preserve the limits.

The assumptions for the following lemmata are:
\begin{itemize}
\item $\Ss : \sortsty$ is the definition of the sorts
\item $s : \specty_\Ss$ is the specification of the previous constructors, hence
\item $\Alg_s$ will have products and equalisers
\item $U_s : \Func{\Alg_s}{\SortCat{\Ss}}$ preserves these
\item $\sortsin{S_i}{\Ss}$ is the sort of the constructor we are adding
\end{itemize}

The forgetful functor $U_s$ extends to
$\bar{U_s} : \Func{\Alg_s}{S_i}$ since $S_i \in \Ss$. By
\cref{forgetful-into-sorts} $\bar{U_s}$ also preserves products and
equalisers.

Note that $S_i \neq \unitty$.

\subsubsection{Products}

\begin{lemma}[Products of point constructors]
  Let $s' : \specty_\Ss$ be $s$ extended with a point constructor of sort
  $S_i$ as specified by:
  \begin{itemize}
  \item $F : \Func{\Alg_s}{S_i}$, satisfying:
  \item $t_i \circ F = t_i \circ \bar{U_s}$
  \end{itemize}

  If $\Alg_s$ has products and $U_s$ preserves them, then the category
  $\Alg_{s'}$ has products and its forgetful functor $U_{s'}$
  preserves them.
\end{lemma}

\begin{proof}
  Suppose we have two algebras in $\Alg_{s'}$, \ie we have:
  \begin{itemize}
  \item $X, Y : | \Alg_s |$
  \item $\theta : S_i(FX,\bar{U_s}X)$, $\rho : S_i(FY,\bar{U_s}Y)$
  \item $t_i \theta = \id_{t_i (\bar{U_s} X)}$, $t_i \rho = \id_{t_i (\bar{U_s} Y)}$
  \end{itemize}

  We will proceed by showing that $X \times Y : \Alg_s$ has an algebra
  structure. Let us define for $X, Y$ the morphism
  $\phi_U : S_i(U(X \times Y), UX \times UY)$ as
  $\phi_u \ddefeq \langle U \pi_0 , U \pi_1 \rangle$. Per assumption
  $\phi_U$ has an inverse $\phi_U^{-1}$. We can then define the
  algebra structure $\zeta$ on $X \times Y$ as follows:
  $$
  \xymatrix{ 
    F(X \times Y) \ar[r]^{\phi_F}
    &FX \times FY \ar[r]^{\theta \times \rho} 
    &\bar{U}X \times \bar{U}Y \ar[r]^{\phi_U^{-1}} 
    &\bar{U}(X \times Y) 
  }
  $$
  where $\phi_F \ddefeq \langle F \pi_0 , F \pi_1 \rangle$.
  
  For this to be an algebra structure, we need to establish that
  $t_i \zeta = \id_{t_i (\bar{U_s} (X \times Y))}$. This holds as
  $t_i$ preserves products definitionally. We have:
  \begin{align*}
    &t_i (\theta \times \rho) = t_i \langle \theta \circ \pi_0 , \rho \circ \pi_1 \rangle \\
    &=  \langle t_i (\theta \circ \pi_0) , t_i (\rho \circ \pi_1) \rangle \\
    &= \langle \pi_0 , \pi_1 \rangle \\
    &= \id_{t_I (\bar{U_s} (X \times Y))}
  \end{align*}
  and
  \begin{align*}
    &t_i \phi_F = t_i \langle F \pi_0 , F \pi_1 \rangle \\
    &= \langle t_i F \pi_0 , t_i F \pi_1 \rangle \\
    &= \langle t_i U \pi_0 , t_i U \pi_1 \rangle \\
    &= t_i \phi_U
  \end{align*}
  Putting it all together, we get:
  \begin{align*}
    &t_i \zeta = t_i (\phi_u^{-1} \circ \theta \times \rho \circ \phi_F) \\
    &= t_i \phi_u^{-1} \circ t_i (\theta \times \rho) \circ t_i \phi_F \\
    &= t_i \phi_U^{-1} \circ \id_{t_i (\bar{U_s} (X \times Y))} \circ t_i \phi_U \\
    &= \id_{t_i (\bar{U_s} (X \times Y))}
  \end{align*}

  We furthermore have to check whether $\pi_0 : S_i (X \times Y, X)$
  and $\pi_1 : S_i (X \times Y, Y)$ are algebra morphisms. To this
  end, let us consider the following diagram:
  $$
  \xymatrix{
    F(X \times Y) \ar[r]^{\phi_F} \ar[d]_{F \pi_0}
    &FX \times FY \ar[r]^{\theta \times \rho} \ar[dl]_{\pi_0}
    &\bar{U}X \times \bar{U}Y \ar[r]^{\phi_U^{-1}} \ar[dr]_{\pi_0}
    &\bar{U}(X \times Y) \ar[d]_{U \pi_0}
    \\
    FX \ar[rrr]_{\theta} &&&UX
  }
  $$
  The triangle on the left holds by definition of $\phi_F$. The square
  (trapezoid) in the middle holds by definition of
  $\theta \times \rho$. The triangle on the right can be established
  as follows: we have:
  \begin{align*}
    &\pi_0 \circ \phi_U \\
    &= U \pi_0 \\
    &= U \pi_0 \circ \phi_U^{-1} \circ \phi_U
  \end{align*}
  Since $\phi_U$ is an isomorphism it is in particular a monomorphism,
  hence from this equation we get that
  $\pi_0 = U \pi_0 \circ \phi_U{^-1}$. This shows that $\pi_0$ is an
  algebra morphism $\zeta \to \theta$. The proof that $\pi_1$ is an
  algebra morphism $\zeta \to \rho$ goes along the same lines.

  Finally we have to show that the universal property is
  satisfied. Suppose we have an algebra $(A,\alpha) : | \Alg_{s'} |$
  with $f : \Alg_s(A,X)$ and $g : \Alg_s(A,Y)$ both algebra
  morphisms. We get a unique arrow
  $\langle f , g \rangle : \Alg_s(A , X \times Y)$. We then have to
  ascertain that this is an algebra morphism $\alpha \to \zeta$, \ie
  we have to show that the following commutes:
  $$
  \xymatrix{
    FA \ar[rrr]_{\alpha} \ar[d]^{F \langle f , g \rangle} \ar[dr]_{\langle Ff , Fg \rangle}
    &&&UA \ar[d]^{U \langle f , g \rangle}
    \ar[dl]_{\langle Uf , Ug \rangle}
    \\
    F(X \times Y) \ar[r]^{\phi_F} 
    &FX \times FY \ar[r]^{\theta \times \rho}
    &\bar{U}X \times \bar{U}Y \ar[r]^{\phi_U^{-1}}
    &\bar{U}(X \times Y) 
  }
  $$
  The left triangle holds by definition. The middle trapezoid holds as
  $f$ and $g$ are algebra morphisms $\alpha \to \theta$ and
  $\alpha \to \rho$ respectively. The right triangle can be shown to
  hold by the following equational reasoning:
  \begin{align*}
    &\phi_U \circ U \langle f , g \rangle = \langle U f , U g \rangle \\
    &= \phi_U \circ \phi_U^{-1} \circ \langle U f , U g \rangle
  \end{align*}
  Since $\phi_U$ is an isomorphism, it is also an epimorphism, which
  means we get
  $U \langle f , g \rangle = \phi_U^{-1} \circ \langle U f , U g
  \rangle$.

  Note that by construction, $\bar{U}_{s'}$ preserves products
  definitionally.
\end{proof}

\begin{lemma}[Products of path constructors]
  Let $s' : \specty_\Ss$ be $s$ extended with a point constructor of sort
  $S_i$ as specified by:
  \begin{itemize}
  \item $F : \Func{\Alg_s}{S_i}$, satisfying $t_i \circ F = t_i \circ \bar{U_s}$
  \item $l, r : \Nat{F}{\bar{U}_s}$ satisfying
    $t_i\ l = t_i\ r = \id_{t_i \circ \bar{U}_s}$.
  \end{itemize}

  If $\Alg_s$ has products and $U_s$ preserves them, then the category
  $\Alg_{s'}$ has products and its forgetful functor $U_{s'}$
  preserves them.
\end{lemma}

\begin{proof}
  Suppose we have objects $X, Y : | \Alg_s |$ with algebra structures
  $\theta : l_X = r_X$ and $\rho : l_Y = r_Y$. We will proceed by
  constructing an algebra on the object $X \times Y$.

  Note that by naturality of $l$, the following commutes:
  $$
  \xymatrix{
    F(X \times Y) \ar[r]^{\phi_F} \ar[d]_{l_{X \times Y}} &FX \times FY \ar[d]^{l_X \times l_Y} \\
    U(X \times Y) \ar[r]_{\phi_U} &UX \times UY
  }
  $$
  Postcomposing with $\phi_U^{-1}$, we get the equation:
  $$
  l_{X \times Y} = \phi_U^{-1} \circ l_X \times l_Y \circ \phi_F
  $$
  Since we have $l_X = r_X$ and $l_Y = r_Y$, we also have
  $l_{X \times Y} = r_{X \times Y}$.

  Now the category of algebras $\Alg_{s'}$ is a full subcategory of
  $\Alg_s$, hence we get automatically that the projections are
  algebra morphisms and that the universal property is satisfied.

  By construction of the products, the forgetful functor
  $\bar{U}_{s'}$ preserves products definitionally.
\end{proof}

\subsubsection{Equalisers}

To talk about equalisers in a category of algebras, we need to know
what equality of algebra morphisms is. An algebra morphism is a pair
of a morphism in the underlying category and an equality stating that
this morphism preserves the algebra structure. If we have two pairs,
since equality of pairs is a pair of equalities, an equality between
them consists of an equality between the morphisms and an equality
between the proofs that they preserve the algebra structure. Since we
are working with types that satisfy uniqueness of identity proofs, we
can ignore the latter part, hence an equality between two algebra
morphisms is just an equality of the two underlying morphisms. This
reasoning applies to both point constructor algebra morphisms as well as
path constructor algebra morphisms.

\begin{lemma}[Equalisers of point constructors]
  Let $s' : \specty_\Ss$ be $s$ extended with a point constructor of sort
  $S_i$ as specified by:
  \begin{itemize}
  \item $F : \Func{\Alg_s}{S_i}$, satisfying:
  \item $t_i \circ F = t_i \circ \bar{U_s}$
  \end{itemize}

  If $\Alg_s$ has equalisers and $U_s$ preserves them, then the category
  $\Alg_{s'}$ has equalisers and its forgetful functor $U_{s'}$
  preserves them.
\end{lemma}

\begin{proof}
  Suppose we have two algebras in $\Alg_{s'}$, \ie we have:
  \begin{itemize}
  \item $X, Y : | \Alg_s |$
  \item $\theta : S_i(FX,\bar{U_s}X)$, $\rho : S_i(FY,\bar{U_s}Y)$
  \item $t_i \theta = \id_{t_i (\bar{U_s} X)}$, $t_i \rho = \id_{t_i (\bar{U_s} Y)}$
  \end{itemize}
  along with morphisms $f, g : \Alg_s(X,Y)$ satisfying:
  \begin{itemize}
  \item $Uf \circ \theta = \rho \circ Ff$
  \item $Ug \circ \theta = \rho \circ Fg$
  \end{itemize}
  \ie they are algebra morphisms $\theta \to \rho$.

  Define $E : \Alg_s$ to be the equaliser of $f$ and $g$ with
  inclusion $e : \Alg_s(E,X)$ which satisfies $f \circ e = g \circ e$.
  We need to show that $E$ has an algebra structure and $e$ is an
  algebra morphism of this structure into $\theta$. The following
  diagram commutes by virtue of $E$ being an equaliser and $f$ and $g$
  being algebra morphisms:
  $$
  \xymatrix{
    FE \ar[r]^{Fe} &FX \ar[d]_{\theta} \ar@<-.5ex>[r]_-{Ff} \ar@<.5ex>[r]^-{Fg} &FY \ar[d]^{\rho} \\
    UE \ar[r]^{Ue} &UX \ar@<-.5ex>[r]_-{Uf} \ar@<.5ex>[r]^-{Ug} &UY
  }
  $$
  Since $U$ preserves equalisers, $UE$ is an equaliser, hence we get a
  unique arrow $\epsilon : S_i(FE,UE)$. We need to check that we have
  $t_i \epsilon = \id_{t_i (\bar{U}_s E)}$. We know that the following
  commutes:
  $$
  \xymatrix{
    t_i (FE) \ar[r]^{t_i (Fe)} \ar[d]_{t_i \epsilon} &t_i (FX) \ar[d]^{t_i \theta} \\
    t_i (UE) \ar[r]^{t_i (Ue)} &t_i (UX) \ar@<-.5ex>[r]_-{t_i Uf} \ar@<.5ex>[r]^-{t_i Ug} &t_i (UY)
  }
  $$
  Furthermore, $t_i \theta = \id_{t_i (\bar{U}_s X)}$ and
  $t_i (Fe) = t_i (Ue)$, and since $t_i$ preserves equalisers, we
  necessarily have that $t_i \epsilon = \id_{t_i (\bar{U}_s E)}$.

  We still have to establish that the universal property is
  satisfied. Suppose we have $(A, \alpha) : | \Alg_{s'} |$ along with
  $a$ an algebra morphism $\alpha \to \theta$, by the universal
  property of $E$, we get a unique arrow $h : \Alg_s(A,E)$, satisfying
  $a = e \circ h$. We have to establish whether this is an algebra
  morphism $\alpha \to \epsilon$. Consider the following diagram:
  $$
  \xymatrix{
    FA
    \ar[r]^{Fh}
    \ar[d]_{\alpha}
    \ar@/^2pc/[rr]^{Fa}
    &FE 
    \ar[r]^{Fe}
    \ar[d]^{\epsilon}
    &FX
    \ar[d]^{\theta}
    \\
    UA
    \ar[r]_{Uh}
    \ar@/_2pc/[rr]_{Ua}
    &UE
    \ar[r]_{Ue}
    &UX
    \ar@<-.5ex>[r]_-{Uf} \ar@<.5ex>[r]^-{Ug}
    &UY
  }
  $$
  We have yet to establish whether the left square commutes, the other
  subdiagrams have already been shown to commute. Observe that we have
  two cones $(FA, \theta \circ Fa)$ and $(FA, Ua \circ \alpha)$ for
  the fork $Uf, Ug$. Since $a$ is an algebra morphism, these two cones
  are actually the same. Both $\epsilon \circ Fh$ and
  $Uh \circ \alpha$ are then cone morphisms from this cone into
  $(UE,Ue)$, which by the universal property of $UE$ means that
  $Uh \circ \alpha = \epsilon \circ Fh$, which establishes the
  commutativity of the left square and thereby the universal property
  of equalisers in $\Alg_{s'}$.
\end{proof}

\begin{lemma}[Equalisers of path constructors]
  Let $s' : \specty_\Ss$ be $s$ extended with a path constructor of sort
  $S_i$ as specified by:
  \begin{itemize}
  \item $F : \Func{\Alg_s}{S_i}$, satisfying $t_i \circ F = t_i \circ \bar{U_s}$
  \item $l, r : \Nat{F}{\bar{U}_s}$ satisfying
    $t_i\ l = t_i\ r = \id_{t_i \circ \bar{U}_s}$.
  \end{itemize}

  If $\Alg_s$ has equalisers and $U_s$ preserves them, then the category
  $\Alg_{s'}$ has equalisers and its forgetful functor $U_{s'}$
  preserves them.
\end{lemma}

\begin{proof}
  Suppose we have objects $X, Y : | \Alg_s |$ with algebra structures
  $\theta : l_X = r_X$ and $\rho : l_Y = r_Y$ and morphisms
  $f, g : \Alg_s(X,Y)$. We claim that the equaliser $E : \Alg_s$ of
  $f$ and $g$ has an algebra structure, \ie we can show that
  $l_E = r_E$.

  Since $l_X = r_X$ and the naturality of $l$ and $r$, we have that
  the following commutes:
  $$
  \xymatrix{
    FE \ar[r]^{Fe} \ar[d]_{l_E} &FX \ar@<-.5ex>[d]_-{l_X} \ar@<.5ex>[d]^-{r_X} \\
    UE \ar[r]^{Ue} &UX \ar@<-.5ex>[r]_-{Uf} \ar@<.5ex>[r]^-{Ug} &UY
  }
  $$
  We observe that $(FE, l_X \circ Fe)$ is a cone for the fork
  $Uf,Ug$. By $l_X = r_X$, $(FE, r_X \circ Fe)$ is the same fork. We
  then have that by naturality, both $l_E$ and $r_E$ are cone
  morphisms from $(FE, l_X \circ Fe)$ into the terminal cone
  $(UE,Ue)$, hence by universality we get that $l_E = r_E$.

  Since $\Alg_{s'}$ is a full subcategory of $\Alg_s$, $E$ with its
  proof $\epsilon : l_E = r_E$ inherits its universal property
  directly from $\Alg_s$.
\end{proof}

Together with \cref{initiality-to-section} and
\cref{section-to-initiality}, this immediately gives the main theorem
of this section:

\begin{theorem}
\label{thm:main}
  For each sort $\Ss : \sortsty$ and specification $s : \specty$, let $X$
  be an object in the category of algebras $\Alg_s$. Then $X$ is
  initial if and only if $X$ satisfies the section principle. \qed
\end{theorem}

In particular, this means that when implementing or formalising
quotient inductive-inductive types, one can restrict attention to the
conceptually simpler notion of initial algebra.

\section{Deriving the induction principle}

If we unfold the section principle for our categories of algebras, we
will not end up with a very natural induction principle. One of the
key features of type theory is that we have special notation for
families. If we want to define a predicate on a type $X$, the most 
natural way to do it is usually to define a family $X \to \Set$, not
to define another type $Y$ with a function $Y \to X$. 

Since our categories of sorts and algebras are built out of types, we
can try and derive a notion of families in these categories. In
$\Set$, we have the equivalence, for any $X : \Set$:
$$
(X \to \Set) = (Y : \Set) \times (p : Y \to X)
$$
where the function left to right is defined as
$\lambda P . ((x : X) \times P\ x , \pi_0)$, \ie we map the family to
its ``total space'' and its projection function. The inverse operation
is the preimage family: $(Y,p)$ is mapped to
$\lambda x . (y : Y) \times (p\ y = x)$. 

\subsection{Induction for $F$-algebras}
If we want to derive the notion of families of $F$-algebras for some
endofunctor $F : \Func{\Set}{\Set}$, then we proceed as follows: let
$(X,\theta) : | \algcat{F} |$, we want to solve the equivalence for
the type $\tau$:
%
\begin{align*}
&\ \ \ \ \ \ (P : X \to \Set) \times (m : \tau) \\
&= ((Y,\rho) : | \algcat{F} |) \times ((p,p_0) : \algcat{F}((Y,\rho),(X,\theta)))  
\end{align*}
%
We set $Y$ to $(x : X) \times P\ x$ and $p$ to $\pi_0$. We then have
to simplify the type
$(\rho : F ((x : X) \times P\ x)) \times (p_0 : \pi_0\ \circ \rho =
\theta \circ F\ \pi_0)$, which leads us to:
$$
m : (x : F ((x : X) \times P\ x)) \to P\ (F\ \pi_0\ x)
$$
This can be simplified even further if we define the operation
$\Box_F : (X \to \Set) \to FX \to \Set$, \ie the action of $F$ on type
families, which has the defining equation
$F ((x : X) \times P\ x) = (x : FX) \times \Box_F\ P\
x$. Rewriting the type of $m$ using this notation gives us:
$$
m : (x : FX) \times \Box_F\ P\ x \to P\ (\theta\ x)
$$
Intuitively the type $\Box_F\ P\ x$ is the induction hypothesis. We
can also read it as the modality ``all'': $\Box_F\ P\ x$ holds if $P$
holds for all values of type $X$ ``contained'' in $x$.

Now that we know what the algebra families are, we can derive what the
dependent algebra morphisms are as follows:

let $(X,\theta) : | \algcat{F}$ with an algebra family
$P : X \to \Set$,
$m : (x : FX) \times \Box_F\ P\ x \to P\ (\theta\ x)$. Our goal is to
find a type $\tau$ such that the following equivalence holds:
$$
(s : (x : X) \to P\ x) \times \tau = (f : \algcat{F}((X,\theta),(\Sigma X . P , \tilde{m}))) \times (\issection\ f)
$$
where $(\Sigma X . P , \tilde{m})$ is the total space of the family of
algebras $(P,m)$, where $\tilde{m}$ is given as the composite:
$$
\xymatrix@!C{
  F (\Sigma X . P)
  \ar[r]^-{\phi}
  &\Sigma (FX) . \Box_F\ P
  \ar[r]^-{\langle \theta \circ \pi_0 , m \rangle}
  &\Sigma X . P
}
$$



\subsection{General framework}

To derive notions of famlies and dependent morphism in the categories
of algebras, we will introduce some notation, making precise what we
have to generalise. We want to define a type of families over an
object that is equivalent to the type of morphisms into that same
object. We will call such a structure the \emph{family structure} on
that category. This definition on its own is not very useful: we can
always trivially satisfy the definition by letting the type of
families exactly be the type of morphisms into an object. However, our
categories are not completely arbitrary: they are always in some way
built out of objects and morphisms in $\Set$. We can therefore use the
notion of families in $\Set$ for those parts and see how the remaining
parts simplify.

\begin{definition}[Family structure on a category]
  The operations we need from a category $\Cc$ to talk about families
  are as follows:
%
  \begin{itemize}
  \item $\Fam_{\Cc} : | \Cc | \to \Type$
  \item $\total : (X : | \Cc |) \to \Fam_{\Cc}\ X \to | \Cc |$
  \item
    $\proj : (X : | \Cc |) (P : \Fam_{\Cc}\ X) \to \Cc(\total\ X\ P,
    X)$
  \item
    $\preimage : (X : | \Cc |)\ (Y : | \Cc |)\ (p : \Cc(Y,X)) \to
    \Fam_{\Cc}\ X$
  \end{itemize}
%
  The operations should also satisfy the following correctness
  conditions, for any $X : | \Cc |$:
%
  \begin{itemize}
  \item for any family $P : \Fam_{\Cc}\ X$,
  $$\preimage\ X\ (\total\ X\ P , \proj\ X\ P) = P$$
\item for any object $Y : | \Cc |$ with $p : \Cc(Y,X)$,
  %
  \begin{align*}
    &\ \ \ \ \ \ (\total\ X\ (\preimage\ X\ (Y,p)) , \proj\ X\ (\preimage\ X\ (Y,p))) \\
    &= (Y,p)
  \end{align*}
\end{itemize}
%
\end{definition}
To define these operations for the sort and algebra categories, we can
perform induction on the specification and apply the same techniques
as we did to derive the notion of families in $\algcat{F}$.

Given these operations, we can generalise the $\Box$ operator to any
functor $F : \Func{\Cc}{\Dd}$.

\begin{definition}[Functorial action on families]
  Given family structures $\Fam_{\Cc}$ and $\Fam_{\Dd}$, and
  $X : | \Cc |$ and $P : \Fam_{\Cc}\ X$,
  $\Box_F : (X : | \Cc |) \to \Fam_{\Cc} \to \Fam_{\Dd}$ is defined
  as:
  $$
  \Box_F\ X\ P \ddefeq \preimage_{\Dd}\ FX\ (F\ (\total_{\Cc}\ X\ P) ,
  F\ (\proj_{\Cc}\ X\ P))
  $$
\end{definition}

\begin{proposition}
  \label{box-thm}
  Given family structures $\Fam_{\Cc}$ and $\Fam_{\Dd}$, and
  $X : | \Cc |$ and $P : \Fam_{\Cc}\ X$, we have
  $$
  F (\total_{\Cc}\ X\ P) = \total_{\Dd}\ (F X) (\Box_F\ P)
  $$
\end{proposition}

\begin{proof}
  This follows directly from the correctness condition of the family
  structure on $\Dd$:
  \begin{align*}
    &&&F (\total_{\Cc}\ X\ P) \\
    &=& &\reasontext{correctness condition of $\Fam_{\Dd}$} \\
    &&&\total_{\Dd}\ (F X) (\preimage_{\Dd}\ (F X) (F (\total_{\Cc}\ X\ P), F (\proj_{\Cc}\ X\ P))) \\
    &=& &\reasontext{definition of $\Box_F$} \\
    &&&\total_{\Dd}\ (F X) (\Box_F\ P)
  \end{align*}
\end{proof}

\begin{corollary}
  Applying \cref{box-thm} to endofunctors on $\Set$, we get, given
  $F : \Func{\Set}{\Set}$, $X : \Set$, $P : X \to \Set$:
  $$
  F ((x : X) \times P x) = (x : FX) \times \Box_F\ P\ x
  $$
\end{corollary}

Having defined families, we can then go on to generalise the notion of
dependent functions. In $\Set$, given a family $P : X \to \Set$, a
dependent function $(x : X) \to P\ x$ corresponds to a function
$s : X \to (x : X) \times P\ x$ along with
$s_0 : \pi_0 \circ s = \id_X$. The function from left to right sends a
dependent function $s$ to its graph $\lambda x . (x , s\ x)$, which is
trivially a section. The other direction composes the section $s$ with
$\pi_1$, but we have to transport along the proof given by $s_0$ to
make it typecheck.

\begin{definition}
  The type of \emph{sections} in a category $\Cc$ is defined as:
  \begin{align*}
    &\Sect_{\Cc} : (X : | \Cc |) (Y : | \Cc |) (p : \Cc(Y,X)) \to \Set \\
    &\Sect_{\Cc}\ X\ Y\ p \ddefeq (s : \Cc(X,Y)) \times (s_0 : p \circ s = \id_X)
  \end{align*}
\end{definition}

A dependent morphism structure on a category with a family structure
is something that allows us to perform the same construction as in
$\Set$:

\begin{definition}[Dependent morphism structure]
  To generalise dependent morphisms to a category $\Cc$, we need a
  family
  $\DepHom_{\Cc} : (X : | \Cc |)\ (P : \Fam_{\Cc}\ X) \to \Type$ along
  with the following operations, given an object $X : | \Cc |$ and a
  family $P : \Fam_{\Cc}\ X$:
%
  \begin{itemize}
  \item
    $\grph : \DepHom\ X\ P \to \Sect\ X\ (\total\ X\ P,\proj\ X\ P)$
  \item
    $\snd : \Sect\ X\ (\total\ X\ P,\proj\ X\ P) \to \DepHom_{\Cc}\ X\
    P$
  \end{itemize}
%
  The correctness conditions are:
%
  \begin{itemize}
  \item for any $f : \DepHom_{\Cc}\ X\ P$,
  $$\snd\ X\ P\ s\ (\grph\ X\ P\ f) = f$$
\item for any $s : \Sect\ X\ (\total\ X\ P, \proj\ X\ P)$,
  $$\grph\ X\ P\ (\snd\ X\ P\ s) = s$$
\end{itemize}
%
\end{definition}

Note that the correctness conditions give us an equivalence
$$
\DepHom_{\Cc}\ X\ P = \Sect_{\Cc}\ (\total_{\Cc}\ X\ P)\ X\ (\proj_{\Cc}\ X\ P)
$$

Similar to the action of a functor $F$ on families, we can use this
structure to define the action of functors on dependent
morphisms. Given a functor $F : \Func{\Cc}{\Dd}$, we can define:
$$
\bar{F} : (X : | \Cc |) (P : \Fam_{\Cc}\ X) \to \DepHom_{\Cc}\ X\ P \to \DepHom_{\Cc}\ FX\ (\Box_F\ X\ P)
$$
If $F$ happens to be an endofunctor on $\Set$, this simplifies to:
$$
\bar{F} : (X : \Set) (P : X \to \Set) \to ((x : X) \to P\ x) \to (x : F X) \to \Box_F\ X\ P\ x
$$
Before we define $\bar{F}$, observe that we can easily define a function:
$$
\Sect_{\Cc}\ X\ (s , p) \to \Sect_{\Dd}\ FX\ (F s , F p)
$$
$\bar{F}$ can then be defined as the composite:
$$
\xymatrix{
\DepHom_{\Cc}\ X\ P
\ar[d]^{\grph}
\\
\Sect_{\Cc}\ X\ (\total_{\Cc}\ X\ P, \proj_{\Cc}\ X\ P)
\ar[d] 
\\
\Sect_{\Dd}\ FX\ (F (\total_{\Cc}\ X\ P), F\ (\proj_{\Cc}\ X\ P))
\ar[d]^{\phi}
\\
\Sect_{\Dd}\ FX\ (\total_{\Dd}\ FX (\Box_F\ X\ P), \proj_{\Dd}\ FX\ (\Box_F\ X\ P))
\ar[d]^{\snd}
\\
\DepHom_{\Dd}\ FX\ (\Box_F\ X\ P)
}
$$
The map $\phi$ we get from the equivalence given in \cref{box-thm}.

\subsection{Induction for quotient inductive-inductive definitions}

The family structure on $\Set$ is the usual one. We can derive
definitions of the family structure on categories of algebras by
induction. Since they are defined ``on top of'' $\Set$, we can use the
specification and the family structure on $\Set$ to derive appropriate
definitions. We will start out by considering the induction principles
for the contexts and types example and the interval type.

\subsubsection{Induction principle for $(\ttconty, \tttyty)$}

The induction principle consists of four parts:
\begin{itemize}
\item the \emph{motive}, which is intuitively the property that we are
  trying to prove holds for every element of the inductive definition
\item the \emph{methods}: we show for every constructor that the
  motive holds for that constructor, given the assumption that the
  motive holds for the recursive arguments
\item given the motive and methods, we get a \emph{dependent morphism}
  from the inductive type into the motive
\item this dependent morphism comes with \emph{computation rules},
  telling us how this dependent morphism behaves in conjunction with
  the constructors.
\end{itemize} 

Consider the inductive definition of the syntax of type theory,
restricting ourselves to contexts and types in a context, \ie we have
sorts $\ttconty : \Set$ and $\tttyty : \ttconty \to \Set$ with
constructors:
\begin{align*}
  \constr{\ttnil}{\ttconty} \\
  \constr{\ttcons{\_}{\_}}{(\Gamma : \ttconty) \to \tttyty\ \Gamma \to \ttconty} \\
  \constr{\ttpi}{(\Gamma : \ttconty)\ (A : \tttyty\ \Gamma)\ (B : \tttyty\ (\ttcons{\Gamma}{A})) \to \tttyty\ \Gamma}
\end{align*}

The motives for this definition are:
\begin{align*}
&P : \ttconty \to \Set \\
&Q : (\Gamma : \ttconty) \to P\ \Gamma \to \tttyty\ \Gamma \to \Set
\end{align*}
$P$ is a family over $\ttconty$ and $Q$ is a family over both $P$ and
$\tttyty$. In the motive for $\tttyty$ we are allowed to refer to
results of the induction principle applied to the context at hand.

The methods are as follows:
\begin{align*}
  &m_{\ttnil} &&: &&P\ \ttnil \\
  &m_{\ttcons{\_}{\_}} &&: &&(\Gamma : \ttconty)\ (x : P\ \Gamma) \\
  &&&&&(A : \tttyty\ \Gamma)\ (y : Q\ \Gamma\ x\ A)  \\
  &&&&&\to P\ (\ttcons{\Gamma}{A}) \\
  &m_{\ttpi} &&: &&(\Gamma : \ttconty)\ (x : P\ \Gamma) \\
  &&&&&(A : \tttyty\ \Gamma)\ (y : Q\ \Gamma\ x\ A) \\
  &&&&&(B : \tttyty\ (\ttcons{\Gamma}{A}))\ (z : Q\ (\ttcons{\Gamma}{A})\ (m_{\ttcons{\_}{\_}}\ \Gamma\ x\ A\ y)\ B) \\
  &&&&&\to Q\ \Gamma\ x\ (\ttpi\ \Gamma\ A\ B)
\end{align*}

The method for the constructor $\ttnil$ is unsurprising. For
$\ttcons{\_}{\_}$ we see that its method, just like the constructor
itself, refers to the motive of $\tttyty$. The method for $\ttpi$
refers to a previous \emph{method}, reflecting the reference to the
corresponding previous constructor.

Given these motives and methods, the induction principle gives us the
following dependent functions:
\begin{align*}
&\ttconind : (\Gamma : \ttconty) \to P\ \Gamma \\
&\tttyind : (\Gamma : \ttconty)\ (A : \tttyty\ \Gamma) \to Q\ \Gamma\ (\ttconind\ \Gamma)\ A
\end{align*}
with computation rules:
\begin{align*}
  &\ttconind\ \ttnil = m_{\ttnil} \\
  &\ttconind\ (\ttcons{\Gamma}{A}) = m_{\ttcons{\_}{\_}}\ \Gamma\ (\ttconind\ \Gamma)\ A\ (\tttyind\ \Gamma\ A) \\
  &\tttyind\ \Gamma\ (\ttpi\ \Gamma\ A\ B) = m_{\ttpi}\ \Gamma\ (\ttconind\ \Gamma)\ A\ (\tttyind\ \Gamma\ A)\ B\ (\tttyind\ (\ttcons{\Gamma}{A})\ B)
\end{align*}

Reading these equations as a recursive definition of the morphisms, we
see that it is a mutual definition. Another thing to note is that the
last equation, for the constructor $\ttpi$, has repeating variables on
the left hand side, so we cannot read it strictly as a pattern
matching definition, but instead it is a definition given by dependent
pattern matching. Unifying the type of the constructor $\ttpi$ with
the signature of $\tttyind$, we see that the two variables of type
$\ttconty$ have to be the same.

\subsubsection{Induction principle for the interval type}

Let us recall the inductive definition of the interval $\intty$ with
constructors:
\begin{align*}
  \constr{\intzero}{\intty} \\
  \constr{\intone}{\intty} \\
  \constr{\intseg}{\intzero = \intone}
\end{align*}

Since it is just a $\Set$-sorted inductive definition, a motive for
induction on $\intty$ is a family $P : \intty \to \Set$. The methods
are:
\begin{align*}
  &m_{\intzero} : P\ \intzero \\
  &m_{\intone} : P\ \intone \\
  &m_{\intseg} : \pathover{P}{\intseg}{m_{\intzero}}{m_{\intone}}
\end{align*}

which gives us a dependent function $\intind : (x : \intty) \to P\ x$
with computation rules:
\begin{align*}
  &\intind\ \intzero = m_{\intzero} \\
  &\intind\ \intone = m_{\intone} \\
\end{align*}

The induction principle for $\intty$ is not very different from its
recursion principle. The most interesting difference is that the
method for $\intseg$ is a \emph{dependent equality}, as $m_{\intzero}$
and $m_{\intone}$ have definitionally different types.

Since we are working with sets, we do not need to add a computation
rule for the path constructor $\intseg$, as that would introduce a
path between equalities, \ie it would not introduce anything new.

\subsubsection{Family and dependent morphism structure on $\Fam$}

Before we move on to sort categories and categories of algebras, let
us first consider the families and dependent morphisms in the category
$\Fam$. Recall that $\Fam$ is the sort category for the
inductive-inductive type $(\ttconty,\tttyty)$ of contexts and types in
a context. We will use the intuition of the induction principle of
that inductive-inductive definition to make sense of what is going on
here.

Our first goal is to derive a family $\Fam_{\Fam} : | \Fam | \to \Set$
that satisfies, for any $X : | \Fam |$:
$$
\Fam_{\Fam} = (Y : | \Fam |) \times \Fam(Y,X)
$$
We derive the definition by taking the right hand side of the above
equation and performing the following equational reasoning:
\begin{align*}
  &&&(Y : | \Fam |) \times \Fam(Y,X) \\
  &=& &\reasontext{definition of objects and morphisms in $\Fam$} \\
  &&&(Y : \Set) \times (Q : Y \to \Set) \times (p : Y \to X) \\
  &&&\times (q : (y : Y) \to Q\ y \to P\ (p\ y)) \\
  &=& &\reasontext{combining $Y$ and $P$ using the family structure on $\Set$} \\
  &&&(V : X \to \Set) \times (Q : (x : X) \times V\ x \to \Set) \\
  &&&\times (q : (y : (x : X) \times V\ x) \to Q\ y \to P\ (\pi_1\ y)) \\
  &=& &\reasontext{currying} \\
  &&&(V : X \to \Set) \times (Q : (x : X) \to V\ x \to \Set) \\
  &&&\times (q : (x : X) \to (y : V\ x) \to Q\ x\ y \to P\ x) \\
  &=& &\reasontext{combining $Q$ and $q$ using family structure on $\Set$} \\
  &&&(V : X \to \Set) \times (W : (x : X) \to V\ x \to P\ x \to \Set)
\end{align*}
What we ended up with does match with what a motive for $(\ttconty,\tttyty)$
is, namely:
$$
(P : \ttconty \to \Set) \times (Q : (\Gamma : \ttconty) \to P\ \Gamma \to \tttyty\ \Gamma \to \Set)
$$
A motive consists of a motive on $\ttconty$, which is just a family
on it, along with a family on $\tttyty$, for every
$\Gamma : \ttconty$. Since we may also refer to results we get from
doing induction on $\Gamma$, we also have a $P\ \Gamma$ in there.

We then give the following definitions:
%
\begin{align*}
  \Fam_{\Fam}\ (X , P) &\ddefeq (V : X \to \Set) \times (W : (x : X) \to P\ x \to V\ x \to \Set) \\
  \total_{\Fam}\ (X , P)\ (V , W) &\ddefeq ((x : X) \times V\ x , (\lambda (x , z) . (y : P\ x) \times W\ x\ y\ z)) \\
  \proj_{\Fam}\ (X, P)\ (V, W) &\ddefeq (\lambda (x , y) . x , \lambda (x , y) (z , w) \to z) \\
  \preimage_{\Fam}\ (X, P)\ ((C,D),(p, q)) &\ddefeq (\lambda a . (c : C) \times p\ c = a , \lambda  x y (z, z') . (w : D\ z) \times (\pathover{P}{z'}{q\ z\ w}{y}))
\end{align*}
%
Now we have a family structure on $\Fam$, we need to define what
dependent morphisms of these families are. Returning to the
$(\ttconty,\tttyty)$ example, given a motive $P : \ttconty \to \Set$,
$Q : (\Gamma : \ttconty) \to P\ \ttconty \to \tttyty\ \Gamma \to \Set$
and the appropriate methods, the induction principle gives us two
functions:
%
\begin{align*}
  &\ttconind : (\Gamma : \ttconty) \to P\ \Gamma \\
  &\tttyind : (\Gamma : \ttconty) (\tau : \tttyty\ \Gamma) \to Q\ \Gamma\ (\ttconind\ \Gamma)\ \tau
\end{align*}
%
The function $\tttyind$ refers to $\ttconind$ in its type as well: the
results we get from $\ttconind$ may be used in the motive of
$\tttyty$.

We can derive this formulation by the following equational reasoning:
\begin{align*}
  &&&(s : \Fam_{\Fam}((X,P),(\total_{\Fam}\ (X , P)\ (V, W)))) \times (s_0 : \proj_{\Fam}\ (X, P)\ (V, W) \circ_{\Fam} s = \id_{\Fam}\ (X,P)) \\
  &=&& \reasontext{definition of morphisms in $\Fam$, equality of pairs is pair of equalities} \\
  &&&(s : X \to (x : X) \times V\ x) \\
  &&&\times (t : (x : X) \to P\ x \to (y : P (\pi_0\ (s\ x))) \times (W\ (\pi_0\ (s\ x))\ y\ (\pi_1\ (s\ x)))) \\
  &&&\times (s_0 : \pi_0 \circ s = \id_{\Set}\ X) \times (t_0 : \lambda x z . \pi_0\ (t\ x\ z) = \lambda x z . z) \\
  &=&& \reasontext{combining $s$ and $s_0$ using the dependent morphism structure on $\Set$} \\
  &&&(s : (x : X) \to V\ x) \times (t : (x : X) \to P\ x \to (y : P\ x) \times W\ x\ y\ (s\ x)) \\
  &&&\times (t_0 : \lambda x z . \pi_0\ (t\ x\ z) = \lambda x z . z) \\
  &=&& \reasontext{combining $t$ and $t_0$ using the dependent morphism structure on $\Set$} \\
  &&&(s : (x : X) \to V\ x) \times (t : (x : X)\ (y : P x) \to W\ x\ y\ (s\ x))
\end{align*}

The dependent morphism structure on $\Fam$ is then:
$$
\DepHom_{\Fam}\ (X , P)\ (V , W) \ddefeq (f : (x : X) \to V\ x) \times (g : (x : X) \to (y : P\ x) \to W\ x\ y\ (f\ x))
$$
%
% \begin{align*}
%   \DepHom_{\Fam}\ (X , P)\ (V , W) &\ddefeq (f : (x : X) \to V\ x) \times (g : (x : X) \to (y : P\ x) \to W\ x\ y\ (f\ x)) \\
%   \grph_{\Fam}\ (X , P)\ (V , W)\ (f , g) &\ddefeq ((\lambda x . (x , f\ x) , \lambda x\ y . y , (g\ x\ y)) , \refl) \\
%   \snd_{\Fam}\ (X , P)\ (V , W)\ ((s , t) , s_0) &\ddefeq ?
% \end{align*}
%
\subsubsection{Sort categories}

The family structure on a sort category can be given by induction on
the specification. In the case of an empty specification, we define
$\Fam_{\termcat}\ X \ddefeq \unitty$ for any $X : | \termcat |$. The
other definitions are equally trivial.

In the induction step case, we get a family structure on $S_{i-1}$ and
have to provide one on the category $S_i$ which is built out of
$S_{i-1}$ with the functor $R_i : \Func{S_{i-1}}{\Set}$. Our goal is
to find, given $X : | S_{i-1} |$ and $P : R_i X \to \Set$, a set
$\Fam_{S_i} (X, P)$ such that:
$$
\Fam_{S_i} (X, P) = ((Y , Q) : | S_i |) \times (p : S_i((Y,Q),(X,P)))
$$
We can perform the following equational reasoning on the right hand
side of the equation above:
\begin{align*}
  &&&(Y : | S_i |) \times (p : S_i(Y,(X,P))) \\
  &=& &\reasontext{definition of $S_i$} \\
  &&&(Y : | S_{i-1} |) \times (Q : R_i Y \to \Set) \times (p : S_{i-1}(Y,X)) \times (q : (x : R_i Y) \to Q\ x \to P\ (R_i\ p\ x)) \\
  &=& &\reasontext{combining $Y$ and $p$ using family structure on $S_{i-1}$} \\
  &&&(V : \Fam_{S_{i-1}}\ X) \times (Q : R_i (\total_{S_{i-1}}\ X\ V) \to \Set) \\
  &&&\times (q : (x : R_i (\total_{S_{i-1}}\ X\ V)) \to Q\ x \to P\ (R_i (\proj_{S_{i-1}}\ X\ V)\ x)) \\
  &=& &\reasontext{rewrite $R_i (\total_{S_{i-1}}\ X\ V)$ with $\Box_{R_i}$} \\
  &&&(V : \Fam_{S_{i-1}}\ X) \times (Q : (x : R_i X) \times \Box_{R_i}\ X\ V\ x \to \Set) \\
  &&&\times (q : (x : R_i X) \times (y : \Box_{R_i}\ X\ V\ x) \to Q\ (x , y) \to P\ x)) \\
  &=& &\reasontext{combining $Q$ and $q$ using family structure on $\Set$} \\
  &&&(V : \Fam_{S_{i-1}} X) \times (W : (x : R_i X) \to \Box_{R_i}\ X\ V\ x \to P\ x \to \Set)
\end{align*}

The family structure on $S_i$ is then:
$$
  \Fam_{S_i}\ (X , P) \ddefeq (V : \Fam_{S_{i-1}} X) \times (W : (x : R_i X) \to \Box_{R_i}\ X\ V\ x \to P\ x \to \Set)
$$
with
%
\begin{align*}
  \total_{S_i}\ (X , P)\ (V , W) &\ddefeq (\total_{S_{i-1}}\ X\ V, \lambda x . (y : P\ (R_i\ (\proj_{S_{i-1}}\ X\ V)\ x)) \times (W (\phi\ x)\ y)) \\
  \proj_{S_i}\ (X, P)\ (V, W) &\ddefeq (\proj_{S_{i-1}}\ X\ V, \lambda x (y , z) . y)
\end{align*}
%
where
$\phi : (x : R_i X) \times \Box_{R_i}\ X\ V x \to R_i\
(\total_{S_{i-1}}\ X\ V)$
is the isomorphism we get from the definition of $\Box$.

The dependent morphism structure on $S_i$ can be derived in a similar
way that of $\DepHom_{\Fam}$, arriving at:
$$
  \DepHom_{S_i}\ (X , P)\ (V , W) \ddefeq (f : \DepHom_{S_{i-1}}\ X\ V) \times (g : (x : R_i\ X)\ (y : P\ x) \to W\ (x , \bar{R}_i\ f\ x)\ y)\\
$$

\subsubsection{Point constructors}

Suppose we have the following data describing a point constructor:
%
\begin{itemize}
\item $\Ss : \sortsty$
\item $s : \specty_{\Ss}$
\item $S_i : \Cat$
\item $p : \sortsin{S_i}{\Ss}$
\item $F : \Func{\Alg_s}{S_i}$ such that $t_i \circ F = t_i \circ \hat{U_s}$
\end{itemize}

Define $s' \ddefeq \specsnoc\ s\ (S_i,p,F) : \specty$ to be the new
specification, which is $s$ extended with the point constructor given by
the data above. We want to derive the family structure on this
category $\Alg_{s'}$:
$$
\hdots
$$
The family structure on $\Alg_{s'}$ is then:
$$
  \Fam_{\Alg_{s'}}\ (X , \theta) \ddefeq ? \\
$$
The dependent morphism structure on $\Alg_{s'}$ is then:
$$  
\DepHom_{\Alg_{s'}}\ (X , \theta)\ (P , m) \ddefeq ?
$$

\subsubsection{Path constructors}

Suppose we have the following data describing a path constructor:
%
\begin{itemize}
\item $\Ss : \sortsty$
\item $s : \specty_{\Ss}$
\item $S_i : \Cat$
\item $p : \sortsin{S_i}{\Ss}$
\item $F : \Func{\Alg_s}{S_i}$ such that $t_i \circ F = t_i \circ \hat{U_s}$
\item $l , r : \Nat{F}{\hat{U_s}}$ such that $t_i l = t_i r = \id$
\end{itemize}

Define $s' \ddefeq \specsnoc\ s\ (S_i,p,F) : \specty$ to be the new
specification, which is $s$ extended with the path constructor given by
the data above. We want to derive the family structure on this
category $\Alg_{s'}$:
$$
\hdots
$$
The family structure on $\Alg_{s'}$ is then:
$$
  \Fam_{\Alg_{s'}}\ (X , \theta) \ddefeq ? \\
$$
Since $\Alg_{s'}$ is a full subcategory of $\Alg_s$, the dependent
morphisms are simply inherited from $\Alg_s$.
