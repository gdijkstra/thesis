\chapter{Introduction}
\label{intro}

In this thesis we set out to develop a theory of \emph{quotient
  inductive-inductive definitions}, which are an inductive-inductive
definitions \cite{NordvallForsberg2013} extended with path
constructors. This first chapter we will give some context of the
problem and discuss prior art and related concepts. The chapter is
concluded by an overview of the thesis and a list of contributions.

\section{Inductive definitions in mathematics and computer science}

Inductive definitions occur in various forms in both mathematics and
computer science. We will start out by going through some examples in
a classical (set theoretic) mathematical setting. We will then show
what role induction plays in type theory and mention the various forms
of induction that have been explored in that area. We also spend some
time talking about the categorical treatment of (algebraic) theories
and its relation to inductive definitions. After this we talk about
the use of induction in programming in the form of algebraic data
types and pattern matching definitions and mention how it relates to
inductive definitions in type theory.

\subsection{In mathematics}
In mathematics, induction is an important proof technique. The most
common and perhaps oldest form (dating back to at least Plato
\cite{Acerbi2000}) of induction is induction on the natural numbers:
if we want to prove that a formula $\phi(n)$ holds for any
$n \in \natty$, it suffices to prove $\phi(0)$ and for any
$n \in \natty$ that $\phi(n)$ implies $\phi(n+1)$. In fact, the fact that
the natural numbers satisfy this property can be seen as one of the
defining properties of the natural numbers. This was first written
down formally by Guiseppe Peano \cite{Peano1889}. He defined the natural numbers to be
a set $\natty$ with the properties such as:
\begin{itemize}
\item $0 \in \natty$
\item for any $n \in \natty$, $\natsucc(n) \in \natty$.
\item $\natty$ satisfies the induction principle
\end{itemize}
The remaining axioms describe the equality relation on the natural
numbers and postulate the injectivity of the $\natsucc$ constructor
and that $\natzero \neq \natsucc\ n$ for all $n \in \natty$.

Such a definition is an \emph{inductive definition}.

There are other forms of induction in mathematics: transfinite
induction (induction over ordinals other than the natural numbers?) 

Interesting inductive definitions are those of the surreal numbers,
where one also introduces an equivalence relation inductively at the
same time as its elements.

Schemes for inductive definitions in first order logic \cite{MartinLof1971}

\subsection{In type theory}
In this thesis, we are concerned with inductive definitions in type
theory. In Martin-L\"of Type Theory, types are usually defined
inductively. They are defined by four sets of rules:
\begin{itemize}
\item \emph{type formation rules} ($\natty$ is a type)
\item \emph{introduction rules} ($\natzero : \natty$)
\item \emph{elimination rules} (given $P : \natty \to \Type$, $m_{\natzero} : P\ \natzero$, $m_{\natsucc} : (n : \natty) \to P\ n \to P\ (\natsucc\ n)$, we get $\natind\ P\ m_{\natzero}\ m_{\natsucc} : (x : \natty) \to P\ x$)
\item \emph{computation rules} ($\natind\ P\ m_{\natzero}\ m_{\natsucc}\ \natzero = m_{\natzero}$, $\natind\ P\ m_{\natzero}\ m_{\natsucc}\ (\natsucc\ n) = m_{\natsucc}\ n\ (\natind\ P\ m_{\natzero}\ m_{\natsucc} n)$)
\end{itemize}
The type formation, introduction and elimination rules are not
essentially different from Peano's rules. Missing however are rules
defining an equality relation on $\natty$. As we will see, we can
define the equality relation as a single parametric inductive
definition uniformly for all types. Given this notion of equality and
given that we have a universe of types, one can derive that the
constructors are disjoint and injective.

The declaration of an inductive definition involves given rules in all
these classes. However, as observed by Backhouse, it is enough to give
the type formation rules and introduction rules: the elimination
principle along with its computation rules can be derived from
them. This fact is also reflected in how one declares inductive
definitions in type theory-based proof assistants such as Coq
\cite{Bertot2004} and Agda \cite{Norell2007} by simply giving a
sequence of constructors, \ie introduction rules.

\subsection{In category theory}
Apart from the type theoretic perspective, the categorical perspective
is also relevant. Inductive definitions such as the natural numbers
can be explained as being an initial object in the category of
$F$-algebras, for some endofunctor $F$. The specification of an
inductive definition then amounts to giving the appropriate
endofunctor on the appropriately chosen category.

As observed by Shulman, since given an endofunctor $F$ the category of
$F$-algebras is equivalent to the category of \emph{monad algebras} on
$F^*$ the free monad of $F$ (if it exists), generalising inductive
definitions ought to involve moving from free monads to a larger class
of monads. A related concept to inductive definitions are algebraic
theories. An algebraic theory consists of a set of \emph{operations},
which are much like \emph{constructors} of an inductive
definition. Another ingredient to algebraic theories are
\emph{equations}, which is traditionally not considered to be a part
of inductive definitions. Models of algebraic theories such as the
theory of groups can be specified as being monad algebras of the monad
that corresponds to the theory. For groups, this is the monad on
$\Set$ which sends a set to the underlying set of the free group on
that set.

The quotient inductive-inductive definitions we present in this thesis
are inductive definitions with equations and as such can also be
thought of as algebraic theories. There is a difference however with
theories in general. With inductive definitions we are interested in
the \emph{initial} object of the category of algebras or models. For
theories, the existence of an initial object is not always
important. Consider the theory of fields, the category of fields does
not have an initial object. However, presenting the theory of fields
categorically also means we have to move from algebraic theories to
generalised varieties \cite{Adamek2001}. 

Also the syntax of type theory itself can be thought of as an
inductive definition. One way of describing the semantics of type
theory is as \emph{categories with families}. These objects themselves
form a category in which the syntax, given as the \emph{syntactic
  model}, is the initial object. As such, the category of categories
with families can be thought of as a category of algebras. Realising
type theory in type theory as an inductive definition is done in ...

\subsection{In computer science}

Recursion is a central concept to computer science. Data structures
are often defined in terms of themselves, for example a binary tree is
either a leaf or a pair of binary trees. Functions defined on binary
trees are then naturally also recursive themselves. In functional
programming languages one usually has a mechanism available to define
recursive data structures, called algebraic data types. In Haskell \cite{Jones2003},
one can define (linked) lists as the algebraic data type:
$$
\data\ \List\ a = \listnil\ |\ \listcons\ a\ (\List\ a)
$$
Using \emph{pattern matching} on the constructors, we can define
functions on algebraic data types, \eg:
\begin{align*}
  &\listmap : (a \to b) \to \List\ a \to \List\ b \\
  &\listmap\ f\ \listnil = \listnil \\
  &\listmap\ f\ (\listcons\ x\ xs) = \listcons\ (f\ x)\ (\listmap\ f\ xs)
\end{align*}
In languages like Haskell, we only get a way to pattern matching on an
algebraic data type: we do not get an induction principle as a
primitive. However, as we are allowed to use recursion to our heart's
content, we can derive the (non-dependent) induction principle. For
lists this is usually called $\listfoldr$:
\begin{align*}
  &\listfoldr : b \to (a \to b \to b) \to \List\ a \to b \\
  &\listfoldr\ e\ op\ \listnil = e \\
  &\listfoldr\ e\ op\ (\listcons\ x\ xs) = op\ x\ (\listfoldr\ e\ op\ xs)
\end{align*}

If we move to a dependently typed programming language that we want to
be total, we cannot take this approach to algebraic data types /
inductive definitions. In such a setting one can do it the type
theoretic way and use elimination principles instead of pattern
matching.  In Agda (or as first implemented in ALF) one can have
pattern matching with recursion as long as one makes sure that the
definitions are \emph{structurally} recursive: the recursive
occurrences are on subterms of the arguments of the clause.

Restricting recursive function definitions is not enough however: one
also has to make sure that the inductive definitions themselves are of
the right shape: they have to be \emph{strictly positive}. If we were
to have an inductive type:
\begin{datatype}{\Tty}{\Type}
  \constr{\Ta}{(\Tty \to \Tty) \to \Tty}
\end{datatype}
then we can define:
\begin{align*}
  &uh : T \to \emptyty \\
  &uh (\Ta\ f) \ddefeq uh\ (f\ (\lambda x . x)) \\
  \\
  &oh : T \\
  &oh \ddefeq (\lambda x . x)
\end{align*}
Since $f\ (\lambda x . x)$ is structurally smaller than $\Ta\ f$, the
definition of $uh$ is structurally recursive. However, it does give us
a term that does not have a normal form, namely $uh\ oh$.

Indexed inductive types, or generalised algebraic data types as they
are called in Haskell, are useful in programming as they allow us to
encode properties in the types. Examples being well-scoped and
well-typed abstract syntax trees and red-black trees. Pattern matching
in this setting, which is called dependent pattern matching, also
becomes a powerful tool. As we have to unify the type of the function
that is being defined with that of the constructor of a clause, we
actually get more information about the variables present in the
patterns. This may rule out impossible clauses or tell us that certain
variables are definitionally equal.

When we restrict ourselves to strictly positive inductive definitions
and structurally recursive function definitions, we end up with a
subset of definitions that can be translated to the corresponding
invocations of the elimination principles. There are some caveats with
this translation however. For ordinary inductive types, it is the case
that such a translation cannot always preserve the definitional
computational behaviour of the original function
\cite{McBride2006ii}. When we move to indexed inductive definitions,
the translation becomes more involved and in general requires
uniqueness of identity proofs of the equality used in the translation.

The latter is a problem when we want to use pattern matching
definitions in homotopy type theory, where uniqueness of identity
proofs does not hold. Luckily there exist further restrictions that we
can make on the pattern matching definitions to ensure that a
translation to eliminators is possible, without having to use
uniqueness of identity proofs. This is implemented in Agda.

\section{Homotopy type theory and higher inductive types}

In type theory we have a notion of equality defined on \emph{terms}
called \emph{definitional} equality, which we refer to with the symbol
$\equiv$:
\begin{itemize}
\item $\lambda x . e\ x \equiv \lambda y . e\ y$: $\alpha$-equivalence
\item $\lambda x . f\ x \equiv f$: $\eta$-equivalence
\item $(\lambda x . e) a \equiv e[x/a]$: $\beta$-equivalence
\end{itemize}

This notion of equality is \emph{external} to the theory, it is a
meta-theoretic property. For example, we cannot write down a type:
$$
(A : \Type) \to (x\ y : A) \to x \equiv y \to A
$$
However, using an indexed inductive definition we can ``internalise''
it: given a type $A$ we define:
%
\begin{datatype}{\_=_A\_}{A \to A \to \Type}
  \constr{\refl}{(x : A) \to x =_A x}
\end{datatype}
%
If we have a term $\refl\ x : x =_A y$ for some $x, y : A$ then this
only type checks if $x \equiv y$. From a pattern matching point of
view, it seems like this equality really matches up with definitional
equality. If we normalise a closed term of an identity type $x = y$,
it normalises to $\refl$, hence it gives us that $x \equiv y$. As
such, one would expect that if we have two terms $p, q : x = y$, then
also $p = q$, \ie we have \emph{uniqueness of identity proofs}. Using
dependent pattern matching this is easy to prove:
\begin{align*}
  &uip : (A : \Type)\ (x\ y : A)\ (p\ q : x = y) \to p = q \\
  &uip\ A\ x\ .x\ (\refl\ x)\ (\refl\ x) \ddefeq \refl\ (\refl\ x)
\end{align*}
Pattern matching on $p$ forces $x$ and $y$ to be definitionally equal,
yielding $p \equiv \refl\ x$. Pattern matching on $q$, which now has
type $x = x$, also gives us $q \equiv \refl\ x$. We then have
$p \equiv \refl\ x \equiv q$, hence $\refl\ (\refl\ x)$ type checks.

However, translating this proof of uniqueness of identity proofs to
one that only makes use of the elimination principle of identity
types, called the $\J$ eliminator, is impossible. It has been shown
that there exists a model of type theory with identity types, in which
types are modelled as groupoids. There exist groupoids in which there
are non-trivial automorphisms, hence this model violates uniqueness of
identity proofs.

The idea to model types as groupoids comes from the fact that $J$
allows us to show that the identity types form not only an equivalence
relation on a type, but that the transitivity and symmetry operations,
along with $\refl$ also satisfy the groupoid laws. These laws are
satisfied again up to propositional equality, so the identity types
themselves are groupoids, ad infinitum. In fact, types can be seen as
\inftygrpds. Since \inftygrpds are a model of homotopy theory, which
studies topological spaces up to homotopy, types themselves can also
be thought of as topological spaces up to homotopy. This observation
has given rise to the field of \emph{homotopy type theory}.

A model of type theory emphasising its relationship to homotopy
theory, is the simplicial set model. Simplicial sets have a notion of
\emph{equivalence} which coincides with equality. In this model the
\emph{univalence axiom} is valid, which roughly means that
(coherently) isomorphic types are also propositionally equal.

Now we know we can think of types as topological spaces up to
homotopy, we need a way to define the usual examples, such as the
circle and the torus, in a type theoretic way. As we have seen, we
define new data types in type theory usually as an inductive
type. However, ordinary inductive definitions do not give us a way to
create new paths between points that was not already there. The
solution is to generalise the idea of constructor to also allow for
paths to be constructed. We can then define the circle, which is just
a point with a non-trivial loop, as the following \emph{higher
  inductive type}:
\begin{datatype}{\circlety}{\Type}
  \constr{\circlebase}{\circlety} \\
  \constr{\circleloop}{\circlebase = \circlebase}
\end{datatype}
The constructor $\circleloop$ is a \emph{path constructor}: it
constructs a new path from $\circlebase$ to $\circlebase$. 

\todoi{something about an recursion principle for this}

Note that to show that $\circleloop \neq \refl_{\circlebase}$, we need
to have a universe of types which is univalent. This is similar to how
we cannot show that $\boolt \neq \boolf$ if we cannot eliminate into a
universe.

Apart from allowing constructors to construct paths between points,
higher inductive types also allow for \emph{higher} path constructors
which construct paths between paths. For example, we can describe the
torus as the following higher inductive type:
\begin{datatype}{\torusty}{\Type}
  \constr{\torusbase}{\torusty} \\
  \constr{\torusp}{\torusbase = \torusbase} \\
  \constr{\torusq}{\torusbase = \torusbase} \\
  \constr{\torusr}{\torusp \ct \torusq = \torusq \ct \torusp}
\end{datatype}

This approach has been succesfully used to formalise various results
of homotopy theory in type theory, leading to the field of
\emph{synthetic homotopy theory}.

While people have succesfully used certain particular higher inductive
types and shown that they behave nicely. There are informal proofs
that higher inductive types in general have certain properties, \eg we
can reduce any $n$-constructor with $n > 1$ to a 1-constructor by
iterating the so called hub-spokes construction. However, a general
theory or formal definition of higher inductive types is missing so
far. There is a draft by Lumsdaine and Shulman that discusses the
semantics of higher inductive types, but leaves out the syntactic
details. Sojakova has worked out that initial algebra semantics for
certain higher inductive types along with a more general form called
W-suspensions coincides with the corresponding induction principles.

Furthermore some results have been made by expressing certain higher
inductive types in terms of a small set of primitive (higher)
inductive types.

\todoi{something about path constructors and algebraic theories}

\section{Internalising the theory of quotient inductive-inductive definitions}

Our goal is not only to devise a theory of quotient
inductive-inductive definitions, but also make sure we can formalise
it in type theory itself. With the definition being internal we mean
that in order to formalise it, we do not first have to formalise the
ordinary metatheory of type theory itself, which is already a
gargantuan undertaking of its own, and then build upon that. Instead
we have a more direct definition.

\todoi{something about how we can define a predicate on a type saying
  that it satisfies the induction principle or is the initial object
  in the category of algebras: this kind of internal def is the one we want}

The advantage of this approach that we have a stronger guarantee that
our proofs are correct if we have formalised them. Another advantage
is that having an internal definition of inductive definitions is that
we can perform induction on them, \ie we can do metaprogramming or
generic programming.

Having the theory internal to type theory also allows us to check
whether we have a valid implementation of quotient inductive-inductive
definitions. To show that the implementation is correct is to show
that we get initial objects in the appropriate category of
algebras. If we manage to show that it is enough to implement a small
set of primitive quotient inductive types to be able to implement
arbitrary quotient inductive-inductive definitions, this amounts to
using these primitives to constructing initial objects in the
categories of algebras.

There are downsides to an internal approach however. When talking
about inductive definitions for type theory, we often expect the
computation rules to hold definitionally. In type theory we only have
the weaker notion of propositional equality at our disposal. Replacing
definitional equality with propositional equality is not always
straightforward: one frequently runs into \emph{coherence
  issues}.

There are several solutions to this problem. One solution is to change
the type theory to also have an internal notion of definitional
equality. Such a theory has as of yet not been worked out fully yet,
but progress has been made so far. Now there are two approaches to
define the category of algebras: we can take the original definition
and use definitional equality where needed. Doing this is not without
problems: one is bound to run into issues of resulting ``types'' not
fibrant, hence not being types but \emph{pretypes}. Another approach
is to deal with the coherence issues in a uniform way using techniques
from \inftycat theory, which can be performed in type theory using the
internal definitional equalities.

Another solution to the coherence issues is to restrict one self to
\emph{sets}, \ie types that satisfy the uniqueness of identity proofs
principle, as a first approximation. This is the approach we will use
in the main parts of this thesis. This allows us to focus on the
essential parts of the theory and defer the coherence issues to a
later point in time.

Opposed to tackling the coherence conditions uniformly using the heavy
handed methods from \inftycat theory, one can deal with the coherence
lazily, \ie as they pop up. For our purposes we usually do not need
the full set of coherence conditions from the categories we work with,
so we can just manually use those that we need to prove our theorems
about inductive definitions. This approach is explored in one of the
last chapters.

\section{Overview of the thesis and contributions}

The main contribution of this thesis is a formal specification of
quotient inductive-inductive definitions, given in type theory. The
thesis is organised as follows:

\begin{itemize}
\item In \cref{prelims}, we give the basic concepts and notation we
  will use in this thesis, along with proofs of basic propositions and
  lemmata used throughout the thesis.
\item \Cref{qits} presents examples of quotient inductive-inductive
  definitions and their applications and compares them to other
  notions such as quotients and coequalisers.
\item \Cref{describing} contains the formal specification of quotient
  inductive-inductive definitions. They are specified as being a
  certain kind of iterated dialgebras, which generalises the
  presentation of ordinary inductive definitions as algebras of
  functors.
\item Having a formal specification of quotient inductive-inductive
  definitions and the corresponding categories of algebras, we show in
  \cref{induction} that the initial algebra semantics coincides with a
  categorical formulation of the type theoretic induction
  principle. From the categorical formulation we derive the type
  theoretic formulation, showing that induction and initiality
  coincide for our inductive definitions.
\item In \cref{constructing} we give some preliminary results on
  constructing quotient inductive-inductive definitions given some
  reasonable assumptions on the type theory.
\item \Cref{untruncated} is about what the difficulties are when
  moving from a set-based setting to the untruncated case. Here we go
  into detail about the coherence issues we face and how some of these
  can be solved in an ad-hoc manner.
\item The last chapter, \cref{conclusion}, presents the conclusions of
  the thesis along with a discussion of the presented results. We also
  point out several avenues for future work.
\end{itemize}

\section{Declaration of authorship}

A lot of the research leading up to this thesis has been a joint
effort with fellow researchers.

\todoi{Mention Thorsten, Paolo and Fredrik}
