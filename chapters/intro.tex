\chapter{Introduction}
\label{intro}

In this thesis we set out to develop a theory of \emph{quotient
  inductive-inductive definitions}, which are inductive-inductive
definitions \cite{NordvallForsberg2013} extended with path
constructors. This first chapter we will give some context of the
problem and discuss prior art and related concepts. The chapter is
concluded by an overview of the thesis and a list of contributions.

\section{Induction in mathematics}
\todoi{Add quote from Aczel1977 (find copy of this) for an
introductory definition of induction}

In mathematics, induction is an important proof technique. The most
common and perhaps oldest form of induction is induction on the
natural numbers, dating back to at least Plato
\cite{Acerbi2000}. Induction on the natural numbers gives us a way
want to prove that a formula $\phi(n)$ holds for any $n \in \natty$:
we have to prove $\phi(0)$ and prove that for any $n \in \natty$ that
$\phi(n)$ implies $\phi(n+1)$. In fact, the fact that the natural
numbers satisfy this property can be seen as one of the defining
properties of the natural numbers. This was first written down
formally by Guiseppe Peano \cite{Peano1889}. He defined the natural
numbers to be a set $\natty$ with the properties such as:
\begin{itemize}
\item $0 \in \natty$
\item for any $n \in \natty$, $\natsucc(n) \in \natty$.
\item $\natty$ satisfies the induction principle
\end{itemize}
The remaining axioms describe the equality relation on the natural
numbers and postulate the injectivity of the $\natsucc$ function
symbol and that $\natzero \neq \natsucc\ n$ for all $n \in \natty$.

A consequence of the induction principle for natural numbers, is that
we can define functions $\natty \to X$, for some set $X$,
\emph{recursively}: it suffices to define $f\ 0$ and
$f\ (\natsucc(n))$, where we may refer to $f\ n$. We can use this to
define addition $n + m$ on the natural numbers, by recursion on the
second argument $m$, \ie we define $n + 0 \ddefeq n$ and
$n + \natsucc(m) \ddefeq \natsucc(n+m)$.

In mathematics, the construction of new sets is often done by taking
the natural numbers as a given and building upon this and quotienting
where needed, as opposed to giving an inductive definition
directly. For example, the rational numbers can be constructed as
$\natty \times \natty$ quotiented by the relation
$(a , b) \sim (c , d)$ if and only $ad = bc$. When quotienting
infinite sets is not always unproblematic. The usual construction of
the real numbers as a quotient of Cauchy sequences of rational numbers
requires the axiom of choice to show that it forms a complete metric
space. Direct inductive definitions (with equations) can avoid such
problems, as we will see in \cref{cauchy-reals}.

\section{Induction in computer science}

Recursion is a central concept to computer science. Data structures
are often defined in terms of themselves: for example, a binary tree
is either a leaf or a pair of binary trees. Functional programming
languages therefore often come with a mechanism to express definitions
such as these, usually under the name of \emph{algebraic data types}.

In Haskell \cite{Jones2003}, one can define (linked) lists as the
algebraic data type:
$$
\data\ \List\ a = \listnil\ |\ \listcons\ a\ (\List\ a)
$$
As opposed to having a recursion principle associated with the
algebraic data type, we have \emph{pattern matching} and general
recursion. For example, we can define a function as follows:
%
\begin{align*}
  &\listmap : (a \to b) \to \List\ a \to \List\ b \\
  &\listmap\ f\ \listnil = \listnil \\
  &\listmap\ f\ (\listcons\ x\ xs) = \listcons\ (f\ x)\ (\listmap\ f\ xs)
\end{align*}
%
Pattern matching and general recursion are powerful enough to let us
implement the recursion operator associated with the inductive
type. In the case of lists, this is usually called $\listfoldr$:
%
\begin{align*}
  &\listfoldr : b \to (a \to b \to b) \to \List\ a \to b \\
  &\listfoldr\ e\ op\ \listnil = e \\
  &\listfoldr\ e\ op\ (\listcons\ x\ xs) = op\ x\ (\listfoldr\ e\ op\ xs)
\end{align*}
%

If we care about the totality of our definitions, pattern matching and
general recursion are too powerful. First of all we have to restrict
ourselves to \emph{structurally} recursive definitions: recursive
calls may only be done on subterms of the patterns on the left hand
side of the pattern matching clause. This is however not enough to
ensure termination of definitions. The inductive types themselves also
have to be of the right shape:: they have to be \emph{strictly
positive}. If we were to have an inductive type:
%
\begin{datatype}{\Tty}{\Type}
  \constr{\Ta}{(\Tty \to \Tty) \to \Tty}
\end{datatype}
then we can define:
\begin{align*}
  &uh : T \to \emptyty \\
  &uh\ (\Ta\ f) \ddefeq uh\ (f\ (\lambda x . x)) \\
  \\
  &oh : T \\
  &oh \ddefeq \Ta\ (\lambda x . x)
\end{align*}
%
Since $f\ (\lambda x . x)$ is structurally smaller than $\Ta\ f$, the
definition of $uh$ is structurally recursive. However, it does give us
a term that does not have a normal form, namely $uh\ oh$.

Algebraic data types allow us to specify types or a family of types
parametrised by type variables. As these are \emph{parameters}, we are
not allowed to vary them in the result type of the
constructors. Lifting this restriction, \ie turning the parameters
into \emph{indices}, gives us \emph{generalised algebraic data types}
(GADTs) or \emph{inductive families}. We can use the indices to store
extra information in the type, allowing us to encode invariants. They
have been used to implement a type of well-typed abstract syntax trees
\cite{Pavsalic2004} and red-black trees \cite{Kahrs2001}, among many
other uses.

Inductive families are especially powerful in a dependently typed
setting in conjunction with \emph{dependent pattern matching}
\cite{Coquand1992}, such as it is implemented in Agda
\cite{Norell2007}. The information encoded in the indices may tell us
that certain cases are impossible and need not be treated, or they may
tell us that certain variables in the patterns are equal. We can
define the type of length-indexed lists, also referred to as vectors
as follows:
%
\begin{datatype}{\vecty\ (A : \Type)}{\natty \to \Type}
  \constr{\vecnil}{\vecty\ A\ \natzero} \\
  \constr{\veccons}{A \to (n : \natty)\ (xs : \vecty\ A\ n) \to \vecty\ A\ (\natsucc\ n)}
\end{datatype}
%
We can define a function that returns the first element of a non-empty
list as follows:
%
\begin{align*}
  &\vechead : (A : \Type)\ (n : \natty) \to \vecty\ A\ (\natsucc\ n) \to A \\
  &\vechead\ A\ n\ (\veccons\ x\ .n\ xs) = x
\end{align*}
%
By pattern matching on the argument of type
$\vecty\ A\ (\natsucc\ n)$, we get two cases: the value is either
constructed with constructor $\vecnil$ or $\veccons$. If we unify the
type of the argument with that of the constructors, we see that the
argument can never be $\vecnil$, as that produces something of type
$\vecty\ A\ \natzero$. Furthermore, if we consider the $\veccons$
case, we notice that the natural number argument of the constructor
has to coincide with the one we already had in our context, hence we
get the non-linear pattern $\vechead\ A\ n\ (\veccons\ x\ .n\ xs)$,
where the dot indicates that it is a repeated variable.

It has been shown that under certain assumptions, \ie if the data
types are strictly positive and the recursion is structural, along
with certain assumptions about the equality in the type theory, then
these dependent pattern matching definitions can be translated to ones
using only elimination principles \cite{Goguen2006}. The restrictions
on the type of equality used can be relaxed in certain cases
\cite{Cockx2014}, giving us a form of dependent pattern matching which
is compatible with homotopy type theory.

In Agda, apart from inductive families, we can also define inductive
types mutually with other inductive types/families or functions,
giving us inductive-inductive \cite{NordvallForsberg2013} and
inductive-recursive definitions \cite{Dybjer1999} respectively.

\section{Formal treatment of induction}

So far we have given several examples of inductive types and recursive
definitions, but have not given a formal definition of what an
inductive definition is. In \cite{MartinLof1971}, Martin-L\"of gives a
scheme of the rules that comprise an inductive definition in
first-order logic. In this thesis we are concerned with inductive
definitions in Martin-L\"of Type Theory \cite{MartinLof1972}, but we
will also look at category theoretic characterisations in
\cref{in-category-theory}, to guide us to appropriate generalisations.

\subsection{In type theory}
\label{in-type-theory}
Extending a type theory with a particular inductive definition means
that we have the extend the theory with four sets of inference rules:
%
\begin{itemize}
\item \emph{type formation rules} ($\natty$ is a type)
\item \emph{introduction rules} ($\natzero : \natty$, $\natsucc : \natty \to \natty$)
\item \emph{elimination rules} (given $P : \natty \to \Type$, $m_{\natzero} : P\ \natzero$, $m_{\natsucc} : (n : \natty) \to P\ n \to P\ (\natsucc\ n)$, we get $\natind\ P\ m_{\natzero}\ m_{\natsucc} : (x : \natty) \to P\ x$)
\item \emph{computation rules} ($\natind\ P\ m_{\natzero}\ m_{\natsucc}\ \natzero = m_{\natzero}$, $\natind\ P\ m_{\natzero}\ m_{\natsucc}\ (\natsucc\ n) = m_{\natsucc}\ n\ (\natind\ P\ m_{\natzero}\ m_{\natsucc} n)$)
\end{itemize}
%
In the case of the natural numbers, the type formation, introduction
and elimination rules are not essentially different from Peano's
rules. Missing however are rules defining an equality relation on
$\natty$. As we will see, we can define the equality relation as a
single parametric inductive definition uniformly for all types. Given
this notion of equality and given that we have a universe of types
available, one can derive that the constructors are disjoint and
injective.

The declaration of an inductive definition involves given rules in all
these classes. However, as observed by Backhouse et
al. \cite{Backhouse1989}, it is enough to give the type formation
rules and introduction rules: the elimination principle along with its
computation rules can be derived from them. This fact is also
reflected in how one declares inductive definitions in type
theory-based proof assistants such as Coq \cite{Bertot2004} and Agda
by simply giving a sequence of constructors, \ie introduction rules.

\subsection{In category theory}
\label{in-category-theory}

Inductive definitions can be characterised in category theory as
\emph{initial $F$-algebras}, for some endofunctor $F$ on an
appropriately chosen category. For example, the set of natural numbers
with its operations $\natzero$ and $\natsucc$ form an initial algebra
for the functor $F X \ddefeq \unitty + X$. The property of being an
initial algebra contains the same information as given by the four
classes of rules, for the appropriately chosen endofunctor. 

The perspective on inductive definitions as initial algebras allows us
to generalise easily. If we associate ordinary inductive types with
initial algebras of endofunctors on a category $\Cc$, which is a model
of type theory, \eg $\Set$, then inductive families correspond to
initial algebras of endofunctors on slice categories of
$\Cc$. 


Another way to generalise is based on the observation that
$F$-algebras for an endofunctor $F$ coincide with $F^*$-monad
algebras, where $F^*$ is the free monad of $F$. (Note that $F^*$ may
not exist: $F$ needs to be a strictly positive functor.) As is
described in \cite{Shulman2011}, we can interpret this as ordinary
inductive types being associated with free monads. Generalising these
inductive types would be the same as considering a larger class of monads. 

As monads and monad algebras are also used to talk about algebraic
theories, such as the theory of groups, the aforementioned observation
makes clear the relationship between inductive definitions and
algebraic theories. An essential ingredient of algebraic theories is
the ability to talk about equations. This is something which is
lacking in the inductive definitions we have seen so far.

\section{Higher inductive types and homotopy type theory}

Higher inductive types are a generalisation of inductive types,
stemming from homotopy type theory, where apart from the usual
constructors, called \emph{point constructors}, we may also have
equations as constructors, called \emph{path constructors}.

This notion of equality is \emph{external} to the theory, it is a
meta-theoretic property. For example, we cannot write down a type:
$$
(A : \Type) \to (x\ y : A) \to x \equiv y \to A
$$
However, using an indexed inductive definition we can ``internalise''
it: given a type $A$ we define:
%
\begin{datatype}{\_=_A\_}{A \to A \to \Type}
  \constr{\refl}{(x : A) \to x =_A x}
\end{datatype}
%
If we have a term $\refl\ x : x =_A y$ for some $x, y : A$ then this
only type checks if $x \equiv y$. From a pattern matching point of
view, it seems like this equality really matches up with definitional
equality. If we normalise a closed term of an identity type $x = y$,
it normalises to $\refl$, hence it gives us that $x \equiv y$. As
such, one would expect that if we have two terms $p, q : x = y$, then
also $p = q$, \ie we have \emph{uniqueness of identity proofs}. Using
dependent pattern matching this is easy to prove:
\begin{align*}
  &uip : (A : \Type)\ (x\ y : A)\ (p\ q : x = y) \to p = q \\
  &uip\ A\ x\ .x\ (\refl\ x)\ (\refl\ x) \ddefeq \refl\ (\refl\ x)
\end{align*}
Pattern matching on $p$ forces $x$ and $y$ to be definitionally equal,
yielding $p \equiv \refl\ x$. Pattern matching on $q$, which now has
type $x = x$, also gives us $q \equiv \refl\ x$. We then have
$p \equiv \refl\ x \equiv q$, hence $\refl\ (\refl\ x)$ type checks.

However, translating this proof of uniqueness of identity proofs to
one that only makes use of the elimination principle of identity
types, called the $\J$ eliminator, is impossible. It has been shown
that there exists a model of type theory with identity types, in which
types are modelled as groupoids. There exist groupoids in which there
are non-trivial automorphisms, hence this model violates uniqueness of
identity proofs.

The idea to model types as groupoids comes from the fact that $J$
allows us to show that the identity types form not only an equivalence
relation on a type, but that the transitivity and symmetry operations,
along with $\refl$ also satisfy the groupoid laws. These laws are
satisfied again up to propositional equality, so the identity types
themselves are groupoids, ad infinitum. In fact, types can be seen as
\inftygrpds. Since \inftygrpds are a model of homotopy theory, which
studies topological spaces up to homotopy, types themselves can also
be thought of as topological spaces up to homotopy. This observation
has given rise to the field of \emph{homotopy type theory}.

A model of type theory emphasising its relationship to homotopy
theory, is the simplicial set model. Simplicial sets have a notion of
\emph{equivalence} which coincides with equality. In this model the
\emph{univalence axiom} is valid, which roughly means that
(coherently) isomorphic types are also propositionally equal.

Now we know we can think of types as topological spaces up to
homotopy, we need a way to define the usual examples, such as the
circle and the torus, in a type theoretic way. As we have seen, we
define new data types in type theory usually as an inductive
type. However, ordinary inductive definitions do not give us a way to
create new paths between points that was not already there. The
solution is to generalise the idea of constructor to also allow for
paths to be constructed. We can then define the circle, which is just
a point with a non-trivial loop, as the following \emph{higher
  inductive type}:
\begin{datatype}{\circlety}{\Type}
  \constr{\circlebase}{\circlety} \\
  \constr{\circleloop}{\circlebase = \circlebase}
\end{datatype}
The constructor $\circleloop$ is a \emph{path constructor}: it
constructs a new path from $\circlebase$ to $\circlebase$. 

\todoi{something about an recursion principle for this}

Note that to show that $\circleloop \neq \refl_{\circlebase}$, we need
to have a universe of types which is univalent. This is similar to how
we cannot show that $\boolt \neq \boolf$ if we cannot eliminate into a
universe.

Apart from allowing constructors to construct paths between points,
higher inductive types also allow for \emph{higher} path constructors
which construct paths between paths. For example, we can describe the
torus as the following higher inductive type:
\begin{datatype}{\torusty}{\Type}
  \constr{\torusbase}{\torusty} \\
  \constr{\torusp}{\torusbase = \torusbase} \\
  \constr{\torusq}{\torusbase = \torusbase} \\
  \constr{\torusr}{\torusp \ct \torusq = \torusq \ct \torusp}
\end{datatype}

This approach has been succesfully used to formalise various results
of homotopy theory in type theory, leading to the field of
\emph{synthetic homotopy theory}.

While people have succesfully used certain particular higher inductive
types and shown that they behave nicely. There are informal proofs
that higher inductive types in general have certain properties, \eg we
can reduce any $n$-constructor with $n > 1$ to a 1-constructor by
iterating the so called hub-spokes construction. However, a general
theory or formal definition of higher inductive types is missing so
far. There is a draft by Lumsdaine and Shulman that discusses the
semantics of higher inductive types, but leaves out the syntactic
details. Sojakova has worked out that initial algebra semantics for
certain higher inductive types along with a more general form called
W-suspensions coincides with the corresponding induction principles.

Furthermore some results have been made by expressing certain higher
inductive types in terms of a small set of primitive (higher)
inductive types.

\todoi{something about path constructors and algebraic theories}

\section{A theory of quotient inductive-inductive definitions}

Our goal is not only to devise a theory of quotient
inductive-inductive definitions, but also make sure we can formalise
it in type theory itself. With the definition being internal we mean
that in order to formalise it, we do not first have to formalise the
ordinary metatheory of type theory itself, which is already a
gargantuan undertaking of its own, and then build upon that. Instead
we have a more direct definition.

\todoi{something about how we can define a predicate on a type saying
  that it satisfies the induction principle or is the initial object
  in the category of algebras: this kind of internal def is the one we want}

The advantage of this approach that we have a stronger guarantee that
our proofs are correct if we have formalised them. Another advantage
is that having an internal definition of inductive definitions is that
we can perform induction on them, \ie we can do metaprogramming or
generic programming.

Having the theory internal to type theory also allows us to check
whether we have a valid implementation of quotient inductive-inductive
definitions. To show that the implementation is correct is to show
that we get initial objects in the appropriate category of
algebras. If we manage to show that it is enough to implement a small
set of primitive quotient inductive types to be able to implement
arbitrary quotient inductive-inductive definitions, this amounts to
using these primitives to constructing initial objects in the
categories of algebras.

There are downsides to an internal approach however. When talking
about inductive definitions for type theory, we often expect the
computation rules to hold definitionally. In type theory we only have
the weaker notion of propositional equality at our disposal. Replacing
definitional equality with propositional equality is not always
straightforward: one frequently runs into \emph{coherence
  issues}.

There are several solutions to this problem. One solution is to change
the type theory to also have an internal notion of definitional
equality. Such a theory has as of yet not been worked out fully yet,
but progress has been made so far. Now there are two approaches to
define the category of algebras: we can take the original definition
and use definitional equality where needed. Doing this is not without
problems: one is bound to run into issues of resulting ``types'' not
fibrant, hence not being types but \emph{pretypes}. Another approach
is to deal with the coherence issues in a uniform way using techniques
from \inftycat theory, which can be performed in type theory using the
internal definitional equalities.

Another solution to the coherence issues is to restrict one self to
\emph{sets}, \ie types that satisfy the uniqueness of identity proofs
principle, as a first approximation. This is the approach we will use
in the main parts of this thesis. This allows us to focus on the
essential parts of the theory and defer the coherence issues to a
later point in time.

Opposed to tackling the coherence conditions uniformly using the heavy
handed methods from \inftycat theory, one can deal with the coherence
lazily, \ie as they pop up. For our purposes we usually do not need
the full set of coherence conditions from the categories we work with,
so we can just manually use those that we need to prove our theorems
about inductive definitions. This approach is explored in one of the
last chapters.

\section{Overview of the thesis and contributions}

The main contribution of this thesis is a formal specification of
quotient inductive-inductive definitions, given in type theory. The
thesis is organised as follows:

\begin{itemize}
\item In \cref{prelims}, we give the basic concepts and notation we
  will use in this thesis, along with proofs of basic propositions and
  lemmata used throughout the thesis.
\item \Cref{qits} presents examples of quotient inductive-inductive
  definitions and their applications and compares them to other
  notions such as quotients and coequalisers.
\item \Cref{describing} contains the formal specification of quotient
  inductive-inductive definitions. They are specified as being a
  certain kind of iterated dialgebras, which generalises the
  presentation of ordinary inductive definitions as algebras of
  functors.
\item Having a formal specification of quotient inductive-inductive
  definitions and the corresponding categories of algebras, we show in
  \cref{induction} that the initial algebra semantics coincides with a
  categorical formulation of the type theoretic induction
  principle. From the categorical formulation we derive the type
  theoretic formulation, showing that induction and initiality
  coincide for our inductive definitions.
\item In \cref{constructing} we give some preliminary results on
  constructing quotient inductive-inductive definitions given some
  reasonable assumptions on the type theory.
\item \Cref{untruncated} is about what the difficulties are when
  moving from a set-based setting to the untruncated case. Here we go
  into detail about the coherence issues we face and how some of these
  can be solved in an ad-hoc manner.
\item The last chapter, \cref{conclusion}, presents the conclusions of
  the thesis along with a discussion of the presented results. We also
  point out several avenues for future work.
\end{itemize}

\section{Declaration of authorship}

A lot of the research leading up to this thesis has been a joint
effort with fellow researchers.

\todoi{Mention Thorsten, Paolo and Fredrik}
