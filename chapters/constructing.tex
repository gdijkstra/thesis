\chapter{Constructing quotient inductive-inductive definitions}
\label{constructing}

We have given a formal definition of what constitutes a quotient
inductive-inductive definition in terms of algebraic semantics. We
have shown that the resulting categories of algebras are sensible in
the sense that an algebra is initial if and only if it satisfies the
induction principle. We have therefore shown that the initial algebras
are well-behaved in this regard. To justify adding quotient
inductive-inductive types to the theory, we still need to establish
their existence in the usual models. After all, these results are all
uninteresting if these models do not have quotient inductive-inductive
types, which would make our results vacuously true.

To start out we will address the issue of strict positivity in
inductive definitions and see how we can generalise the notion of
\emph{container} to fit our needs. In this light, we will examine what
the associated generalisation of W-types would be for our inductive
definitions.

Starting from a more semantic point of view, we discuss in
\cref{sequential-colimits} the usual construction of intial algebras
for an endofunctor as a sequential colimit. We explore how this
approach can be both internalised as well as adapted to construct
initial algebras for certain classes of quotient inductive-inductive
definitions. They key is here to not only construct an initial object
but establish that there is a left adjoint to the forgetful functor
$\Func{\Alg_{n+1}}{\Alg_{n}}$, which allows us to do the construction by
induction on the length of the specification. We end up with a chain
of adjunctions:
$$
\xymatrix{
\Set \ar@/^/[r]^{L_0}
\ar@{}[r]|{\top} 
&\Alg_0 \ar@/^/[l]^{U_0} \ar@/^/[r]^{L_1} 
\ar@{}[r]|{\top} 
&\Alg_1 \ar@/^/[l]^{U_1} \ar@/^/[r]^{L_2} 
\ar@{}[r]|{\top} 
&\hdots \ar@/^/[l]^{U_2} \ar@/^/[r]^{L_n} 
\ar@{}[r]|{\top} 
&\Alg_n \ar@/^/[l]^{U_n}
}
$$
Since left adjoints preserve colimits, in particular initial objects
and $\Set$ has an initial object $\emptyty$,
$(L_n \circ \hdots \circ L_0)\ \emptyty$ gives us the initial algebra
in $\Alg_n$ we are after.

\section{Strict positivity}

For ordinary inductive types we have to have several syntactic
restrictions on the point constructors in order for the inductive
types to actually exist. We have seen in
\cref{from-syntax-to-functors} that the recursive positions may only
occur in \emph{positive positions} in order for the arguments to
describe a covariant functor. This is not enough to guarantee the
existence of an initial algebra. If we look at $\Set$ and consider the
double powerset functor $P : \Func{\Set}{\Set}$:
$$
P\ X \ddefeq (X \to \boolty) \to \boolty
$$
This defines a covariant functor on $\Set$, yet $\algcat{P}$ does not
have an initial algebra. By Lambek's lemma, having an initial algebra
$(X,\theta) : | \algcat{P} |$ would imply that $\Iso{X}{P\ X}$. By
Cantor's theorem, we know that there is no set $X$ which is isomorphic
to its powerset, hence we arrive at a contradiction.

\subsection{Containers}
The inductive definitions therefore need to be \emph{strictly}
positive: positivity alone does not suffice. There are different ways
to formally specify strictly positive functors. We can use a syntactic
way to describe them as the class of functors that contains all
constant functor, closed under sums and products of strictly positive
functors, exponentiation with a constant on the left of the arrow, and
taking fixpoints \cite{Morris2007}. A more compact way to characterise
strictly positive functors on $\Set$ in type theory is as
\emph{containers}:
%
\begin{definition}
  A \emph{container} on $\Set$ consists of:
  \begin{itemize}
  \item $S : \Set$, a type of \emph{shapes}
  \item $P : S \to \Set$, a family of \emph{position}, indexed by the shapes.
  \end{itemize}
  %
  The container with shapes $S$ and positions $P$ is denoted as
  $\cont{S}{P}$
\end{definition}
%
The corresponding functor is called the \emph{extension} of the container:
%
\begin{definition}
  Given a container $\cont{S}{P}$, its \emph{extension} is the functor
  $\context{\cont{S}{P}} : \Func{\Set}{\Set}$ with its action on objects
  defined as, for every $X : \Set$:
  $$
  \context{\cont{S}{P}}\ X \ddefeq (s : S) \times (P\ s \to X)
  $$
  and its action on functions $f : X \to Y$:
  $$
  \context{\cont{S}{P}}\ f \ddefeq \lambda (s , t) . (s , f \circ t)
  $$
\end{definition}

\subsection{Containers for $\Set$-sorted definitions}
To give the data for a quotient inductive-inductive definition, we
often need more than just endofunctors on $\Set$. We are generally
working with functors $\Func{\Alg_s}{S_i}$ where $s : \specty$
describes the previous constructors and $S_i$ is sort category
describing the sort of the constructor we are defining. Containers
have a generalisation to \emph{indexed containers} which describe
functors between slice categories of $\Set$. This concept is again an
instance of the more general notion of \emph{polynomial functor},
which describes strictly positive functors between slices categories
of a locally cartesian closed category. We cannot expect $\Alg_s$ to
be locally cartesian closed in general: if we take $s$ to be the
specification corresponding to setoids (as in
\cref{application-to-equational-theories}, then $\Alg_s$ is equivalent
to the category setoids, which is not locally cartesian closed
\cite{Altenkirch2012}.

If we look at containers a bit more closely, we see that they are
coproduct of a family of representable functors. This observation
leads us to \emph{generalised containers}, also known as
\emph{famillialy representable functors} \cite{Carboni1995}:
%
\begin{definition}
  A \emph{generalised container} on a category $\Cc$ consists of:
  \begin{itemize}
  \item $S : \Set$, a type of shapes,
  \item $P : S \to | \Cc |$, a family of representing objects, indexed
    by the shapes.
  \end{itemize}
\end{definition}
%
The extension generalises straightforwardly:
%
\begin{definition}
  Given a container $\cont{S}{P}$ on a category $\Cc$, its extension
  is the functor $\context{\cont{S}{P}} : \Func{\Cc}{\Set}$ with its
  action on objects defined as, for every $X : | \Cc |$:
  $$
  \context{\cont{S}{P}}\ X \ddefeq (s : S) \times \Cc(P\ s, X)
  $$
  and its action on functions $f : X \to Y$:
  $$
  \context{\cont{S}{P}}\ f \ddefeq \lambda (s , t) . (s , f \circ t)
  $$
\end{definition}
%
For ordinary containers, there exists a composition operation on
them. For generalised containers, such an operation only makes sense
if the extensions are composable. Even then, the usual construction is
not always possible: suppose we have a $\Cc$-container $\cont{S}{P}$
and a $\Set$-container $\cont{T}{Q}$, given an object $X : | \Cc |$, we can calculate:
\begin{align*}
  \context{\cont{T}{Q}}\ (\context{\cont{S}{P}}\ X) &=& &(t : T) \times (Q\ t \to \context{\cont{S}{P}}\ X) \\
  &=& &(t : T) \times (Q\ t \to (s : S) \times \Cc(P\ s, X)) \\
  &=& &(t : T) \times (a : Q\ t \to S) \times (b : (x : Q\ t) \to \Cc(P\ (a\ x), X))
\end{align*}
Looking at the above computation, a candidate $\Cc$-container whose
extension is equal to the composite
$\context{\cont{T}{Q}} \circ \context{\cont{S}{P}}$ seems to have as shapes
$$
(t : T) \times (Q\ t \to S)
$$
In the ordinary container case, to derive the corresponding positions,
one uses currying on the type of $b$. However, if
$\context{\cont{S}{P}}$ happens to have a left adjoint
$L : \Func{\Set}{\Cc}$, then the situation simplifies as follows:
\begin{align*}
  \context{\cont{T}{Q}}\ (\context{\cont{S}{P}}\ X) &=& &(t : T) \times (Q\ t \to \context{\cont{S}{P}}\ X) \\
  &=& &(t : T) \times (\Cc(L (Q\ t), X)) \\
\end{align*}
So we get the following equation:
$$
\context{\cont{T}{Q}} \circ \context{\cont{S}{P}} = \context{\cont{T}{L \circ P}}
$$

The notion of \emph{container morphism}, which are used to represent
natural transformations between containers can be phrased as follows
for generalised containers:
\begin{definition}
  Given $\Cc$-containers $\cont{S}{P}$ and $\cont{T}{Q}$, a container
  morphism consists of:
  \begin{itemize}
  \item $f : S \to T$
  \item $g : (s : S) \to \Cc(Q\ (f\ s), P\ s)$
  \end{itemize}
  with its extension being the natural transformation:
  \begin{align*}
    &\context{f , g} : (X : | \Cc |) \to \context{\cont{S}{P}}\ X \to \context{\cont{T}{Q}}\ X \\
    &\context{f , g}\ X\ (s , t) \ddefeq (f\ s , t \circ (g\ s))
  \end{align*}
  Naturality follows from the associativity law of $\Cc$.
\end{definition}

\subsection{Containers for arbitrarily sorted definitions}
We have given a way to describe strictly positive functors and natural
transformations needed to describe $\Set$-sorted quotient
inductive-inductive definitions. However, the functors we work with
are not generally functors into $\Set$, but may also be into any sort
category.

In this section we will show how this can be done for the special case
$\Fam$. Suppose we have a category $\Cc$, which we can think of as
being a category of $\Fam$-sorted algebras. It is therefore equipped
with a forgetful functor $U : \Func{\Cc}{\Fam}$. Describing the
arguments of a $\Fam$-sorted constructor over $\Cc$ requires us to
give a functor $F : \Func{\Cc}{\Fam}$ such that
$t_1 \circ F = t_1 \circ U$, where $t_1 : \Func{\Fam}{\Set}$ is its
forgetful functor.

Note that we have $\Fam = \Set^I$, therefore by the
cartesian-closedness of $\Cat$, we have
$\Func{\Cc}{\Set^I} = \Func{\Cc \times I}{\Set}$. To give a functor
$F : \Func{\Cc}{\Fam}$ is to give two functors
$F^0, F^1 : \Func{\Cc}{\Set}$ along with a natural transformation
$\alpha : \Nat{F^1}{F^0}$.

Furthermore, we have the requirement that $F^0 = t_1 \circ U$. If we
assume that we have an adjunction $L \dashv U : \Func{\Cc}{\Fam}$,
$t_1 \circ U$ will also have a left adjoint (as $t_1$ also has a left
adjoint). If $t_1 \circ U$ has a left adjoint, it is a representible
functor, which means it is also a container.

\subsection{Generalising W-types}

Let $\Cont_{\Set}$ be the type of containers on $\Set$. W-types give
us a primitive $\wty : \Cont_{\Set} \to \Set$ along with a constructor
$\wsup : (F : \Cont_{\Set}) \to \context{F}\ \wty_F \to \wty$. For
every container $F$, $(\wty_F,\wsup_F)$ satisfy the induction
principle, \ie we have:
$$
\welim : (F : \Cont_{\Set}) \to (P : \Fam_{\algcat{F}}\ (\wty_F,\wsup_F)) \to \DepHom_{\algcat{F}}\ P
$$
Generalising this idea to quotient inductive-inductive definitions would be to have a primitive:
$$
\wty : (\Ss : \sortsty)\ (s : \Cont_{\Ss}) \to \Alg_s
$$
with induction principle:
$$
\welim : (\Ss : \sortsty)\ (s : \Cont_{\Ss}) \to (P : \Fam_{\Alg_s}\ (\wty\ \Ss\ s,\wsup\ \Ss\ s)) \to \DepHom_{\Alg_s}\ P
$$
where $\Cont_{\Ss}$ is the same as $\specty_{\Ss}$ but instead of
having arbitrary functors, we have containers instead. The
interpretation of $\Cont_{\Ss}$ as a category of algebras is then also
the same as for $\specty_{\Ss}$, but then composed with the extension
operation on containers.

However, unlike ordinary W-types, this is a rather heavy handed
definition, as $\Cont_{\Ss}$ can be arbitrarily complicated. As such
it would be a bit silly to call such a notion \emph{primitive}. In a
following section we will instead try to construct initial algebras
from more primitive notions, namely the notions of natural numbers and
quotients.

\subsection{Limitations of containers}

While in the traditional setting, containers (on $\Set$) seem to be an
adequate way to characterise strictly positive functors, it has its
limitations. Let us consider the propositional truncation operation on
$\Set$: $\proptrunc{\_} : \Set \to \Set$. Let $\cont{S}{P}$ be its
container representation, then the following holds:
$$
\unitty = \proptrunc{\unitty} = (s : S) \times (P\ s \to \unitty) = S
$$
Therefore we know that that the shapes $S = \unitty$, hence
$\proptrunc{\_}$ has to be a representable functor. Let $P : \Set$ be
its representing object. $P$ has to either be empty or inhabited. If
it is empty, then we have
$\emptyty = \proptrunc{\emptyty} = \emptyty \to \emptyty = \unitty$, a
contradiction. If it is inhabited, we have
$\unitty = \proptrunc{\boolty} = P \to \boolty$, however
$P \to \boolty$ has at least two distinct inhabitants:
$\lambda x . \boolt$ and $\lambda x . boolf$, also a contradiction.

Now this limitation is not necessarily bad for the expressiveness of
our system. If we wanted to express a constructor of a type $\Aty$
such as $\Ac : \proptrunc{\Aty} \to \Aty$, we could simply ``inline''
propositional truncation, \ie add another sort $\Bty : \Set$ which has
a constructor $\Bd : \Aty \to \Bty$ and a constructor of type
$(x\ y : \Bty) \to x = y$.

\section{Initial objects in sort categories}

If we have an inductive specification with no constructors, the
category of algebras is the category of sorts. Constructing the
initial object in these categories is similar to the construction in
$\Fam$. We will construct the left adjoint to the forgetful functors
of sort categories, similar to that of $\Fam$. The forgetful functor
$\Func{\Fam}{\Set}$ has a left adjoint: the \emph{truth functor} that
maps a set $X$ to the family $\lambda x . \unitty : X \to \Set$. This
generalises to any functor in the abovementioned chain of sort
categories: suppose we have a sort specification $\Ss : \sortsty$
giving rise to the following chain of sort categories:
$$
\xymatrix{
\termcat &S_0 \ar[l]_{t_0} &S_1 \ar[l]_{t_1} &\hdots \ar[l]_{t_2} &S_n \ar[l]_{t_n}
}
$$

\begin{proposition}
Every forgetful functor $t_i : \Func{S_{i+1}}{S_i}$ has a left adjoint
\end{proposition}

\begin{proof}
  We define the functor $u_i : \Func{S_i}{S_{i+1}}$ as follows:
  \begin{itemize}
  \item on objects: $u_i X \ddefeq (X , \lambda x . \unitty)$
  \item on morphisms: $u_i f \ddefeq (f , \lambda a\ x . x)$
  \end{itemize}
  We then have to check whether we have for any $X : | S_i |$ and
  $(Y,Q) : | S_{i+1} |$ that
  $$
  S_{i+1}(u_i\ X , (Y,Q)) = S_i(X,Y)
  $$
  which we can show by simple equational reasoning:
  \begin{align*}
      &&S_{i+1}(u_i\ X , (Y,Q)) \\
    &=& S_{i+1}((X,\lambda x . \unitty), (Y,Q)) \\
    &=& (f : S_i(X,Y) \times (g : (a : R_{i+1} X) \to \unitty \to \unitty) \\
    &=& S_i(X,Y)
  \end{align*}

\end{proof}

\begin{proposition}
  There exists an adjunction between $S_0$ and $\Set$
\end{proposition}

\begin{proof}
  Note that $S_0$ is equivalent to a category with objects
  $A \to \Set$ for some $A : \Set$ and morphisms between
  $P, Q : A \to \Set$ being dependent functions
  $(x : A) \to P\ x \to Q\ x$. Usually $A = \unitty$, so we have a
  trivial adjunction between $S_0$ and $\Set$. Whatever the choice of
  $A$ is, we can construct the following pair of adjoint functors
  between $\Set$ and $S_0$:
  \begin{align*}
    &\Pi : \Func{S_0}{\Set} \\
    &\Pi\ P \ddefeq (x : A) \to P\ x \\
    \\
    &K : \Func{\Set}{S_0} \\
    &K\ X \ddefeq (\lambda x . X)
  \end{align*}
  We then have for any $X : \Set$ and $P : A \to \Set$ the following equality
  \begin{align*}
  S_0(LX , P) &=& (x : A) \to X \to P\ x \\
    &=& X \to (x : A) \to P\ x \\
    &=& X \to \Pi\ P
  \end{align*}
  Therefore we have that $K \dashv \Pi$.
\end{proof}

We therefore get the following chain of adjunctions:
$$
\xymatrix{
\Set \ar@/^/[r]^{K}
\ar@{}[r]|{\top} 
&S_0 \ar@/^/[l]^{\Pi} \ar@/^/[r]^{u_1} 
\ar@{}[r]|{\top} 
&S_1 \ar@/^/[l]^{t_1} \ar@/^/[r]^{u_2} 
\ar@{}[r]|{\top} 
&\hdots \ar@/^/[l]^{t_2} \ar@/^/[r]^{u_n} 
\ar@{}[r]|{\top} 
&S_n \ar@/^/[l]^{t_n}
}
$$
Since $\Set$ has an initial object, we get the initial object of any
sort category $S_i$ by following the chain of left adjoints.

\section{Initial objects via sequential colimits}
\label{sequential-colimits}

Initial algebras of endofunctors can be constructed via sequential
colimits, given some reasonable assumptions on the endofunctor. In
this section we will review this result due to Ad\'amek
\cite{Adamek1979} and see how we can use it to construct initial
dialgebras. We will also discuss how these proofs can be performed
inside type theory itself.

\begin{definition}[$\omega$-cochain]
  An $\omega$-cochain in a category $\Cc$ consists of:
  \begin{itemize}
  \item $X : \natty \to | \Cc |$
  \item $x : (n : \natty) \to \Cc(X_n , X_{n+1})$
  \end{itemize}
  \ie, we have the following diagram:
  $$
  \xymatrix{
    X_0 \ar[r]^{x_0}
    &X_1 \ar[r]^{x_1}
    &X_2 \ar[r]^{x_2}
    &X_3 \ar[r]^{x_3}
    &X_4 \ar[r]^{x_4}
    &\hdots
  }
  $$
\end{definition}

\begin{definition}[Sequential colimit]
  Given an $\omega$-cochain $(X,x)$, the colimit of $(X,x)$ consists
  of:
  \begin{itemize}
  \item An object $X_\omega : | \Cc |$
  \item $c : (n : \natty) \to \Cc(X_n,X_\omega)$ its constructors
  \item $g : (n : \natty) \to c_n = c_{n+1} \circ x_n$
  \end{itemize}
  with satisfies the universal property that for any other cocone $(Y,d,h)$ we get:
  \begin{itemize}
  \item a unique $f : \Cc(X_\omega, Y)$
  \item with computation rule $f \circ c_n = d_n$
  \end{itemize}
\end{definition}

\begin{theorem}[Ad\'amek]
  \label{adamek-thm}
  Let $\Cc : \Cat$ be a category with an endofunctor
  $F : \Func{\Cc}{\Cc}$. The category of algebras $\algcat{F}$ has an
  initial object if $\Cc$ has sequential colimits and an initial
  object and $F$ preserves these colimits.
\end{theorem}

\begin{proof}
  Define $X_\omega$ as the colimit of the cochain:
  $$
  \xymatrix{
    \initobj \ar[r]^{\inithom} 
    &F\ \initobj \ar[r]^{F \inithom} 
    &F^2\ \initobj \ar[r]^{F^2 \inithom} 
    &F^3\ \initobj \ar[r]^{F^3 \inithom} 
    &F^4\ \initobj \ar[r] 
    &\hdots
  }
  $$
  We get the following:
  \begin{itemize}
  \item $c_n : \Cc(F^n \initobj , X_\omega)$
  \item $g_n : c_n = c_{n+1} \circ F^n \inithom$
  \end{itemize}
  along with the universal property giving us a recursion
  principle. Similarly for $F X_\omega$: since $F$ preserves
  sequential colimits, we have that $F X_\omega$ is the colimit of the
  cochain formed by applying $F$ to the one given above, hence we have:
  \begin{itemize}
  \item $F c_n : \Cc(F^{n+1} \initobj, F X_\omega)$
  \item $F g_n : c'_n = F c_n \circ F^{n+1} \inithom$
  \end{itemize}
  We can define the algebra structure on $X_\omega$ by employing the
  recursion principle of $F X_\omega$. We define $\theta$ to be the
  morphism with computation rule, for any $n : \natty$:
  $$
  \theta \circ F c_n = c_{n+1}
  $$
  
  Now that we have an algebra, we need to show that it is
  initial. Suppose $(Y,\rho)$ is an $F$-algebra, then we first show
  that we get an algebra morphism $(X_\omega , \theta) \to
  (Y,\rho)$.
  $Y$ comes equipped with a cocone by virtue of its algebra structure,
  defined as follows:
  $$
  \xymatrix{
    \initobj \ar[r]^{\inithom}
    \ar[d]_{\inithom}
    &F\ \initobj \ar[r]^{F \inithom} 
    \ar[d]_{F \inithom}
    &F^2\ \initobj \ar[r]^{F^2 \inithom} 
    \ar[d]_{F^2 \inithom}
    &F^3\ \initobj \ar[r]^{F^3 \inithom} 
    \ar[d]_{F^3 \inithom}
    &\hdots
    \\
    Y
    &F\ Y \ar[l]^{\rho} 
    &F^2\ Y \ar[l]^{F \rho} 
    &F^3\ Y \ar[l]^{F^2 \rho} 
    &\hdots \ar[l]^{F^3 \rho}  
  }
  $$
  We have the cocone $(Y,y_n)$ where $y_n$ is defined recursively:
  \begin{align*}
    &y : (n : \natty) \to \Cc(F^n \initobj, Y) \\
    &y\ 0 \ddefeq\ \inithom \\
    &y\ (n+1) \ddefeq \rho \circ F y_n
  \end{align*}
  It is immediate from this definition that we have
  $y_n = y_{n+1} \circ F^n \inithom$, hence $(Y,y_n)$ is indeed a
  cocone.

  We can now define $f : \Cc(X_\omega, Y)$ by recursion, satisfying
  the computation rule:
  $$
  f \circ c_n = y_n
  $$
  Now we need to establish whether $f \circ \theta = \rho \circ F
  f$.
  Both the left hand and right hand side are cocone morphisms
  $(F X_\omega , F c_n) \to (Y , y_n)$:
  \begin{align*}
    f \circ \theta \circ F c_n &=& f \circ c_{n+1} \\
    &=&y_{n+1}
  \end{align*}
  and
  \begin{align*}
    \rho \circ F f \circ F c_n &=& \rho \circ F (f \circ c_n) \\
    &=&\rho \circ F y_n \\
    &=&y_{n+1}
  \end{align*}
  By the universal property of $F X_\omega$ they are indeed equal. The
  same line of reasoning can be used to established that if we have
  another algebra morphism $f' : (X_\omega,\theta) \to (Y,\rho)$, then
  $f = f'$, which shows initiality of $(X_\omega,\theta)$.
\end{proof}

\subsection{Internal sequential colimits}

The definition of sequential colimits is presented in such a way that
we can straightforwardly formalise it in type theory. The same goes
for Ad\'amek's theorem. We can also show internally that $\Set$ has
sequential colimits, if we have an internal version of coequalisers at
hand.

\begin{proposition}
  We can construct sequential colimits in $\Set$ from the natural
  numbers and coequalisers.
\end{proposition}

\begin{proof}
  Suppose we have $X : \natty \to \Set$ with
  $x : (n : \natty) \to X_n \to X_{n+1}$. Define the function $f$:
  \begin{align*}
    &f : (n : \natty) \times X_n \to (n : \natty) \times X_n \\
    &f\ (n , a) \ddefeq (n + 1 , x_n\ a)
  \end{align*}
  We define $X_\omega$ to be the coequaliser:
  $$
  \xymatrix{
    (n : \natty) \times X_n
    \ar@<.5ex>[r]^{\id}
    \ar@<-.5ex>[r]_{f}
    &(n : \natty) \times X_n
    \ar[r]^-{c}
    &X_\omega
  }
  $$
  We therefore get for any $(n , a) : (n : \natty) \times X_n$:
  $$
  c\ (n , a) = c\ (n + 1 , x_n\ a)
  $$
  Hence we get a cocone for the $\omega$-cochain. Its universal
  property follows directly from the universal property of the
  coequaliser.
\end{proof}

We can generalise the result to arbitrary categories easily, but this
does not help us much as constructing coproducts in categories of
algebras is rather involved, and already involves sequential colimits
themselves.

\subsection{$\Set$-sorted quotient inductive-inductive definitions}

Before we try to tackle the general case, we will look at the
simplified setting of $\Set$-sorted inductive-inductive
definitions. Our ultimate goal is to show that for any $\Set$-sorted
$s : \specty$, where all the functors preserve sequential colimits, we
have a left adjoint to the forgetful functor
$U : \Func{\Alg_s}{\Set}$. We can do this by induction on the
specification $s$. To construct this left adjoint for a category
$\Alg_s$ extended with a point or path constructor, we need to have
sequential colimits, coequalisers and binary coproducts in $\Alg_s$.

$\Set$ satisfies all these conditions, so the base case of the
induction holds. In the next two sections we will to the inductive
step for point and path constructors respectively.

\subsubsection{Point constructors}

If we have $\Alg_s$ with an adjunction
$L \dashv U : \Func{\Alg_s}{\Set}$ and a functor
$F : \Func{\Alg_s}{\Set}$, then the category of $(F,U)$-dialgebras is
equivalent to the category of $(L \circ F)$-algebras. As such, we can
focus our attention on the properties of categories of algebras of
endofunctors. Also note that since $L$ is a left adjoint, it preserves
colimits, hence $L \circ F$ also preserves sequential colimits.

It suffices to show that if a category $\Cc$ has sequential colimits,
binary coproducts and coequalisers and $F$ is an endofunctor on $\Cc$
preserving colimits, then $\algcat{F}$ also has sequential colimits,
binary coproducts and coequalisers and furthermore a left adjoint from
$\Cc$ to the forgetful functor.

In the following we will assume that $\Cc$ is a category with
sequential colimits, binary coproducts and coequalisers and that $F$
is an endofunctor on $\Cc$ preserving sequential colimits.

\begin{proposition}
  The category $\algcat{F}$ has sequential colimits.
\end{proposition}

\begin{proof}
  Suppose we have the following cochain in $\algcat{F}$:
  $$
  \xymatrix{
    (X_0,\theta_0) \ar[r]^{x_0}
    &(X_1,\theta_1) \ar[r]^{x_1} 
    &(X_2,\theta_1) \ar[r]^{x_2} 
    &(X_3,\theta_1) \ar[r]^{x_3}
    &(X_4,\theta_1) \ar[r]
    &\hdots
  }
  $$
  This means we have the following diagram in $\Cc$:
  $$
  \xymatrix{
    F X_0 \ar[r]^{F x_0} \ar[d]_{\theta_0}
    &F X_1 \ar[r]^{F x_1} \ar[d]_{\theta_1}
    &F X_2 \ar[r]^{F x_2} \ar[d]_{\theta_2}
    &F X_3 \ar[r]^{F x_3} \ar[d]_{\theta_3}
    &F X_4 \ar[r] \ar[d]_{\theta_4} 
    &\hdots
    \\
    X_0 \ar[r]_{x_0}
    &X_1 \ar[r]_{x_1}
    &X_2 \ar[r]_{x_2}
    &X_3 \ar[r]_{x_3}
    &X_4 \ar[r]
    &\hdots
  }
  $$
  We can take the colimit of the bottom sequence $(X_i,x_i)$, which
  will have an algebra structure as $F$ preserves colimits of
  cochains. However, we need to make sure that all the inclusion maps
  $X_i \to X_\omega$ are algebra morphisms.
\end{proof}

\begin{proposition}
  The category $\algcat{F}$ has binary coproducts.
\end{proposition}

\begin{proof}
  \todoi{do this}
\end{proof}

\begin{proposition}
  The category $\algcat{F}$ has coequalisers.
\end{proposition}

\begin{proposition}
  The forgetful functor $U : \Func{\algcat{F}}{\Cc}$ has a left
  adjoint.
\end{proposition}

\begin{proof}
  \todoi{do this}
\end{proof}

\subsubsection{Path constructors}
\todo{This is related to the ``On the Construction of Free Algebras
  for Equational Systems'' paper}

Suppose we have a category $\Cc : \Cat$ with an adjunction
$L \dashv U : \Func{\Cc}{\Set}$. In our case $\Cc$ will be a category
of algebras and $U$ its forgetful functor. To describe a 1-constructor
on $\Cc$, we need the following data:
\begin{itemize}
\item $F : \Func{\Cc}{\Set}$, describing the arguments of the constructor
\item $l, r : \Nat{F}{U}$, giving the end points of the equations
\end{itemize}

\begin{proposition}
  If $\Cc$ has sequential colimits and $F$ preserves them, then
  subcategory $\Cc$ of objects $X : | \Cc |$ together with an equality
  $l_X = r_X$ has an initial object.
\end{proposition}

\begin{proof}
  Since we have $L \dashv U$, we have isomorphisms
  $$
  \phi_{X,Y} : \Cc(L X , Y) \to (X \to U Y)
  $$
  $\phi$ is natural in both $X$ and $Y$, hence we have natural
  transformations:
  $$
  \phi \circ l , \phi \circ r : \Nat{L \circ F}{\id_{\Cc}}
  $$
  It suffices to show that we have an initial object in the
  subcategory of $\Cc$ of objects $X : | \Cc |$ satisfying
  $\phi \circ l_X = \phi \circ r_X$.

  We define $X_\omega$ to be the colimit of the following cochain in $\Cc$:
  $$
  \xymatrix{
    &LF X_0
    \ar@<.5ex>[d]^{\phi \circ l_{X_0}}
    \ar@<-.5ex>[d]_{\phi \circ r_{X_0}}
    &LF X_1
    \ar@<.5ex>[d]^{\phi \circ l_{X_1}}
    \ar@<-.5ex>[d]_{\phi \circ r_{X_1}}
    &LF X_2 
    \ar@<.5ex>[d]^{\phi \circ l_{X_2}}
    \ar@<-.5ex>[d]_{\phi \circ r_{X_2}}
    &LF X_3
    \ar@<.5ex>[d]^{\phi \circ l_{X_3}}
    \ar@<-.5ex>[d]_{\phi \circ r_{X_3}}
    &LF X_4
    \ar@<.5ex>[d]^{\phi \circ l_{X_4}}
    \ar@<-.5ex>[d]_{\phi \circ r_{X_4}}
    \\
    \initobj \ar@{}[r]|{\ddefeq} 
    &X_0
    \ar[r]_{x_0}
    &X_1
    \ar[r]_{x_1}
    &X_2 
    \ar[r]_{x_2}
    &X_3
    \ar[r]_{x_3}
    &X_4
    \ar[r]_{x_4}
    &\hdots
    }
  $$
  That is, the $\omega$-cochain $(X,x)$ is defined as:
  \begin{align*}
    &X : (n : \natty) \to | \Cc | \\
    &X\ 0 \ddefeq \initobj \\
    &X\ (n+1) \ddefeq \coeqty{\phi \circ l_{X_n}}{\phi \circ r_{x_n}}
  \end{align*}
  with $x_0$ the initial morphism and $x_{n+1}$ the constructor of
  corresponding coequaliser.

  We need to show that for $X_\omega$,
  $\phi \circ l_{X_\omega} = \phi \circ r_{X_\omega}$. This we will
  achieve by showing that $X_\omega$ has a cocone structure for the
  cochain $(LFX_n, LFx_n)$. Both $\phi \circ l_{X_\omega}$ and
  $\phi \circ r_{X_\omega}$ are cocone morphisms
  $LF X_\omega \to X_\omega$, which means that by the universal
  property of $LF X_\omega$ they must be equal.

  For $X_\omega$ we have:
  \begin{itemize}
  \item constructors $d_n : \Cc(X_n, X_\omega)$
  \item satisfying $d_n = d_{n+1} \circ x_n$
  \end{itemize}

  $F$ preserves sequential colimits and $L$ preserves all colimits as
  it is a left adjoint, hence $L \circ F$ preserves sequential
  colimits. We then have that $LFX_\omega$ is the colimit of the
  $\omega$-cochain $(LFX_n,x_n)$ and therefore have:
  \begin{itemize}
  \item constructors $LFd_n : \Cc(LFX_n, LFX_\omega)$
  \item satisfying $LFd_n = LFd_{n+1} \circ LFx_n)$
  \end{itemize}

  We define the $(LFX_n,LFx_n)$-cocone on $X_\omega$ with $z_n$ as the
  composite:
  $$
  \xymatrix{
    LFX_n
    \ar[r]^{\phi \circ l_n}
    &X_n
    \ar[r]^{d_n}
    &X_\omega
  }
  $$
  Note that it does not matter whether we use $l$ or $r$ here, as
  $d_n = x_n \circ d_{n+1}$ and $x_n$ is the coequaliser map, hence
  precomposing with $\phi \circ l$ or $\phi \circ r$ is going to yield
  the same result.

  We have to check that $z_n = z_{n+1} \circ LFx_n$, which holds as we
  have the following commutative diagram:
  $$
  \xymatrix{
    LFX_n
    \ar[r]^{\phi \circ l_n}
    \ar[d]_{LF x_n}
    &X_n
    \ar[r]^{d_n}
    \ar[d]^{x_n}
    &X_\omega
    \\
    LFX_{n+1}
    \ar[r]_{\phi \circ l_{n+1}}
    &X_{n+1}
    \ar[ur]_{d_{n+1}}
  }
  $$
  The left square holds by naturality of $\phi \circ l$, the right
  square holds as $X_\omega$ is a colimit with $d_n$ is constructors.
  
  Now we have constructed a $(LFX_n,LFx_n)$-cocone structure on
  $X_\omega$, we need to check whether $\phi \circ l_{X_\omega}$ and
  $\phi \circ r_{X_\omega}$ are indeed cocone morphisms. This amounts
  to checking whether the following commutes:
  $$
  \xymatrix{
    LFX_n
    \ar[r]^{LF d_n}
    \ar[d]_{\phi \circ l_{X_n}}
    &LFX_\omega
    \ar[d]^{\phi \circ l_{X_\omega}}
    \\
    X_n
    \ar[r]_{d_n}
    &X_\omega
  }
  $$

  This square commutes by naturality of $\phi \circ l$. By the same
  reasoning $\phi \circ r_{X_\omega}$ is a cocone morphism, hence by
  the universal property of $LFX_\omega$ we get that
  $\phi \circ l_{X_\omega} = \phi \circ r_{X_\omega}$.
  \todo{Check whether this object is initial}

\end{proof}

\todo{Show that this construction is a generlisation to the
  construction of prop. truncation as a colimit}

Now we have shown that the subcategory has an initial object, we need
to strengthen the result to showing that we actually have an
adjunction between the inclusion functor and some free functor that we
have to construct. This free functor can be constructed in much the
same way as one constructs the free algebra functor, \ie using the
same sequential colimit techniques.

\todoi{Prove that we get an adjunction between $\Cc$ and its subcategory}

\todoi{Establish existence of coequalisers in categories of algebras}

\subsection{Related concepts}

The constructions here are similar to those found in the literature in
slightly different settings. The construction of colimits in are found
in \todoi{this}.
