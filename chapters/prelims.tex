\chapter{Preliminaries}

In this chapter we will introduce the type theoretic background
material for the thesis. We introduce notation and basic propositions
and lemmata that we will use throughout the thesis. As we will be
using category theoretic approaches, the chapter is concluded with our
approach to category theory in type theory.

\section{Basic type formers}
In type theory we can form $\Pi$-types, or dependent functions, given
a type $A$ and for every $a : A$ a type $B\ a$, we have the type:
$$
(x : A) \to B\ a
$$
Traditionally this is denoted as $\Pi (x : A) . B\ a$. We will use
Agda's notation for $\Pi$-types instead. The introduction rule for
$\Pi$-types is that if we have $x : A$ in our context and a term
$b : B\ x$, then we can form the term:
$$
\lambda x . b : (x : A) \to B\ x
$$
$\Pi$-types have an elimination rule, called \emph{application}: if
$f : (x : A) \to B\ x$ and $x : A$, then $f\ x : B\ x$. Terms of
$\Pi$-types are subject to two classes of definitional equalities,
$\beta$-equality:
$$
(\lambda x . e)\ y \defeq e[x/y]
$$
where $e[x/y]$ denotes the substitution of every occurence in $e$ of
$x$ with $y$. Furthermore we have $\eta$-equality, for every
$f : (x : A) \to B\ x$:
$$
f \defeq \lambda x . f\ x
$$
Note that if the codomain of a $\Pi$-type does not refer to elements
of its domain, \ie when we have a non-dependent function, we denote it
as $A \to B$.

Apart from $\Pi$-types, we also have $\Sigma$-types, or dependent
pairs/products. The type formation rule is similar to that of
$\Pi$-types: if we have a type $A$ such that if we have $a : A$ in our
context, the term $B\ a$ is a type, then we have that the following is a type:
$$
(x : A) \times B\ a
$$
This is traditionally written as $\Sigma (x : A) . B\ a$, but we are
using the \emph{Capriotti notation} here, which mimicks Agda's
notation for $\Pi$-types.

\subsection{Universes}

Another basic type is the type whose inhabitants themselves are again
types, the universe $\Type$. Using such a universe, we can now
rephrase the type formation for $\Pi$-types as having a term:
$$
\Pi : (A : \Type) \to (B : A \to \Type) \to \Type
$$
Such a universe may not have the property that $\Type : \Type$ as that
gives rise to a paradox, similar to Russell's paradox in set
theory. Instead, we have a hierarchy of universes:
$$
\Type_0 : \Type_1 : \Type_2 : \hdots
$$
While avoiding the paradox, this hierarchy brings a lot of complexity
to our language in terms of usability. Every time we use a universe,
we have to explicitly indicate its level, cluttering our terms.

One solution to this problem is to leave the level indices implicit
and let the type checker infer them, if there exists a valid
substitution. This is the approach Coq takes.

Another problem is that we may want to give definitions that can be
instantiated to more than one level. If we want to define a function
composition operator, we would like that it works for functions
between types of any level. In Agda, we have the notion of
\emph{universe polymorphism}. We can define terms such as:
\begin{align*}
  &\id : (n : \Level) (A : \Type_n) \to A \to A \\
  &\id\ n\ A\ x \ddefeq x
\end{align*}
The function $\id$ is polymorphic over all levels $n$. While this
saves us from having to define $\id$ for any level, universe
polymorphism does introduce some complexity of its own. $\Level$ is
\emph{not} a type, which means that while
$(n : \Level) (A : \Type_n) \to A \to A$ is a valid Agda
\emph{expression}, it is not a type, \ie it is not an inhabitant of
$\Type_i$ for any $i : \Level$.

In this thesis we will leave the universe levels implicit. The
formalisation in Agda of course makes them explicit and uses universe
polymorphism where applicable.

\subsection{Implicit arguments}

An important feature of Agda is that we can denote arguments of a
function as being an \emph{implicit argument}. One use case is the
aforementioned universe levels. If we consider again the type and
definition of $\id$, with implicit arguments, we can write:
\begin{align*}
&\id : {n : \Level} {A : \Type_n} \to A \to A \\
&\id\ x \ddefeq x
\end{align*}
The idea here is that the context in which a function is called gives
information we can use to fill in the blanks: if we call $\id$ with a
certain argument, we know the type of the argument and in turn also
know the universe level of that type. Sometimes the context does not
contain enough information to resolve the holes left by the implicit
arguments.

\subsection{Inductive data types}

As mentioned in the introduction, an important feature to have in a
type theory is to have a way to define custom inductive data types. In
Agda, one can define an inductive type by giving a list of
constructors. For example, the natural numbers can be defined as
follows:
\begin{datatype}{\natty}{\Type}
  \constr{\natzero}{\natty} \\
  \constr{\natsucc}{\natty \to \natty}
\end{datatype}
We will often use Agda-like notation to give
definitions/specifications of inductive types.

Two trivial, yet important types we will use are the empty and the
unit types, which can be defined as inductive types:
\begin{datatype}{\emptyty}{\Type}
\end{datatype}
%
\begin{datatype}{\unitty}{\Type}
  \constr{\unitval}{\unitty}
\end{datatype}
%
The ``smallest non-trivial'' data type, $\boolty$ can also be defined
inductively:
\begin{datatype}{\boolty}{\Type}
  \constr{\booltrue}{\boolty} \\
  \constr{\boolfalse}{\boolty}
\end{datatype}

Such a declaration in Agda does not give us the elimination principle
directly. Instead Agda has a notion of \emph{dependent pattern
  matching}: we write our functions out of inductive types by matching
against the possible constructors of said types. These function
definitions may be recursive, as long as the recursive occurrences are
on a subterm of the pattern. Dependent pattern matching has been shown
to be equivalent to having eliminators, assuming all types satisfy
uniqueness of identity proofs. Moreover, the translation of pattern
matching definitions into definitions with eliminators does not always
preserve definitional equalities.

As opposed to adding inductive types to the theory in an ad hoc
manner, one can add W-types as a primitive and define all inductive
types in terms of this primitive. W-types are enough to give us
ordinary inductive types as well as indexed inductive types.

In this thesis, the inductive definitions we need to formalise the
theory of quotient inductive-inductive types, can all be written using
W-types. However, for sake of convenience and presentational clarity,
we will use Agda its notation to present these.

\section{Equality}

\begin{definition}
  Given a type $A : \Type$ and $x, y : A$, we define the type
  $x = y : \Type$, with constructor:
  $$
  \refl : (x : A) \to x = x
  $$

  The elimination principle for the identity type is:
  \begin{align*}
  \J : &(A : \Type)\ (P : (x\ y : A) \to x = y \to \Type)\ \\
  &(m : (x : A) \to P\ x\ x\ (\refl\ x)) \\
  &\to (x\ y : A)\ (p : x = y) \to P\ x\ y\ p
  \end{align*}
  which satisfies the computation rule:
  $$
  \J\ A\ P\ m\ x\ x\ (\refl\ x) \defeq m\ x
  $$
\end{definition}

\begin{lemma}
  Given a type $A : \Type$, the identity types form an equivalence
  relation on $A$.
\end{lemma}

\begin{proof}
  We need to show that the relation $\_ = \_ : A \to A \to \Type$ is
  reflexive, symmetric and transitive. Reflexivity we immediately get
  from the $\refl$ constructor. For symmetry we need to appeal to the
  elimination principle. Let $p : x = y$, we define $\sym{p} : y = x$:
  $$
  \sym{p} \ddefeq \J\ A\ (\lambda x\ y\ p . y = x)\ (\lambda x . \refl\ x)\ x\ y\ p
  $$
  For transitivity, we need an operation:
  $$
  \trans{\_}{\_} : x = y \to y = z \to x = z
  $$
  This can be defined by path induction on any of combination of its
  arguments.
\end{proof}

\begin{lemma}
  The identity types on a type $A : \Type$ form a groupoid with
  respect to propositional equality.
\end{lemma}

\begin{proof}
  The identity types on $A$ form a groupoid with transitivity as its
  composition, its inverses given by symmetry and the unit being
  reflexivity. These operations need to adhere to the following laws:
  \begin{itemize}
  \item associativity: $(p : x = y) (q : y = z) (r : z = w) \to \trans{(\trans{p}{q})}{r} = \trans{p}{(\trans{q}{r})}$
  \item left identity: $(p : x = y) \to \trans{\refl_x}{p} = p$
  \item right identity: $(p : x = y) \to \trans{p}{\refl_y} = p$
  \item left inverse: $(p : x = y) \to \trans{\sym{p}}{p} = \refl_y$
  \item right inverse: $(p : x = y) \to \trans{p}{\sym{p}} = \refl_x$
  \end{itemize}
  These can all be shown to hold by straightforward path induction.
\end{proof}

\begin{remark}
  The computational properties of transitivity obviously depend on how
  it is defined: we either get the left identity or the right identity
  law to hold definitionally if we perform path induction on one
  argument. If it is defined by path induction on both arguments, we
  get neither law ``for free''. We can make a new definition of
  propositional equality on top of the original one, which satisfies
  the category laws definitionally, as we will see in
  \cref{alt-identity-type}.
\end{remark}

Since identity types are types again, they themselves are also
equipped with a groupoid structure. We can always consider identity
types of identity types of identity types, et cetera. Such an infinite
tower of groupoids on top of eachother is called an \inftygrpd. An
external proof of the fact that every type gives rise to an \inftygrpd
has been given. Internally this has not been shown yet, as one first
needs an internal definition of \inftygrpd.

\subsection{Truncation levels}

If we consider the tower of identity types for a specific type $A$, it
is sometimes the case that after several levels the identity types
\emph{vanish}, \ie they are equivalent to the unit type. Another way
of stating that a type is equivalent to the unit type is that it is
\emph{contractible}:

\begin{definition}
  A type $A$ is \emph{contractible} if there exists a ``central''
  point $c : A$ such that every point is connected to the centre via
  an equality:
  \begin{align*}
    &\iscontr : (A : \Type) \to \Type \\
    &\iscontr A \ddefeq (c : A) \times ((x : A) \to c = x)
  \end{align*}
\end{definition}

We can show that the identity types for a contractible type are again
contractible: $\iscontr\ A \to (x\ y : A) \to \iscontr\ (x = y)$. The
level at which the identity types vanish is the so called
\emph{truncation level} or \emph{h-level} of the type:
\begin{definition}
  A type has truncation level $n : \natty_{-2}$, if we have a proof of
  $\istrunc{n}\ A$ where $\istrunc{n}$ is defined recursively over $n$:
  \begin{align*}
    &\istrunc{n} : (A : \Type) \to \Type \\
    &\istrunc{-2}\ A \ddefeq \iscontr\ A \\
    &\istrunc{n+1}\ A \ddefeq (x\ y : A) \to \istrunc{n}\ (x = y)
  \end{align*}
\end{definition}

For our purposes, there are two important truncation levels, apart
from contractibility:
\begin{definition}
  A type is a \emph{proposition} or \emph{propositional} if it has
  truncation level $-1$.
\end{definition}

A useful characterisation of propositions is given by the following
proposition:
\begin{proposition}
  If the type $A$ satisfies $(x\ y : A) \to x = y$ then $A$ is
  propositional.
\end{proposition}
From this characterisation, we immediately see that if $A$ is
propositional, then it is either empty or contractible, \ie uniquely
inhabited up to propositional equality. Of course, we do not have an
internal proof of
$(A : \Type) \to \isprop\ A \to (A \to \emptyty) + (\iscontr\ A)$.

The next truncation level, level $0$, are the so called sets:
\begin{definition}
  A type is a \emph{set} if it has truncation level $0$, \ie for all
  $x, y : A$, $x = y$ is propositional.
\end{definition}
The property of being a set is also called ``uniqueness of identity
proofs''.

\subsection{Equivalence}

We have a notion of equality on types, so far have not talked in great
detail about equality on a universe of types, \ie equality
\emph{between} types.

A very weak notion of types being equal is ``logical equivalence'':
\begin{definition}
  Types $A$ and $B$ are \emph{logically equivalent} if we have
  functions $A \to B$ and $B \to A$:
  \begin{align*}
    &A \logequiv B : \Type \\
    &A \logequiv B \ddefeq (A \to B) \times (B \to A)
  \end{align*}
\end{definition}

With logical equivalence we do not have any requirements on the two
functions between the two types, just that there exist any. There
being a logical equivalence is also not a proposition: the type
$\boolty \logequiv \boolty$ has two distinct inhabitants:
$(\id_{\boolty} , \id_{\boolty})$ and $(\boolnot , \boolnot)$.

The notion of isomorphism also requires the two functions to be
eachother's inverses:
\begin{definition}[Isomorphism]
  Types $A$ and $B$ are \emph{isomorphic} if they are eachother's
  inverse:
  \begin{align*}
    &\Iso{A}{B} : \Type \\
    &\Iso{A}{B} \ddefeq (f : A \to B) \times (g : B \to A)  \\
    &\ \ \ \ \ \ \times ((x : A) \to g\ (f\ a) = a) \times ((y : B) \to f\ (g\ y) = y)
  \end{align*}
\end{definition}

\begin{definition}[Equivalence]
  
\end{definition}



\subsection{Univalence}

\begin{definition}[Univalence]
  
\end{definition}

\subsection{Function extensionality}

\begin{lemma}
  Univalence implies function extensionality
\end{lemma}

\subsection{Singleton contraction}

\begin{proposition}
  For any type $A : \Type$ and $a : A$, we have the following
  equivalence:
  $$
  ((x : A) \times (x = a)) = \unitty
  $$
\end{proposition}

\begin{proof}
  This follows directly from path induction.
\end{proof}

The type $(x : A) \times (x = a)$ is called a \emph{singleton}. This
fact is very useful in equational reasoning. It is comparable to high
school algebra where multiplying by $\frac{a}{a}$ for a cleverly
chosen expression $a$, or recognising that two factors cancel
eachother out, are a useful techniques.

\subsection{Alternative formulation of identity types}
\label{alt-identity-type}
We have seen that the identity types form a groupoid on its underlying
type. The unit and associativity laws do not hold definitionally for
this groupoid. When reasoning about equalities \emph{between} paths,
it can be annoying if we have to take associativity into account. For
example, suppose we want to prove
$a \ct p \ct (\sym{p} \ct b) = a \ct b$, for some expressions $a$ and
$b$. The easiest way to prove this is by applying path induction to
$p$, which will reduce the goal to $a \ct b = a \ct b$. However,
sometimes we are in comparable situations where we cannot perform path
induction on all of the paths involved.
\begin{align*}
  &a \ct p \ct (\sym{p} \ct b) \\
  &= \\
  &a \ct ((p \ct \sym{p}) \ct b) \\
  &= \\
  &a \ct (\refl \ct b) \\
  &= \\
  &a \ct b
\end{align*}

We can define an alternative formulation of identity types which have
different computational properties. This formulation is based on the
insight that functions on $\Type$ do satisfy the associativity and
unit laws definitionally with respect to function composition.

Identity types satisfy a form of the Yoneda lemma and that $\Type$
comes with a strict categorical structure.

\begin{lemma}[Yoneda lemma for identity types]
  
\end{lemma}

\begin{proof}
  Straightforward proof by path induction.
\end{proof}

\section{Category theory in type theory}

When defining the concept of category in type theory, we have to make
several choices. A naive way of defining a category would be as the
following $\Sigma$-type:
$$
\Cat \ddefeq (obj : \Type) \times (hom : obj \to obj \to \Type) \times (\hdots)
$$
where on the place of the ellipsis one would have to fill in the
category structure and laws. 

\begin{definition}[Category]
  We define the type $\Cat : \Type$ as the following $\Sigma$-type:
  %
  \begin{align*}
    \Cat &\ddefeq &&(obj : \Type) \\
         &\times &&(hom : obj \to obj \to \Type) \\
         &\times &&(hom-is-set : (X\ Y : obj) \to \isset (hom\ X\ Y)) \\
         &\times &&(id : (X : obj) \to hom\ X\ X) \\
         &\times &&(comp : \{\ X\ Y\ Z : obj\ \} \to hom\ Y\ Z \to hom\ X\ Y \to hom\ X\ Z) \\
         &\times &&(left-id : \{\ X\ Y : obj\ \}\ (f : hom\ X\ Y) \to comp\ (id\ Y)\ f = f) \\
         &\times &&(right-id : \{\ X\ Y : obj\ \}\ (f : hom\ X\ Y) \to comp\ f\ (id\ X) = f) \\
         &\times &&(assoc : \{\ X\ Y\ Z\ W : obj\ \}\ (h : hom\ Z\ W) (g : hom\ Y\ Z) (f : hom\ X\ Y) \\
         & &&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \to comp\ (comp\ h\ g)\ f = comp\ h\ (comp\ g\ f))
  \end{align*}
\end{definition}

The type of objects of a category $\Cc$ is denoted with $| \Cc |$. The
type of morphisms given objects $X, Y : | \Cc |$ is denoted as
$\Cc(X,Y)$.

\begin{example}
  The universe $\Set$ of types that are sets forms a category with its
  morphisms defined as functions between sets.
\end{example}

\begin{remark}
  The universe $\Type$ is \emph{not} a category in this sense, as for
  arbitrary types $X, Y$, the function space $X \to Y$ will in general
  not be a set.
\end{remark}

\begin{definition}[Functor]
  Suppose $\Cc, \Dd : \Cat$, then we define the type of functors $\Cc$
  to $\Dd$ as the following $\Sigma$-type:
  %
  \begin{align*}
    \Func{\Cc}{\Dd} &\ddefeq &&(obj : | \Cc | \to | \Dd |) \\
    &\times &&(hom : \{\ X\ Y : | \Cc |\ \} \to \Cc(X,Y) \to \Cc(obj\ X, obj\ Y)) \\
    &\times &&(id : \{\ X : | \Cc |\ \} \to hom\ (\id_{\Cc}\ X) = \id_{\Dd}\ (obj\ X)) \\
    &\times &&(comp : \{\ X\ Y\ Z : | \Cc |\ \}\ (g : \Cc(Y,Z))\ (h : \Cc(X,Y)) \to hom\ (g \circ_{\Cc} f) = hom\ g \circ_{\Dd} hom\ f)
  \end{align*}
\end{definition}

As is usual, we will use the notation $F X$, where
$F : \Func{\Cc}{\Dd}$ and $X : | \Cc |$ for the action of $F$ on
object $X$ and $F f$ for the action on morphisms $f : \Cc(X,Y)$. When
defining functors, we will often only define the action on objects and
leave the rest implicit.

\begin{definition}
  The \emph{empty category} $\initcat$ is defined as the category with
  no objects. The \emph{unit category} $\termcat$ is defined as the
  category with one object and no non-trivial automorphisms.
\end{definition}

\begin{definition}
  The category of categories $\Cat$ is defined as a category with as
  objects categories and morphisms functors.
\end{definition}

The categories $\initcat$ and $\termcat$ are respectively initial and
terminal in the category of categories.

In ordinary category theory, done in a set theoretic metatheory,
talking about equality between \emph{objects} is \emph{evil}: doing so
allows us to write propositions that are not invariant under
equivalence of categories. In type theory we have a type of equalities
between any type, so ...

\begin{definition}[Isomorphism]
  Let $X, Y : | \Cc |$ for some $\Cc : \Cat$, then the type of
  isomorphisms between $X$ and $Y$ is defined as:
  \begin{align*}
    \Iso{X}{Y} &\ddefeq &&(to : X \to Y) \\
               &\times &&(from : Y \to X) \\
               &\times &&(from-to : from \circ to = \id_{\Cc}\ X) \\
               &\times &&(to-from : to \circ to = \id_{\Cc}\ Y)
  \end{align*}
\end{definition}

\begin{definition}[Univalent category]
  A category $\Cc$ is called \emph{univalent} if for any two objects
  $X, Y : | \Cc |$ we have the following equivalence:
  $$
  \Iso{X}{Y} = (X = Y)
  $$  
\end{definition}

\begin{proposition}
  The category $\Set$ is univalent.
\end{proposition}

\begin{proof}
  This follows directly from univalence for the universe $\Type$.
\end{proof}

\subsection{Higher categories}

As mentioned before, the universe of types $\Type$ does not form a
category if we take functions as morphisms. Function spaces will in
general not be sets. However, we can define composition and identity
morphisms in the usual way. These will satisfy the category laws
definitionally as well.

We can relax the definition of category to not have hom-\emph{sets}
but hom-\emph{types}. Composition and identity morphisms still make
sense with this generalisation. We may run into issues with the
category \emph{laws}: in some situations it is not enough to simply
have the laws, they also need to be coherent in some sense: the
interaction of the laws with eachother needs to satisfy certain laws
as well. Naturally, how these coherence laws interact also has to
adhere to additional higher coherence laws, ad infinitum.

Stating all these coherence properties in a uniform way in type theory
itself is currently still an open problem. One approach to solve this
problem is to extend the theory with an \emph{internal} notion of
strict equality. This then allows us to define Segal \emph{types},
mimicking the usual constructions on bisimplicial sets.

Alternatively, one can define simplicial sets and bisimplicial sets in
type theory and use these to define \inftycats with. This means
however that we the type of objects is a bisimplicial set, which is
not a convenient object to work with in type theory.

In some cases, such as $\Type$ and $\Fam$ the category of families,
the category laws are satisfied strictly, which means all the
coherence laws are also satisfied trivially.
