\chapter{Preliminaries}

\section{Basic type formers}
In type theory we can form $\Pi$-types, or dependent functions, given
a type $A$ and for every $a : A$ a type $B\ a$, we have the type:
$$
(x : A) \to B\ a
$$
Traditionally this is denoted as $\Pi (x : A) . B\ a$. We will use
Agda's notation for $\Pi$-types instead. The introduction rule for
$\Pi$-types is that if we have $x : A$ in our context and a term
$b : B\ x$, then we can form the term:
$$
\lambda x . b : (x : A) \to B\ x
$$
$\Pi$-types have an elimination rule, called \emph{application}: if
$f : (x : A) \to B\ x$ and $x : A$, then $f\ x : B\ x$. Terms of
$\Pi$-types are subject to two classes of definitional equalities,
$\beta$-equality:
$$
(\lambda x . e)\ y \defeq e[x/y]
$$
where $e[x/y]$ denotes the substitution of every occurence in $e$ of
$x$ with $y$. Furthermore we have $\eta$-equality, for every
$f : (x : A) \to B\ x$:
$$
f \defeq \lambda x . f\ x
$$
Note that if the codomain of a $\Pi$-type does not refer to elements
of its domain, \ie when we have a non-dependent function, we denote it
as $A \to B$.

Apart from $\Pi$-types, we also have $\Sigma$-types, or dependent
pairs/products. The type formation rule is similar to that of
$\Pi$-types: if we have a type $A$ such that if we have $a : A$ in our
context, the term $B\ a$ is a type, then we have that the following is a type:
$$
(x : A) \times B\ a
$$
This is traditionally written as $\Sigma (x : A) . B\ a$, but we are
using the \emph{Capriotti notation} here, which mimicks Agda's
notation for $\Pi$-types.

\subsection{Universes}



\subsection{Inductive data types}

\section{Equality}

\begin{definition}
  Given a type $A : \Type$ and $x, y : A$, we define the type
  $x = y : \Type$, with constructor:
  $$
  \refl : (x : A) \to x = x
  $$

  The elimination principle for the identity type is:
  \begin{align*}
  \J : &(A : \Type)\ (P : (x\ y : A) \to x = y \to \Type)\ \\
  &(m : (x : A) \to P\ x\ x\ (\refl\ x)) \\
  &\to (x\ y : A)\ (p : x = y) \to P\ x\ y\ p
  \end{align*}
  which satisfies the computation rule:
  $$
  \J\ A\ P\ m\ x\ x\ (\refl\ x) \defeq m\ x
  $$
\end{definition}

\begin{lemma}
  Given a type $A : \Type$, the identity types form an equivalence
  relation on $A$.
\end{lemma}

\begin{proof}
  We need to show that the relation $\_ = \_ : A \to A \to \Type$ is
  reflexive, symmetric and transitive. Reflexivity we naturally get
  from the $\refl$ constructor. For symmetry we need to appeal to the
  elimination principle. Let $p : x = y$, we define $\sym{p} : y = x$:
  $$
  \sym{p} \ddefeq \J\ A\ (\lambda x\ y\ p . y = x)\ (\lambda x . \refl\ x)\ x\ y\ p
  $$
\end{proof}

\begin{lemma}
  The identity types on a type $A : \Type$ form a groupoid with
  respect to propositional equality.
\end{lemma}

\begin{proof}
  
\end{proof}

\subsection{Truncation levels}

\subsection{Equivalence}

\begin{definition}
  Types $A$ and $B$ are \emph{logically equivalent} if we have
  functions $A \to B$ and $B \to A$.
\end{definition}

\begin{definition}[Isomorphism]
  
\end{definition}

\begin{definition}[Equivalence]
  
\end{definition}



\subsection{Univalence}

\begin{definition}[Univalence]
  
\end{definition}

\subsection{Function extensionality}

\begin{lemma}
  Univalence implies function extensionality
\end{lemma}

\subsection{Singleton contraction}

\begin{proposition}
  For any type $A : \Type$ and $a : A$, we have the following
  equivalence:
  $$
  ((x : A) \times (x = a)) = \unitty
  $$
\end{proposition}

\begin{proof}
  This follows directly from path induction.
\end{proof}

The type $(x : A) \times (x = a)$ is called a \emph{singleton}. This
fact is very useful in equational reasoning. It is comparable to high
school algebra where multiplying by $\frac{a}{a}$ for a cleverly
chosen expression $a$ is a useful technique.

\subsection{Alternative formulation of identity types}

Given the definition of identity types above, we can define an
alternative formulation of identity types which have different
computational properties. This formulation is based on the insight
that identity types satisfy a form of the Yoneda lemma and that
$\Type$ comes with a strict categorical structure.

\begin{lemma}[Yoneda lemma for identity types]
  
\end{lemma}

\begin{proof}
  Straightforward proof by path induction.
\end{proof}

\section{Category theory in type theory}

When defining the concept of category in type theory, we have to make
several choices. A naive way of defining a category would be as the
following $\Sigma$-type:
$$
\Cat \ddefeq (obj : \Type) \times (hom : obj \to obj \to \Type) \times (\hdots)
$$
where on the place of the ellipsis one would have to fill in the
category structure and laws. 

\begin{definition}[Category]
  We define the type $\Cat : \Type$ as the following $\Sigma$-type:
  %
  \begin{align*}
    \Cat &\ddefeq &&(obj : \Type) \\
         &\times &&(hom : obj \to obj \to \Type) \\
         &\times &&(hom-is-set : (X\ Y : obj) \to \isset (hom\ X\ Y)) \\
         &\times &&(id : (X : obj) \to hom\ X\ X) \\
         &\times &&(comp : \{\ X\ Y\ Z : obj\ \} \to hom\ Y\ Z \to hom\ X\ Y \to hom\ X\ Z) \\
         &\times &&(left-id : \{\ X\ Y : obj\ \}\ (f : hom\ X\ Y) \to comp\ (id\ Y)\ f = f) \\
         &\times &&(right-id : \{\ X\ Y : obj\ \}\ (f : hom\ X\ Y) \to comp\ f\ (id\ X) = f) \\
         &\times &&(assoc : \{\ X\ Y\ Z\ W : obj\ \}\ (h : hom\ Z\ W) (g : hom\ Y\ Z) (f : hom\ X\ Y) \\
         & &&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \to comp\ (comp\ h\ g)\ f = comp\ h\ (comp\ g\ f))
  \end{align*}
\end{definition}

The type of objects of a category $\Cc$ is denoted with $| \Cc |$. The
type of morphisms given objects $X, Y : | \Cc |$ is denoted as
$\Cc(X,Y)$.

\begin{example}
  The universe $\Set$ of types that are sets forms a category with its
  morphisms defined as functions between sets.
\end{example}

\begin{remark}
  The universe $\Type$ is \emph{not} a category in this sense, as for
  arbitrary types $X, Y$, the function space $X \to Y$ will in general
  not be a set.
\end{remark}

\begin{definition}[Functor]
  Suppose $\Cc, \Dd : \Cat$, then we define the type of functors $\Cc$
  to $\Dd$ as the following $\Sigma$-type:
  %
  \begin{align*}
    \Func{\Cc}{\Dd} &\ddefeq &&(obj : | \Cc | \to | \Dd |) \\
    &\times &&(hom : \{\ X\ Y : | \Cc |\ \} \to \Cc(X,Y) \to \Cc(obj\ X, obj\ Y)) \\
    &\times &&(id : \{\ X : | \Cc |\ \} \to hom\ (\id_{\Cc}\ X) = \id_{\Dd}\ (obj\ X)) \\
    &\times &&(comp : \{\ X\ Y\ Z : | \Cc |\ \}\ (g : \Cc(Y,Z))\ (h : \Cc(X,Y)) \to hom\ (g \circ_{\Cc} f) = hom\ g \circ_{\Dd} hom\ f)
  \end{align*}
\end{definition}

As is usual, we will use the notation $F X$, where
$F : \Func{\Cc}{\Dd}$ and $X : | \Cc |$ for the action of $F$ on
object $X$ and $F f$ for the action on morphisms $f : \Cc(X,Y)$. When
defining functors, we will often only define the action on objects and
leave the rest implicit.

In ordinary category theory, done in a set theoretic metatheory,
talking about equality between \emph{objects} is \emph{evil}: doing so
allows us to write propositions that are not invariant under
equivalence of categories. In type theory we have a type of equalities
between any type, so ...

\begin{definition}[Isomorphism]
  Let $X, Y : | \Cc |$ for some $\Cc : \Cat$, then the type of
  isomorphisms between $X$ and $Y$ is defined as:
  \begin{align*}
    \Iso{X}{Y} &\ddefeq &&(to : X \to Y) \\
               &\times &&(from : Y \to X) \\
               &\times &&(from-to : from \circ to = \id_{\Cc}\ X) \\
               &\times &&(to-from : to \circ to = \id_{\Cc}\ Y)
  \end{align*}
\end{definition}

\begin{definition}[Univalent category]
  A category $\Cc$ is called \emph{univalent} if for any two objects
  $X, Y : | \Cc |$ we have the following equivalence:
  $$
  \Iso{X}{Y} = (X = Y)
  $$  
\end{definition}

\begin{proposition}
  The category $\Set$ is univalent.
\end{proposition}

\begin{proof}
  This follows directly from univalence for the universe $\Type$.
\end{proof}

\subsection{Higher categories}

As mentioned before, the universe of types $\Type$ does not form a
category if we take functions as morphisms. Function spaces will in
general not be sets. However, we can define composition and identity
morphisms in the usual way. These will satisfy the category laws
definitionally as well.

We can relax the definition of category to not have hom-\emph{sets}
but hom-\emph{types}. Composition and identity morphisms still make
sense with this generalisation. We may run into issues with the
category \emph{laws}: in some situations it is not enough to simply
have the laws, they also need to be coherent in some sense: the
interaction of the laws with eachother needs to satisfy certain laws
as well. Naturally, how these coherence laws interact also has to
adhere to additional higher coherence laws, ad infinitum.

Stating all these coherence properties in a uniform way in type theory
itself is currently still an open problem. One approach to solve this
problem is to extend the theory with an \emph{internal} notion of
strict equality. This then allows us to define Segal \emph{types},
mimicking the usual constructions on bisimplicial sets.

Alternatively, one can define simplicial sets and bisimplicial sets in
type theory and use these to define \inftycats with. This means
however that we the type of objects is a bisimplicial set, which is
not a convenient object to work with in type theory.

In some cases, such as $\Type$ and $\Fam$ the category of families,
the category laws are satisfied strictly, which means all the
coherence laws are also satisfied trivially.
