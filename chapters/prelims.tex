\chapter{Preliminaries}

\section{Basic type formers}



\section{Equality}

\begin{definition}
  Given a type $A : \Type$ and $x, y : A$, we define the type
  $x = y : \Type$, with constructor:
  $$
  \refl : (x : A) \to x = x
  $$

  The elimination principle for the identity type is:
  \begin{align*}
  \J : &(A : \Type)\ (P : (x\ y : A) \to x = y \to \Type)\ \\
  &(m : (x : A) \to P\ x\ x\ (\refl\ x)) \\
  &\to (x\ y : A)\ (p : x = y) \to P\ x\ y\ p
  \end{align*}
  which satisfies the computation rule:
  $$
  \J\ A\ P\ m\ x\ x\ (\refl\ x) \defeq m\ x
  $$
\end{definition}

\begin{lemma}
  Given a type $A : \Type$, the identity types form an equivalence
  relation on $A$.
\end{lemma}

\begin{proof}
  We need to show that the relation $\_ = \_ : A \to A \to \Type$ is
  reflexive, symmetric and transitive. Reflexivity we naturally get
  from the $\refl$ constructor. For symmetry we need to appeal to the
  elimination principle. Let $p : x = y$, we define $\sym{p} : y = x$:
  $$
  \sym{p} \ddefeq \J\ A\ (\lambda x\ y\ p . y = x)\ (\lambda x . \refl\ x)\ x\ y\ p
  $$
\end{proof}

\begin{lemma}
  The identity types on a type $A : \Type$ form a groupoid with
  respect to propositional equality.
\end{lemma}

\begin{proof}
  
\end{proof}

\subsection{Truncation levels}

\subsection{Equivalence}

\begin{definition}
  Types $A$ and $B$ are \emph{logically equivalent} if we have
  functions $A \to B$ and $B \to A$.
\end{definition}

\begin{definition}[Isomorphism]
  
\end{definition}

\begin{definition}[Equivalence]
  
\end{definition}



\subsection{Univalence}

\begin{definition}[Univalence]
  
\end{definition}

\subsection{Function extensionality}

\begin{lemma}
  Univalence implies function extensionality
\end{lemma}

\subsection{Alternative formulation of identity types}

Given the definition of identity types above, we can define an
alternative formulation of identity types which have different
computational properties. This formulation is based on the insight
that identity types satisfy a form of the Yoneda lemma and that
$\Type$ comes with a strict categorical structure.

\begin{lemma}[Yoneda lemma for identity types]
  
\end{lemma}

\begin{proof}
  Straightforward proof by path induction.
\end{proof}

\section{Category theory in type theory}

When defining the concept of category in type theory, we have to make
several choices. A naive way of defining a category would be as the
following $\Sigma$-type:
$$
\Cat \ddefeq (obj : \Type) \times (hom : obj \to obj \to \Type) \times (\hdots)
$$
where on the place of the ellipsis one would have to fill in the
category structure and laws. 

\begin{definition}[Category]
  We define the type $\Cat : \Type$ as the following $\Sigma$-type:
  %
  \begin{align*}
    \Cat &\ddefeq &&(obj : \Type) \\
         &\times &&(hom : obj \to obj \to \Type) \\
         &\times &&(hom-is-set : (X\ Y : obj) \to \isset (hom\ X\ Y)) \\
         &\times &&(id : (X : obj) \to hom\ X\ X) \\
         &\times &&(comp : \{\ X\ Y\ Z : obj\ \} \to hom\ Y\ Z \to hom\ X\ Y \to hom\ X\ Z) \\
         &\times &&(left-id : \{\ X\ Y : obj\ \}\ (f : hom\ X\ Y) \to comp\ (id\ Y)\ f = f) \\
         &\times &&(right-id : \{\ X\ Y : obj\ \}\ (f : hom\ X\ Y) \to comp\ f\ (id\ X) = f) \\
         &\times &&(assoc : \{\ X\ Y\ Z\ W : obj\ \}\ (h : hom\ Z\ W) (g : hom\ Y\ Z) (f : hom\ X\ Y) \\
         & &&\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \to comp\ (comp\ h\ g)\ f = comp\ h\ (comp\ g\ f))
  \end{align*}
\end{definition}

\begin{example}
  The universe $\Set$ of types that are sets forms a category with its
  morphisms defined as functions between sets.
\end{example}

\begin{remark}
  The universe $\Type$ is \emph{not} a category in this sense, as for
  arbitrary types $X, Y$, the function space $X \to Y$ will in general
  not be a set.
\end{remark}

\begin{definition}[Functor]
  Suppose $\Cc, \Dd : \Cat$, then we define the type of functors $\Cc$
  to $\Dd$ as the following $\Sigma$-type:
  %
  \begin{align*}
    \Func{\Cc}{\Dd} &\ddefeq &&(obj : | \Cc | \to | \Dd |) \\
    &\times &&(hom : \{\ X\ Y : | \Cc |\ \} \to \Cc(X,Y) \to \Cc(obj\ X, obj\ Y)) \\
    &\times &&(id : \{\ X : | \Cc |\ \} \to hom\ (\id_{\Cc}\ X) = \id_{\Dd}\ (obj\ X)) \\
    &\times &&(comp : \{\ X\ Y\ Z : | \Cc |\ \}\ (g : \Cc(Y,Z))\ (h : \Cc(X,Y)) \to hom\ (g \circ_{\Cc} f) = hom\ g \circ_{\Dd} hom\ f)
  \end{align*}
\end{definition}

As is usual, we will use the notation $F X$, where
$F : \Func{\Cc}{\Dd}$ and $X : | \Cc |$ for the action of $F$ on
object $X$ and $F f$ for the action on morphisms $f : \Cc(X,Y)$. When
defining functors, we will often only define the action on objects and
leave the rest implicit.

In ordinary category theory, done in a set theoretic metatheory,
talking about equality between \emph{objects} is \emph{evil}: doing so
allows us to write propositions that are not invariant under
equivalence of categories. In type theory we have a type of equalities
between any type, so ...

\begin{definition}[Isomorphism]
  Let $X, Y : | \Cc |$ for some $\Cc : \Cat$, then the type of
  isomorphisms between $X$ and $Y$ is defined as:
  \begin{align*}
    \Iso{X}{Y} &\ddefeq &&(to : X \to Y) \\
               &\times &&(from : Y \to X) \\
               &\times &&(from-to : from \circ to = \id_{\Cc}\ X) \\
               &\times &&(to-from : to \circ to = \id_{\Cc}\ Y)
  \end{align*}
\end{definition}

\begin{definition}[Univalent category]
  A category $\Cc$ is called \emph{univalent} if for any two objects
  $X, Y : | \Cc |$ we have the following equivalence:
  $$
  \Iso{X}{Y} = (X = Y)
  $$  
\end{definition}

\subsection{Higher categories}

As mentioned before, the universe of types $\Type$ does not form a
category if we take functions as morphisms. Function spaces will in
general not be sets. However, we can define composition and identity
morphisms in the usual way. These will satisfy the category laws
definitionally as well.


